.. index:: intervalp
.. _intervalp/0:

**protocol**

``intervalp``
=============

Basic temporal interval relations protocol (based on James F. Allen Interval Algebra work).

* author: Paulo Moura
* version: 1.1
* date: 2014/4/26
* compilation flags: ``static``

(no dependencies on other entities)


Public interface
----------------

.. raw:: html

   <div id="new/3"> </div>

.. index:: new/3
.. _intervalp/0::new/3:

``new/3``
^^^^^^^^^

Constructs a new interval given start and end points. The start point must strictly precede the end point.

* compilation flags: ``static``
* template: ``new(Start,End,Interval)``

* mode - number of proofs:

  * ``new(@ground,@ground,-interval)`` - ``zero_or_one``


.. raw:: html

   <div id="valid/1"> </div>

.. index:: valid/1
.. _intervalp/0::valid/1:

``valid/1``
^^^^^^^^^^^

True if Interval is a valid interval.

* compilation flags: ``static``
* template: ``valid(Interval)``

* mode - number of proofs:

  * ``valid(@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="before/2"> </div>

.. index:: before/2
.. _intervalp/0::before/2:

``before/2``
^^^^^^^^^^^^

True if Interval1 takes place before Interval2.

* compilation flags: ``static``
* template: ``before(Interval1,Interval2)``

* mode - number of proofs:

  * ``before(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="after/2"> </div>

.. index:: after/2
.. _intervalp/0::after/2:

``after/2``
^^^^^^^^^^^

True if Interval1 takes place after Interval2.

* compilation flags: ``static``
* template: ``after(Interval1,Interval2)``

* mode - number of proofs:

  * ``after(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="meets/2"> </div>

.. index:: meets/2
.. _intervalp/0::meets/2:

``meets/2``
^^^^^^^^^^^

True if Interval1 meets Interval2.

* compilation flags: ``static``
* template: ``meets(Interval1,Interval2)``

* mode - number of proofs:

  * ``meets(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="met_by/2"> </div>

.. index:: met_by/2
.. _intervalp/0::met_by/2:

``met_by/2``
^^^^^^^^^^^^

True if Interval1 is met by Interval2.

* compilation flags: ``static``
* template: ``met_by(Interval1,Interval2)``

* mode - number of proofs:

  * ``met_by(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="overlaps/2"> </div>

.. index:: overlaps/2
.. _intervalp/0::overlaps/2:

``overlaps/2``
^^^^^^^^^^^^^^

True if Interval1 overlaps with Interval2.

* compilation flags: ``static``
* template: ``overlaps(Interval1,Interval2)``

* mode - number of proofs:

  * ``overlaps(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="overlapped_by/2"> </div>

.. index:: overlapped_by/2
.. _intervalp/0::overlapped_by/2:

``overlapped_by/2``
^^^^^^^^^^^^^^^^^^^

True if Interval1 is overlapped by Interval2.

* compilation flags: ``static``
* template: ``overlapped_by(Interval1,Interval2)``

* mode - number of proofs:

  * ``overlapped_by(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="starts/2"> </div>

.. index:: starts/2
.. _intervalp/0::starts/2:

``starts/2``
^^^^^^^^^^^^

True if Interval1 starts Interval2.

* compilation flags: ``static``
* template: ``starts(Interval1,Interval2)``

* mode - number of proofs:

  * ``starts(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="started_by/2"> </div>

.. index:: started_by/2
.. _intervalp/0::started_by/2:

``started_by/2``
^^^^^^^^^^^^^^^^

True if Interval1 is started by Interval2.

* compilation flags: ``static``
* template: ``started_by(Interval1,Interval2)``

* mode - number of proofs:

  * ``started_by(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="during/2"> </div>

.. index:: during/2
.. _intervalp/0::during/2:

``during/2``
^^^^^^^^^^^^

True if Interval1 occurs during Interval2.

* compilation flags: ``static``
* template: ``during(Interval1,Interval2)``

* mode - number of proofs:

  * ``during(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="contains/2"> </div>

.. index:: contains/2
.. _intervalp/0::contains/2:

``contains/2``
^^^^^^^^^^^^^^

True if Interval1 contains Interval2.

* compilation flags: ``static``
* template: ``contains(Interval1,Interval2)``

* mode - number of proofs:

  * ``contains(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="finishes/2"> </div>

.. index:: finishes/2
.. _intervalp/0::finishes/2:

``finishes/2``
^^^^^^^^^^^^^^

True if Interval1 finishes Interval2.

* compilation flags: ``static``
* template: ``finishes(Interval1,Interval2)``

* mode - number of proofs:

  * ``finishes(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="finished_by/2"> </div>

.. index:: finished_by/2
.. _intervalp/0::finished_by/2:

``finished_by/2``
^^^^^^^^^^^^^^^^^

True if Interval1 is finished by Interval2.

* compilation flags: ``static``
* template: ``finished_by(Interval1,Interval2)``

* mode - number of proofs:

  * ``finished_by(@interval,@interval)`` - ``zero_or_one``


.. raw:: html

   <div id="equal/2"> </div>

.. index:: equal/2
.. _intervalp/0::equal/2:

``equal/2``
^^^^^^^^^^^

True if Interval1 is equal to Interval2.

* compilation flags: ``static``
* template: ``equal(Interval1,Interval2)``

* mode - number of proofs:

  * ``equal(@interval,@interval)`` - ``zero_or_one``


Protected interface
-------------------

(none)

Private predicates
------------------

(none)

Operators
---------

(none)

Remarks
-------

(none)

See also
--------

(none)

