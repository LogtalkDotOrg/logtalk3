<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright (c) 1998-2012 Paulo Moura <pmoura@logtalk.org>
%  
%  Logtalk is free software. You can redistribute it and/or modify it under
%  the terms of the FSF GNU General Public License 3  (plus some additional
%  terms per section 7).        Consult the `LICENSE.txt` file for details.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: predicates</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div> 
<div class="top-right">Predicates</div>
<div class="bottom-left"><span class="page"/></div> 
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Predicates</div>

<h1 id="predicates_predicates">Predicates</h1>

<p>
Predicate directives and clauses can be encapsulated inside objects and categories. Protocols can only contain predicate directives. From the point-of-view of an object-oriented language, predicates allows both object state and object behavior to be represented. Mutable object state can be represented using dynamic object predicates.
</p>
<p>
In order to avoid possible conflicts with internal entity predicates generated by the Logtalk compiler, predicates whose functor start with an underscore should be avoided.
</p>

<h2 id="predicates_declaring">Declaring predicates</h2>

<p>
All object (or category) predicates that we want to access from other objects must be explicitly declared. A predicate declaration must contain, at least, a scope directive. Other directives may be used to document the predicate or to ensure proper compilation of the predicate definitions.
</p>
<p>
Predicate directives should always precede the corresponding predicate definitions and/or calls in the source files in order to ensure proper compilation.
</p>

<h3 id="predicates_scope">Scope directives</h3>

<p>
A predicate can be <em>public</em>, <em>protected</em>, <em>private</em>, or <em>local</em>. Public predicates can be called from any object. Protected predicates can only be called from the container object or from a container descendant. Private predicates can only be called from the container object. Local predicates, like private predicates, can only be called from the container object (or category) but they are <em>invisible</em> to the reflection built-in methods (<code>current_op/3</code>, <code>current_predicate/1</code>, and <code>predicate_property/2</code>) and to the message error handling mechanisms (i.e. sending a message corresponding to a local predicate results in a <code>predicate_declaration</code> existence error, not in a scope error).
</p>
<p>
The scope declarations are made using the directives <a title="Consult reference manual" href="../refman/directives/public1.html"><code>public/1</code></a>, <a title="Consult reference manual" href="../refman/directives/protected1.html"><code>protected/1</code></a>, and <a title="Consult reference manual" href="../refman/directives/private1.html"><code>private/1</code></a>. For example:
</p>
<pre>:- public(init/1).

:- protected(valid_init_option/1).

:- private(process_init_options/1).</pre>
<p>
If a predicate does not have a scope declaration, it is assumed that the predicate is local. Note that we do not need to write scope declarations for all defined predicates. One exception is local dynamic predicates: declaring them as private predicates may allow the Logtalk compiler to generate optimized code for asserting and retracting clauses.
</p>

<h3 id="predicates_mode">Mode directive</h3>

<p>
Many predicates cannot be called with arbitrary arguments with arbitrary instantiation status. The valid arguments and instantiation modes can be documented by using the <a title="Consult reference manual" href="../refman/directives/mode2.html"><code>mode/2</code></a> directive. For instance:
</p>
<pre>:- mode(member(?term, +list), zero_or_more).</pre>
<p>
The first argument describes a valid calling mode. The minimum information will be the instantiation mode of each argument. There are four possible values (described in <a title="ISO Prolog Standard" href="../bibliography.html#ISO95">[ISO 95]</a>):
</p>
<dl>
	<dt><code>+</code></dt>
		<dd>Argument must be instantiated.</dd>
	<dt><code>-</code></dt>
		<dd>Argument must be a free (non-instantiated) variable.</dd>
	<dt><code>?</code></dt>
		<dd>Argument can either be instantiated or free.</dd>
	<dt><code>@</code></dt>
		<dd>Argument will not be modified.</dd>
</dl>
<p>
These four mode atoms are also declared as prefix operators by the Logtalk compiler. This makes it possible to include type information for each argument like in the example above. Some of the possible type values are: <code>event</code>, <code>object</code>, <code>category</code>, <code>protocol</code>, <code>callable</code>, <code>term</code>, <code>nonvar</code>, <code>var</code>, <code>atomic</code>, <code>atom</code>, <code>number</code>, <code>integer</code>, <code>float</code>, <code>compound</code>, and <code>list</code>. The first four are Logtalk specific. The remaining are common Prolog types. We can also use our own types that can be either atoms or compound terms. 
</p>
<p>
The second argument documents the number of proofs (or solutions) for the specified mode. The possible values are:
</p>
<dl>
	<dt><code>zero</code></dt>
		<dd>Predicate always fails.</dd>
	<dt><code>one</code></dt>
		<dd>Predicate always succeeds once.</dd>
	<dt><code>zero_or_one</code></dt>
		<dd>Predicate either fails or succeeds.</dd>
	<dt><code>zero_or_more</code></dt>
		<dd>Predicate has zero or more solutions.</dd>
	<dt><code>one_or_more</code></dt>
		<dd>Predicate has one or more solutions.</dd>
	<dt><code>error</code></dt>
		<dd>Predicate will throw an error (see below).</dd>
</dl>
<p>
Mode declarations can also be used to document that some call modes will throw an error. For instance, regarding the <code>arg/3</code> ISO Prolog built-in predicate, we may write:
</p>
<pre>:- mode(arg(-, -, +), error).</pre> 
<p>
Note that most predicates have more than one valid mode implying several mode directives. For example, to document the possible use modes of the <code>atom_concat/3</code> ISO built-in predicate we would write:
</p>
<pre>:- mode(atom_concat(?atom, ?atom, +atom), one_or_more).
:- mode(atom_concat(+atom, +atom, -atom), zero_or_one).</pre>
<p>
Some old Prolog compilers supported some sort of mode directives to improve performance. To the best of my knowledge, there is no modern Prolog compiler supporting these kind of directive. The current version of the Logtalk compiler just parses and than discards this directive (however, see the description on <a title="Consult user manual" href="threads.html#threads_synchronized_predicates">synchronized predicates</a> on the <a title="Consult user manual" href="threads.html">multi-threading programming</a> section). Nevertheless, the use of mode directives is a good starting point for documenting your predicates.
</p>

<h3 id="predicates_meta">Meta-predicate directive</h3>

<p>
Some predicates may have arguments that will be called as goals or closures that will be used for constructing a call. To ensure that these calls and closures will be executed in the correct scope (i.e. in the calling context, not in the meta-predicate definition context) we need to use the <a title="Consult reference manual" href="../refman/directives/meta_predicate1.html"><code>meta_predicate/1</code></a> directive. For example:
</p>
<pre>:- meta_predicate(findall(*, 0, *)).</pre>
<p>
The meta-predicate mode arguments in this directive have the following meaning:
</p>
<dl>
	<dt><code>0</code></dt>
		<dd>Meta-argument that will be called as a goal.</dd>
	<dt><code>N</code></dt>
		<dd>Meta-argument that will be a closure used to construct a call by appending <code>N</code> arguments at the end. The value of <code>N</code> must be a non-negative integer.</dd>
	<dt><code>::</code></dt>
		<dd>Argument that is context-aware but that will not be called as a goal.</dd>
	<dt><code>/</code></dt>
		<dd>Predicate indicator.</dd>
	<dt><code>^</code></dt>
		<dd>Existentially quantified goal (<code>Vars^Goal</code>).</dd>
	<dt><code>[0]</code></dt>
		<dd>List of goals.</dd>
	<dt><code>[/]</code></dt>
		<dd>List of predicate indicators (<code>Functor/Arity</code>).</dd>
	<dt><code>*</code></dt>
		<dd>Normal argument.</dd>
</dl>
<p>
To the best of my knowledge, the use of non-negative integers to specify closures has first introduced on Quintus Prolog for providing information for predicate cross-reference tools.
</p>
<p>
The <code>meta_predicate/1</code> directive must precede the meta-predicate definition and any local calls to the meta-predicate in order to ensure proper compilation. In addition, as each Logtalk entity is independently compiled, this directive must be included in every object or category that contains a definition for the described predicate, even if the predicate declaration is inherited from another entity, to ensure proper compilation of meta-arguments.
</p>

<h3 id="predicates_discontiguous">Discontiguous directive</h3>

<p>
The clause of an object (or category) predicate may not be contiguous. In that case, we must declare the predicate discontiguous by using the <a title="Consult reference manual" href="../refman/directives/discontiguous1.html"><code>discontiguous/1</code></a> directive:
</p>
<pre>:- discontiguous(foo/1).</pre>
<p>
This is a directive that we should avoid using: it makes your code harder to read and it is not supported by some Prolog compilers.
</p>
<p>
As each Logtalk entity is compiled independently from other entities, this directive must be included in every object or category that contains a definition for the described predicate (even if the predicate declaration is inherited from other entity).
</p>

<h3 id="predicates_dynamic">Dynamic directive</h3>

<p>
An object predicate can be static or dynamic. By default, all object predicates are static. To declare a dynamic predicate we use the <a title="Consult reference manual" href="../refman/directives/dynamic1.html"><code>dynamic/1</code></a> directive:
</p>
<pre>:- dynamic(foo/1).</pre>
<p>
This directive may also be used to declare dynamic grammar rule non-terminals. As each Logtalk entity is compiled independently from other entities, this directive must be included in every object that contains a definition for the described predicate (even if the predicate declaration is inherited from other object or imported from a category). If we omit the dynamic declaration then the predicate definition will be compiled static. In the case of dynamic objects, static predicates cannot be redefined using the database built-in methods (despite being internally compiled to dynamic code).
</p>
<p>
Note that static objects may declare and define dynamic predicates.
</p>

<h3 id="predicates_op">Operator directive</h3>

<p>
An object (or category) predicate can be declared as an operator using the familiar <a title="Consult reference manual" href="../refman/directives/op3.html"><code>op/3</code></a> directive:
</p>
<pre>:- op(Priority, Specifier, Operator).</pre>
<p>
Operators are local to the object (or category) where they are declared. This means that, if you declare a public predicate as an operator, you cannot use operator notation when sending to an object (where the predicate is visible) the respective message (as this would imply visibility of the operator declaration in the context of the <em>sender</em> of the message). If you want to declare global operators and, at the same time, use them inside an entity, just write the corresponding directives at the top of your source file, before the entity opening directive.
</p>
<p>
When the same operators are used on several entities within the same source file, the corresponding directives must appear before any entity that uses them. However, this results in a global scope for the operators. If you prefer the operators to be local to the source file, just <em>undefine</em> them at the end of the file. For example:
</p>
<pre>:- op(400, xfx, results).  % before any entity that uses the operator

...

:- op(0, xfx, results).    % after all entities that used the operator</pre>

<h3 id="predicates_uses">Uses directive</h3>

<p>
When a predicate makes heavy use of predicates defined on other objects, its predicate clauses can be verbose due to all the necessary message sending goals. Consider the following example:
</p>
<pre>foo :-
    ...,
    findall(X, list::member(X, L), A),
    list::append(A, B, C),
    list::select(Y, C, R),
    ...</pre>
<p>
Logtalk provides a directive, <a title="Consult reference manual" href="../refman/directives/uses2.html"><code>uses/2</code></a>, which allows us to simplify the code above. The usage template for this directive is:
</p>
<pre>:- uses(Object, [Functor1/Arity1, Functor2/Arity2, ...]).</pre>
<p>
Rewriting the code above using this directive results in a simplified and more readable predicate definition:
</p>
<pre>:- uses(list,
    [append/3, member/2, select/3]).

    foo :-
        ...,
        findall(X, member(X, L), A),
        append(A, B, C),
        select(Y, C, R),
        ...</pre>
<p>
Logtalk also supports an extended version of this directive that allows the declaration of predicate alias using the notation <code>Predicate::Alias</code>. For example:
</p>
<pre>:- uses(btrees, [new/1::new_btree/1]).
:- uses(queues, [new/1::new_queue/1]).</pre>
<p>
You may use this extended version for solving conflicts between predicates declared on several <code>uses/2</code> directives or just for giving new names to the predicates that will be more meaningful on their using context.
</p>
<p>
The <code>uses/2</code> directive allows simpler predicate definitions as long as there are no conflicts between the predicates declared in the directive and the predicates defined in the object (or category) containing the directive. A predicate (or its alias if defined) cannot be listed in more than one <code>uses/2</code> directive. In addition, a <code>uses/2</code> directive cannot list a predicate (or its alias if defined) which is defined in the object (or category) containing the directive. Any conflicts are reported by Logtalk as compilation errors.
</p>
<p>
In the current Logtalk version, the omission of the <code>Object::</code> prefix is not supported when the predicate call occurs as an argument of a user-defined meta-predicate (Logtalk specified meta-predicates and Prolog non-standard meta-predicates declared in the adapter files pose no problem).
</p>

<h3 id="predicates_alias">Alias directive</h3>

<p>
Logtalk allows the definition of an alternative name for an inherited or imported predicate (or for an inherited or imported grammar rule non-terminal) through the use of the <a title="Consult reference manual" href="../refman/directives/alias3.html"><code>alias/3</code></a> directive:
</p>
<pre>:- alias(Entity, Predicate, Alias).</pre>
<p>
This directive can be used in objects, protocols, or categories. The first argument, <code>Entity</code>, must be an entity referenced in the opening directive of the entity contain the <code>alias/3</code> directive. It can be an implemented protocol, an imported category, an extended prototype, an instantiated class, or a specialized class. The second and third arguments are predicate indicators (or grammar rule non-terminal indicators).
</p>
<p>
A common use for the <code>alias/3</code> directive is to give an alternative name to an inherited predicate in order to improve readability. For example:
</p>
<pre>:- object(square,
    extends(rectangle)).

    :- alias(rectangle, width/1, side/1).

    ...

:- end_object.</pre>
<p>
The directive allows both <code>width/1</code> and <code>side/1</code> to be used as messages to the object <code>square</code>. Thus, using this directive, there is no need to explicitly declare and define a "new" <code>side/1</code> predicate. Note that the <code>alias/3</code> directive does not rename a predicate, only provides an alternative, additional name; the original name continues to be available.
</p>
<p>
Another common use for this directive is to solve conflicts when two inherited predicates have the same functor and arity. We may want to call the predicate which is masked out by the Logtalk lookup algorithm (see the <a href="inheritance.html">Inheritance</a> section) or we may need to call both predicates. This is simply accomplished by using the <code>alias/3</code> directive to give alternative names to masked out or conflicting predicates. Consider the following example:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, member/2, list_member/2).
    :- alias(set, member/2, set_member/2).

    ...

:- end_object.</pre>
<p>
Assuming that both <code>list</code> and <code>set</code> objects define a <code>member/2</code> predicate, without the <code>alias/3</code> directives, only the definition of <code>member/2</code> predicate in the object <code>list</code> would be visible on the object <code>my_data_structure</code>, as a result of the application of the Logtalk predicate lookup algorithm. By using the <code>alias/3</code> directives, all the following messages would be valid (assuming a public scope for the predicates):
</p>
<pre>| ?- my_data_structure::list_member(X, L).    % uses list member/2

| ?- my_data_structure::set_member(X, L).     % uses set member/2

| ?- my_data_structure::member(X, L).         % uses list member/2</pre>
<p>
When used this way, the <code>alias/3</code> directive provides functionality similar to programming constructs of other object-oriented languages which support multi-inheritance (the most notable example probably being the renaming of inherited features in Eiffel).
</p>
<p>
Note that the <code>alias/3</code> directive never hides a predicate which is visible on the entity containing the directive as a result of the Logtalk lookup algorithm. However, it may be used to make visible a predicate which otherwise would be masked by another predicate, as illustrated in the above example.
</p>
<p>
The <code>alias/3</code> directive may also be used to give access to an inherited predicate, which otherwise would be masked by another inherited predicate, while keeping the original name as follows:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, member/2, list_member/2).
    :- alias(set, member/2, set_member/2).

    member(X, L) :-
        ::set_member(X, L).

    ...

:- end_object.</pre>
<p>
Thus, when sending the message <code>member/2</code> to <code>my_data_structure</code>, the predicate definition in <code>set</code> will be used instead of the one contained in <code>list</code>.
</p>

<h3 id="predicates_info">Documenting directive</h3>

<p>
A predicate can be documented with arbitrary user-defined information by using the <a title="Consult reference manual" href="../refman/directives/info2.html"><code>info/2</code></a> directive:
</p>
<pre>:- info(Functor/Arity, List).</pre>
<p>
The second argument is a list of <code>Key is Value</code> terms. See the <a href="documenting.html">Documenting Logtalk programs</a> session for details.
</p>

<h3 id="predicates_multifile">Multifile directive</h3>

<p>
A predicate can be declared <em>multifile</em> by using the <a title="Consult reference manual" href="../refman/directives/multifile1.html"><code>multifile/1</code></a> directive:
</p>
<pre>:- multifile(Functor/Arity).</pre>
<p>
This allows clauses for a predicate to be defined in several objects or categories. This is a directive that should be used with great care. Support for this directive have been added to Logtalk primarily to support migration of Prolog module code. Spreading clauses for a predicate among several Logtalk entities can be handy in special cases but can also make your code difficult to understand. Logtalk precludes using a multifile predicate for breaking object encapsulation by checking that the object declaring the predicate (using a scope directive) defines it also as multifile. This object is said to contain the <em>primary declaration</em>for the multifile predicate. In addition, note that the <code>multifile/1</code> directive is mandatory when defining multifile predicates.
</p>
<p>
Consider the following simple example:
</p>
<pre>
:- object(main).

    :- public(a/1).
    :- multifile(a/1).
    a(1).

:- end_object.


:- object(other).

    :- multifile(main::a/1).
    main::a(2).
    main::a(3).

:- end_object.
</pre>
<p>
After compiling and loading the above objects, you can use queries such as:
</p>
<pre>
| ?- main::a(X).

X = 1 ;
X = 2 ;
X = 3
yes
</pre>
<p>
The Logtalk compiler will print a warning if the <code>multifile/1</code> directive is missing. Multifile predicates may also be declared dynamic using the same <code>Entity::Functor/Arity</code> notation (multifile predicates are static by default).
</p>
<p>
When a clause of a multifile predicate is a rule, its body is compiled within the context of the object or category containing the clause. This allows clauses for multifile predicates to call local object or category predicates. However, clauses for multifile predicates should avoid calling the execution context methods. With the clause head defined in one entity and the clause body defined in another entity, there is no clear semantics for the values of <em>sender</em>, <em>self</em>, or <em>this</em>.
</p>

<h3 id="predicates_coinductive">Coinductive directive</h3>

<p>
A predicate can be declared <em>coinductive</em> by using the <a title="Consult reference manual" href="../refman/directives/coinductive1.html"><code>coinductive/1</code></a> directive. For example:
</p>
<pre>:- coinductive(comember/2).</pre>
<p>
Logtalk support for coinductive predicates is experimental and requires a back-end Prolog compiler with minimal support for cyclic terms.
</p>

<h2 id="predicates_defining">Defining predicates</h2>

<h3 id="predicates_objects">Object predicates</h3>

<p>
We define object predicates as we have always defined Prolog predicates, the only difference be that we have four more control structures (the three message sending operators plus the external call operator) to play with. For example, if we wish to define an object containing common utility list predicates like <code>append/2</code> or <code>member/2</code> we could write something like:
</p>
<pre>:- object(list).

    :- public(append/3).
    :- public(member/2).

    append([], L, L).
    append([H| T], L, [H| T2]) :-
        append(T, L, T2).

    member(H, [H| _]).
    member(H, [_| T]) :-
        member(H, T).

:- end_object.</pre>
<p>
Note that, abstracting from the opening and closing object directives and the scope directives, what we have written is plain Prolog.  Calls in a predicate definition body default to the local predicates, unless we use the message sending operators or the external call operator. This enables easy conversion from Prolog code to Logtalk objects: we just need to add the necessary encapsulation and scope directives to the old code.
</p>

<h3 id="predicates_categories">Category predicates</h3>

<p>
Because a category can be imported by several different objects, dynamic private predicates must be called using the <a title="Consult reference manual" href="../refman/control/to_self1.html"><code>::/1</code></a> message sending operator. This ensures that the correct predicate definition will be used. For example, if we want to define a category implementing variables using destructive assignment we could write:
</p>
<pre>:- category(variable).

    :- public(get/2).
    :- public(set/2).

    :- private(value_/2).
    :- dynamic(value_/2).

    get(Var, Value) :-
        ::value_(Var, Value).

    set(Var, Value) :-
        ::retractall(value_(Var, _)), 
        ::asserta(value_(Var, Value).

:- end_category.</pre>
<p>
This way, each importing object will have its own definition for the <code>value_/2</code> private predicate. Furthermore, the <code>get/2</code> and <code>set/2</code> predicates will always access/update the correct definition, contained in the object receiving the messages.
</p>
<p>
A category may only contain clauses for static predicates. Nevertheless, as the example above illustrates, there are no restrictions in declaring and calling dynamic predicates from inside a category.
</p>

<h3 id="predicates_metadef">Meta-predicates</h3>

<p>
Meta-predicates may be defined inside objects (and categories) as any other predicate. A meta-predicate is declared using the <code>meta_predicate/1</code> directive as described earlier on this section. When defining a meta-predicate, the arguments in the clause heads corresponding to the meta-arguments must be variables. All meta-arguments are called in the context of the object calling the meta-predicate (either directly or through message sending).
</p>
<p>
Some meta-predicates have meta-arguments which are not goals but closures. Logtalk supports the definition of meta-predicates that are called with closures instead of goals as long as the definition uses the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/methods/callN.html"><code>call/N</code></a> to call the closure with the additional arguments. For example:
</p>
<pre>:- public(all_true/2).
:- meta_predicate(all_true(1, *)).

all_true(_, []).
all_true(Closure, [Arg| Args]) :-
    call(Closure, Arg),
    all_true(Closure, Args).</pre>
<p>
Note that the meta-predicate directive specifies that the closure will be extended with exactly one extra argument.
</p>

<h3 id="predicates_dcgs">Definite clause grammar rules</h3>

<p>
Definite clause grammar rules provide a convenient notation to represent the rewrite rules common of most grammars in Prolog. In Logtalk, definite clause grammar rules can be encapsulated in objects and categories. Currently, the ISO/IEC WG17 group is working on a draft specification for a definite clause grammars Prolog standard. Therefore, in the mean time, Logtalk follows the common practice of Prolog compilers supporting definite clause grammars, extending it to support calling grammar rules contained in categories and objects. A common example of a definite clause grammar is the definition of a set of rules for parsing simple arithmetic expressions:
</p>
<pre>:- object(calculator).

    :- public(parse/2).

    parse(Expression, Value) :-
        phrase(expr(Value), Expression).

    expr(Z) --&gt; term(X), "+", expr(Y), {Z is X + Y}.
    expr(Z) --&gt; term(X), "-", expr(Y), {Z is X - Y}.
    expr(X) --&gt; term(X).

    term(Z) --&gt; number(X), "*", term(Y), {Z is X * Y}.
    term(Z) --&gt; number(X), "/", term(Y), {Z is X / Y}.
    term(Z) --&gt; number(Z).

    number(C) --&gt; "+", number(C).
    number(C) --&gt; "-", number(X), {C is -X}.
    number(X) --&gt; [C], {0'0 =&lt; C, C =&lt; 0'9, X is C - 0'0}.

:- end_object. </pre>
<p>
The predicate <a title="Consult reference manual" href="../refman/methods/phrase2.html"><code>phrase/2</code></a> called in the definition of predicate <code>parse/2</code> above is a Logtalk built-in method, similar to the predicate with the same name found on most Prolog compilers that support definite clause grammars. After compiling and loading this object, we can test the grammar rules with calls such as the following one:
</p>
<pre>| ?- calculator::parse("1+2-3*4", Result).

Result = -9
yes</pre>
<p>
In most cases, the predicates resulting from the translation of the grammar rules to regular clauses are not declared. Instead, these predicates are usually called by using the built-in methods <a title="Consult reference manual" href="../refman/methods/phrase2.html"><code>phrase/2</code></a> and <a title="Consult reference manual" href="../refman/methods/phrase3.html"><code>phrase/3</code></a> as shown in the example above. When we want to use the built-in methods <code>phrase/2</code> and <code>phrase/3</code>, the non-terminal used as first argument must be within the scope of the <em>sender</em>. For the above example, assuming that we want the predicate corresponding to the <code>expr//1</code> non-terminal to be public, the corresponding scope directive would be:
</p>
<pre>:- public(expr//1). </pre>
<p>
The <code>//</code> infix operator used above tells the Logtalk compiler that the scope directive refers to a grammar rule non-terminal, not to a predicate. The idea is that the predicate corresponding to the translation of the <code>expr//1</code> non-terminal will have a number of arguments equal to one plus the number of additional arguments necessary for processing the subjacent lists of tokens.
</p>
<p>
In the body of a grammar rule, we can call rules that are inherited from ancestor objects, imported from categories, or contained in other objects. This is accomplished by using non-terminals as messages. Using a non-terminal as a message to <em>self</em> allows us to call grammar rules in categories and ancestor objects. To call grammar rules encapsulated in other objects, we use a non-terminal as a message to those objects. Consider the following example, containing grammar rules for parsing natural language sentences:
</p>
<pre>:- object(sentence,
    imports(determiners, nouns, verbs)).

    :- public(parse/2).

    parse(List, true) :-
        phrase(sentence, List).
    parse(_, false).

    sentence --&gt; noun_phrase, verb_phrase.

    noun_phrase --&gt; ::determiner, ::noun.
    noun_phrase --&gt; ::noun.

    verb_phrase --&gt; ::verb.
    verb_phrase --&gt; ::verb, noun_phrase.

:- end_object.</pre>
<p>
The categories imported by the object would contain the necessary grammar rules for parsing determiners, nouns, and verbs. For example:
</p>
<pre>:- category(determiners).

    :- private(determiner//0).

    determiner --&gt; [the].
    determiner --&gt; [a].

:- end_category.</pre>
<p>
Along with the message sending operators (<code>::/1</code> and <code>::/2</code>), we may also use other control constructs such as <code>\+/1</code>, <code>!/0</code>, <code>;/2</code>, <code>-&gt;/2</code>, and <code>{}/1</code> in the body of a grammar. In addition, grammar rules may contain meta-calls (a variable taking the place of a non-terminal), which are translated to calls of the built-in method <code>phrase/3</code>. 
</p>
<p>
You may have noticed that Logtalk defines <code>{}/1</code> as a control construct for bypassing the compiler when compiling a clause body goal. As exemplified above, this is the same control construct that is used in grammar rules for bypassing the expansion of rule body goals when a rule is converted into a clause. Both control constructs can be combined in order to call a goal from a grammar rule body, while bypassing at the same time the Logtalk compiler. Consider the following example:
</p>
<pre>bar :-
    write('bar predicate called'), nl.


:- object(bypass).

    :- public(foo//0).

    foo --&gt; {{bar}}.

:- end_object.</pre>
<p>
After compiling and loading this code, we may try the following query:
</p>
<pre>| ?- logtalk &lt;&lt; phrase(bypass::foo, _, _).

bar predicate called
yes</pre>
<p>
This is the expected result as the expansion of the grammar rule into a clause leaves the <code>{bar}</code> goal untouched, which, in turn, is converted into the goal <code>bar</code> when the clause is compiled.
</p>
<p>
A grammar rule non-terminal may be declared as dynamic or discontiguous, as any object predicate, using the same <code><em>Functor//Arity</em></code> notation illustrated above for the scope directives. In addition, grammar rule non-terminals can be documented using the <a title="Consult reference manual" href="../refman/directives/info2.html"><code>info/2</code></a> directive, as in the following example:
</p>
<pre>:- public(sentence//0).

:- info(sentence//0, [
    comment is 'Rewrites a sentence into a noun phrase and a verb phrase.']).</pre>

<h2 id="predicates_methods">Built-in object predicates (methods)</h2>

<p>
Logtalk defines a set of built-in object predicates or methods to access message execution context, to find sets of solutions, to inspect objects and for database handling. Similar to Prolog built-in predicates, these built-in methods should not be redefined.
</p>

<h3 id="predicates_context">Execution context methods</h3>

<p>
Logtalk defines four built-in private methods to access an object execution context. These methods (with the possible exception of <code>parameter/2</code>) are translated to a single unification performed at compile time with a clause head context argument. Therefore, they can be freely used without worrying about performance penalties. When called from inside a category, these methods refer to the execution context of the object importing the category. These methods cannot be used as messages to objects.
</p>
<p>
To find the object that received the message under execution we may use the <a title="Consult reference manual" href="../refman/methods/self1.html"><code>self/1</code></a> method. We may also retrieve the object that has sent the message under execution using the <a title="Consult reference manual" href="../refman/methods/sender1.html"><code>sender/1</code></a> method.
</p>
<p>
The method <a title="Consult reference manual" href="../refman/methods/this1.html"><code>this/1</code></a> enables us to retrieve the name of the object that contains the predicate clause that is being executed instead of using the name directly. This helps to avoid breaking the code if we decide to change the object name and forget to change the name references. This method may also be used from within a category. In this case, the method returns the object importing the category on whose behalf the predicate clause is being executed.
</p>
<p>
Here is a short example including calls to these three object execution context methods:
</p>
<pre>:- object(test).

    :- public(test/0).

    test :-
        this(This), 
        write('Executing  a predicate definition contained in '), writeq(This), nl,
        self(Self),
        write('to answer a message received by '), writeq(Self), nl,
        sender(Sender),
        write('that was sent by '), writeq(Sender), nl, nl.

:- end_object.


:- object(descendant,
    extends(test)).

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- descendant::test.

Executing  a predicate definition contained in test
to answer a message received by descendant
that was sent by user
yes</pre>
<p>
Note that the goals <code>self(Self)</code>, <code>sender(Sender)</code>, and <code>this(This)</code>, being translated to unifications with the clause head context arguments at compile time, are effectively removed from the clause body. Therefore, a clause such as:
</p>
<pre>predicate(Arg) :-
    self(Self),
    atom(Arg),
    ... .</pre>
<p>
is compiled with the goal <code>atom(Arg)</code> as the first condition on the clause body. As such, the use of these context execution methods do not interfere with the optimizations that some Prolog compilers perform when the first clause body condition is a call to a built-in type-test predicate or a comparison operator. 
</p>
<p>
For parametric objects and categories, the method <a title="Consult reference manual" href="../refman/methods/parameter2.html"><code>parameter/2</code></a> enables us to retrieve current parameter values (see the session on <a href="objects.html#parametric">parametric objects</a> for a detailed description). For example:
</p>
<pre>:- object(block(_Color)).

    :- public(test/0).

    test :-
        parameter(1, Color), 
        write('Color parameter value  is '), writeq(Color), nl.

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- block(blue)::test.

Color parameter value is blue
yes</pre>
<p>
The method <code>parameter/2</code> is only translated to a compile time unification for parametric objects. When the method is used in a parametric category, its call is translated to a call to the built-in Prolog predicate <code>arg/3</code>.
</p>

<h3 id="predicates_database">Database methods</h3>

<p>
Logtalk provides a set of built-in methods for object database handling similar to the usual database Prolog predicates: <a title="Consult reference manual" href="../refman/methods/abolish1.html"><code>abolish/1</code></a>, <a title="Consult reference manual" href="../refman/methods/asserta1.html"><code>asserta/1</code></a>, <a title="Consult reference manual" href="../refman/methods/assertz1.html"><code>assertz/1</code></a>, <a title="Consult reference manual" href="../refman/methods/clause2.html"><code>clause/2</code></a>, <a title="Consult reference manual" href="../refman/methods/retract1.html"><code>retract/1</code></a>, and <a title="Consult reference manual" href="../refman/methods/retractall1.html"><code>retractall/1</code></a>. These methods always operate on the database of the object receiving the corresponding message.
</p>
<p>
When working with dynamic grammar rule non-terminals, you may use the built-in method <a title="Consult reference manual" href="../refman/methods/expand_term2.html"><code>expand_term/2</code></a> convert a grammar rule into a clause that can than be used with the database methods.
</p>

<h3 id="predicates_metacalls">Meta-call methods</h3>

<p>
Logtalk supports the generalized <a title="Consult reference manual" href="../refman/methods/callN.html"><code>call/1-N</code></a> meta-predicate. This built-in private meta-predicate must be used in the implementation of meta-predicates which work with closures instead of goals. In addition, Logtalk supports the built-in private meta-predicates <a title="Consult reference manual" href="../refman/methods/ignore1.html"><code>ignore/1</code></a>, <a title="Consult reference manual" href="../refman/methods/once1.html"><code>once/1</code></a>, and <a title="Consult reference manual" href="../refman/methods/not1.html"><code>\+/1</code></a>. These methods cannot be used as messages to objects.
</p>

<h3 id="predicates_solutions">All solutions methods</h3>

<p>
The usual all solutions meta-predicates are built-in private methods in Logtalk: <a title="Consult reference manual" href="../refman/methods/bagof3.html"><code>bagof/3</code></a>, <a title="Consult reference manual" href="../refman/methods/findall3.html"><code>findall/3</code></a>, and <a title="Consult reference manual" href="../refman/methods/setof3.html"><code>setof/3</code></a>. There is also a <a title="Consult reference manual" href="../refman/methods/forall2.html"><code>forall/2</code></a> method that implements generate and test loops. These methods cannot be used as messages to objects.
</p>

<h3 id="predicates_reflection">Reflection methods</h3>

<p>
Logtalk provides built-in methods for inspecting object operators and predicates: <a title="Consult reference manual" href="../refman/methods/current_op3.html"><code>current_op/3</code></a>, which returns operator specifications, <a title="Consult reference manual" href="../refman/methods/predicate_property2.html"><code>predicate_property/2</code></a>, which returns predicate properties, and <a title="Consult reference manual" href="../refman/methods/current_predicate1.html"><code>current_predicate/1</code></a>, which enables us to query about predicate definitions. See below for a more detailed description of these methods.
</p>

<h3 id="predicates_parsing">Definite clause grammar parsing methods and non-terminals</h3>

<p>
Logtalk supports two definite clause grammar parsing built-in private methods, <a title="Consult reference manual" href="../refman/methods/phrase2.html"><code>phrase/2</code></a> and <a title="Consult reference manual" href="../refman/methods/phrase3.html"><code>phrase/3</code></a>, with definitions similar to the predicates with the same name found on most Prolog compilers that support definite clause grammars. These methods cannot be used as messages to objects.
</p>
<p>
Logtalk also supports a <a title="Consult reference manual" href="../refman/methods/call1.html"><code>call//1</code></a> built-in non-terminal. This non-terminal takes a closure (which can be a lambda expression) and is processed by appending the input list of tokens and the list of remaining tokens to the arguments of the closure.
</p>

<h3 id="predicates_expanding">Term and goal expansion methods</h3>

<p>
Logtalk supports a <a title="Consult reference manual" href="../refman/methods/expand_term2.html"><code>expand_term/2</code></a> built-in method for expanding a term into a list of terms. This method is mostly used to translate grammar rules into Prolog clauses. It can be customized, e.g. for bypassing the default Logtalk grammar rule translator, by defining clauses for the predicate <a title="Consult reference manual" href="../refman/methods/term_expansion2.html"><code>term_expansion/2</code></a>.
</p>
<p>
Logtalk also supports a <a title="Consult reference manual" href="../refman/methods/expand_goal2.html"><code>expand_goal/2</code></a> built-in method for expanding a goal. This method can be customized by defining clauses for the predicate <a title="Consult reference manual" href="../refman/methods/goal_expansion2.html"><code>goal_expansion/2</code></a>.
</p>
<p>
Term and goal expansion may be performed either by calling the <code>expand_term/2</code> and <code>expand_goal/2</code> built-in methods explicitly or by using <em><a class="glossary" title="Go to glossary definition" href="../glossary.html#hook">hook objects</a></em>. Clauses for the <code>term_expansion/2</code> and <code>goal_expansion/2</code> predicates defined within an object or a category are never used in the compilation of the object or the category itself. In order to use clauses for the <code>term_expansion/2</code> and <code>goal_expansion/2</code> predicates defined in plain Prolog, you will need to explicitly specify the pseudo-object <code>user</code> as the hook object when compiling source files.
</p>
<p>
Logtalk provides a <a title="Consult reference manual" href="../refman/builtins/logtalk_load_context2.html"><code>logtalk_load_context/2</code></a> built-in predicate that can be used to access the compilation/loading context when performing term-expansion or goal-expansion.
</p>

<h2 id="predicates_properties">Predicate properties</h2>

<p>
We can find the properties of visible predicates by calling the <a title="Consult reference manual" href="../refman/methods/predicate_property2.html"><code>predicate_property/2</code></a> built-in method. For example:
</p>
<pre>| ?- bar::predicate_property(foo(_), Property).</pre>
<p>
Note that this method respects the predicate's scope declarations. For instance, the above call will only return properties for public predicates.
</p>
<p>
An object's set of visible predicates is the union of all the predicates declared for the object with all the built-in methods and all the Logtalk and Prolog built-in predicates.
</p>
<p>
Possible predicate properties values are:
</p>
<ul>
	<li><code>scope(Scope)</code></li>
	<li><code>public</code>, <code>protected</code>, <code>private</code></li>
	<li><code>static</code>, <code>dynamic</code></li>
	<li><code>logtalk</code>, <code>prolog</code></li>
	<li><code>built_in</code></li>
	<li><code>multifile</code></li>
	<li><code>meta_predicate(Template)</code></li>
	<li><code>coinductive(Template)</code></li>
	<li><code>declared_in(Entity)</code></li>
	<li><code>defined_in(Entity)</code></li>
	<li><code>redefined_from(Entity)</code></li>
	<li><code>non_terminal(NonTerminal//Arity)</code></li>
	<li><code>alias_of(Predicate)</code></li>
	<li><code>synchronized</code></li>
</ul>
<p>
Some properties are only available when the entities are compiled with the <code>source_data</code> flag turned on:
</p>
<ul>
	<li><code>mode(Mode, Solutions)</code></li>
	<li><code>info(ListOfPairs)</code></li>
	<li><code>number_of_clauses(N)</code></li>
	<li><code>declared_in(Entity, Line)</code></li>
	<li><code>defined_in(Entity, Line)</code></li>
	<li><code>redefined_from(Entity, Line)</code></li>
</ul>
<p>
The properties <code>logtalk</code> and <code>prolog</code> allows us to distinguish between predicates defined by Logtalk and predicates defined by the back-end Prolog compiler.
</p>
<p>
The properties <code>declared_in/1</code>, <code>defined_in/1</code>, and <code>redefined_from/1</code> do not apply to built-in methods and Logtalk or Prolog built-in predicates. Note that if a predicate is declared in a category imported by the object, it will be the category name &mdash; not the object name &mdash; that will be returned by the property <code>declared_in/1</code>. The same is true for protocol declared predicates.
</p>
<p>
The predicate property <code>defined_in(Entity)</code> results in the definitions for the predicate being looked up in <code>Entity</code>. This does not necessarily implies that clauses for the predicate exist in <code>Entity</code>; the predicate can simply be false (closed world assumption).
</p>
<p>
The property <code>non_terminal/1</code> only applies to predicates that result from the compilation of grammar rule non-terminals. 
</p>
<p>
The property <code>alias_of/1</code> is returned for a predicate that is an alias of another predicate (which is returned in the property argument).
</p>
<p>
The property <code>synchronized</code> is returned for predicates that are declared synchronized when using multi-threading programming.
</p>


<h2 id="predicates_finding">Finding declared predicates</h2>

<p>
We can find, by backtracking, all visible user predicates by calling the <a title="Consult reference manual" href="../refman/methods/current_predicate1.html"><code>current_predicate/1</code></a> built-in method. This method respects the predicate's scope declarations. For instance, the following call:
</p>
<pre>| ?- some_object::current_predicate(Functor/Arity).</pre>
<p>
will only return user predicates that are declared public. The predicate property <code>non_terminal/1</code> may be used to retrieve all grammar rule non-terminals declared for an object. For example:
</p>
<pre>current_non_terminal(Object, NonTerminal//Args) :-
    Object::current_predicate(Functor/Arity),
    functor(Predicate, Functor, Arity),
    Object::predicate_property(Predicate, non_terminal(NonTerminal//Args)).</pre>
<p>
Usually, the non-terminal and the corresponding predicate share the same functor but users should not rely on this always being true.
</p>

<h2 id="predicates_prolog">Calling Prolog built-in predicates</h2>

<p>
In predicate definitions, predicate calls which are not prefixed with a message sending operator (either <code>::</code> or <code>^^</code>), are compiled to either calls to local predicates or as calls to Logtalk/Prolog built-in predicates. A predicate call is compiled as a call to a local predicate if the object (or category) contains a scope directive, a definition for the called predicate, or a dynamic declaration for it. When the object (or category) does not contain either a definition of the called predicate or a corresponding dynamic declaration, Logtalk tests if the call corresponds to a Logtalk or Prolog built-in predicate. Calling a predicate which is neither a local predicate nor a Logtalk/Prolog built-in predicate results in a compile time warning. This means that, in the following example:
</p>
<pre>foo :-
    ...,
    write(bar),
    ...</pre>
<p>
the call to the predicate <code>write/1</code> will be compiled as a call to the corresponding Prolog built-in predicate unless the object (or category) encapsulating the above definition also contains a predicate named <code>write/1</code> or a dynamic declaration for the predicate.
</p>
<p>
When calling non-standard Prolog built-in predicates or using non-standard Prolog arithmetic functions, you may run into portability problems while trying your applications with different back-end Prolog compilers (non-standard predicates and non-standard arithmetic functions are often specific to a Prolog compiler). You may use the Logtalk compiler flag <a title="Consult user manual" href="programming.html#programming_flags"><code>portability/1</code></a> to help check for problematic calls in your code.
</p>

<h3 id="predicates_prolog_meta">Calling Prolog non-standard meta-predicates</h3>

<p>
Prolog built-in meta-predicates may only be called locally within objects or categories, i.e. they cannot be used as messages. Compiling calls to non-standard, Prolog built-in meta-predicates can be tricky for two reasons: first, there is no standard way of checking if a built-in predicate is also a meta-predicate and finding out which are its meta-arguments; second, in some cases, the meta-arguments of a meta-predicate are not goals but closures, used for constructing goals. The way the goals are constructed is specific to the meta-predicate and cannot be reliable inferred by the Logtalk compiler. For meta-predicates whose meta-arguments are directly called as goals, the solution is to explicitly declare them in the corresponding Prolog adapter file using the predicate <code>'$lgt_pl_meta-predicate'/3</code>. For example:
</p>
<pre>'$lgt_prolog_meta_predicate'(*-&gt;(_, _), (*-&gt;(0, 0), control_construct).
'$lgt_prolog_meta_predicate'(call_with_depth_limit(_, _, _), call_with_depth_limit(0, *, *), predicate).</pre>
<p>
Currently, there is no clean workaround for calling non-standard Prolog built-in meta-predicates whose meta-arguments are closures instead of goals.
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: December 4, 2012</span>
	</div>
	<div class="navbottom">
		<span><a href="categories.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="inheritance.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
