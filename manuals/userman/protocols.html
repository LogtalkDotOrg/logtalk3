<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright (c) 1998-2013 Paulo Moura <pmoura@logtalk.org>
%  
%  Logtalk is free software. You can redistribute it and/or modify it under
%  the terms of the FSF GNU General Public License 3  (plus some additional
%  terms per section 7).        Consult the `LICENSE.txt` file for details.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: protocols</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div>
<div class="top-right">Protocols</div>
<div class="bottom-left"><span class="page"/></div>
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Protocols</div>

<h1 id="protocols_protocols">Protocols</h1>

<p>
Protocols enable the separation between interface and implementation: several objects can implement the same protocol and an object can implement several protocols. Protocols may contain only predicate declarations. In some languages the term <em>interface</em> is used with similar meaning. Logtalk allows predicate declarations of any scope within protocols, contrary to some languages that only allow public declarations.
</p>
<p>
Logtalk defines two built-in protocols, <code>monitoring</code> and <code>expanding</code>, which are described at the end of this section.
</p>

<h2 id="protocols_defining">Defining a new protocol</h2>

<p>
We can define a new object in the same way we write Prolog code: by using a text editor. Logtalk source files may contain one or more objects, categories, or protocols. If you prefer to define each entity in its own source file, it is recommended that the file be named after the protocol. By default, all Logtalk source files use the extension <code>.lgt</code> but this is optional and can be set in the adapter files. Intermediate Prolog source files (generated by the Logtalk compiler) have, by default, a <code>.pl</code> extension. Again, this can be set to match the needs of a particular Prolog compiler in the corresponding adapter file. For example, we may define a protocol named <code>listp</code> and save it in a <code>listp.lgt</code> source file that will be compiled to a <code>listp.pl</code> Prolog file.
</p>
<p>
Protocol names must be atoms. Objects, categories and protocols share the same name space: we cannot have a protocol with the same name as an object or a category.
</p>
<p>
Protocol directives are textually encapsulated by using two Logtalk directives: <a title="Consult reference manual" href="../refman/directives/protocol1_2.html"><code>protocol/1-2</code></a> and <a title="Consult reference manual" href="../refman/directives/end_protocol0.html"><code>end_protocol/0</code></a>. The most simple protocol will be one that is self-contained, not depending on any other Logtalk entity:
</p>
<pre>:- protocol(Protocol).
    ...
:- end_protocol.</pre>
<p>
If a protocol extends one or more protocols, then the opening directive will be:
</p>
<pre>:- protocol(Protocol,
    extends(Protocol1, Protocol2, ...)).
    ...
:- end_protocol.</pre>
<p>
In order to maximize protocol reuse, all predicates specified in a protocol should relate to the same functionality. Therefore, the only recommended use of protocol extension is when you need both a minimal protocol and an extended version of the same protocol with additional, useful predicates.
</p>

<h2 id="protocols_finding">Finding defined protocols</h2>

<p>
We can find, by backtracking, all defined protocols by using the <a title="Consult reference manual" href="../refman/builtins/current_protocol1.html"><code>current_protocol/1</code></a> built-in predicate with a non-instantiated variable:
</p>
<pre>| ?- current_protocol(Protocol).</pre>
<p>
This predicate can also be used to test if a protocol is defined by calling it with a valid protocol identifier (an atom).
</p>

<h2 id="protocols_creating">Creating a new protocol in runtime</h2>

<p>
We can create a new (dynamic) protocol in runtime by calling the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/builtins/create_protocol3.html"><code>create_protocol/3</code></a>:
</p>
<pre>| ?- create_protocol(Protocol, Relations, Directives).</pre>
<p>
The first argument should be either a variable or the name of the new protocol (a Prolog atom, which must not match an existing entity name). The remaining two arguments correspond to the relations described in the opening protocol directive and to the protocol  directives.
</p>
<p>
For instance, the call:
</p>
<pre>| ?- create_protocol(ppp, [extends(qqq)], [public([foo/1, bar/1])]).</pre>
<p>
is equivalent to compiling and loading the protocol:
</p>
<pre>:- protocol(ppp,
    extends(qqq)).

    :- dynamic.

    :- public([foo/1, bar/1]).

:- end_protocol.</pre>
<p>
If we need to create a lot of (dynamic) protocols at runtime, then is best to define a metaclass or a prototype with a predicate that will call this built-in predicate in order to provide more sophisticated behavior.
</p>

<h2 id="protocols_abolishing">Abolishing an existing protocol</h2>

<p>
Dynamic protocols can be abolished using the <a title="Consult reference manual" href="../refman/builtins/abolish_protocol1.html"><code>abolish_protocol/1</code></a> built-in predicate:
</p>
<pre>| ?- abolish_protocol(Protocol).</pre>
<p>
The argument must be an identifier of a defined dynamic protocol, otherwise an error will be thrown.
</p>

<h2>Protocol directives<a id="protocols_directives"></a></h2>

<p>
Protocol directives are used to set initialization goals and protocol properties.
</p>

<h3 id="protocols_initialization">Protocol initialization</h3>

<p>
We can define a goal to be executed as soon as a protocol is (compiled and) loaded to memory with the <a title="Consult reference manual" href="../refman/directives/initialization1.html"><code>initialization/1</code></a> directive:
</p>
<pre>:- initialization(Goal).</pre>
<p>
The argument can be any valid Prolog or Logtalk goal, including a message sending call.
</p>

<h3 id="protocols_dynamic">Dynamic protocols</h3>

<p>
As usually happens with Prolog code, a protocol can be either static or dynamic. A protocol created during the execution of a program is always dynamic. A protocol defined in a file can be either dynamic or static. Dynamic protocols are declared by using the <a title="Consult reference manual" href="../refman/directives/dynamic0.html"><code>dynamic/0</code></a> directive in the protocol source code:
</p>
<pre>:- dynamic.</pre>
<p>
The directive must precede any predicate directives. Please be aware that using dynamic code results in a performance hit when compared to static code. We should only use dynamic protocols when these need to be abolished during program execution.
</p>

<h3 id="protocols_documentation">Protocol documentation</h3>

<p>
A protocol can be documented with arbitrary user-defined information by using the <a title="Consult reference manual" href="../refman/directives/info1.html"><code>info/1</code></a> directive:
</p>
<pre>:- info(List).</pre>
<p>
See the <a href="documenting.html">documenting Logtalk programs</a> session for details.
</p>

<h2 id="protocols_relationships">Protocol relationships</h2>

<p>
Logtalk provides two sets of built-in predicates that enable us to query the system about the possible relationships that a protocol have with other entities.
</p>
<p>
The built-in predicates <a title="Consult reference manual" href="../refman/builtins/extends_protocol2_3.html"><code>extends_protocol/2</code></a> and <a title="Consult reference manual" href="../refman/builtins/extends_protocol2_3.html"><code>extends_protocol/3</code></a> return all pairs of protocols so that the first one extends the second:
</p>
<pre>| ?- extends_protocol(Protocol1, Protocol2).</pre>
<p>
or, if we want to know the extension scope:
</p>
<pre>| ?- extends_protocol(Protocol1, Protocol2, Scope).</pre>
<p>
To find which objects or categories implement which protocols we can call the <a title="Consult reference manual" href="../refman/builtins/implements_protocol2_3.html"><code>implements_protocol/2</code></a> or <a title="Consult reference manual" href="../refman/builtins/implements_protocol2_3.html"><code>implements_protocol/2</code></a> built-in predicates:
</p>
<pre>| ?- implements_protocol(ObjectOrCategory, Protocol).</pre>
<p>
or, if we want to know the implementation scope:
</p>
<pre>| ?- implements_protocol(ObjectOrCategory, Protocol, Scope).</pre>
<p>
Note that, if we use a non-instantiated variable for the first argument, we will need to use the <a title="Consult reference manual" href="../refman/builtins/current_object1.html"><code>current_object/1</code></a> or <a title="Consult reference manual" href="../refman/builtins/current_category1.html"><code>current_category/1</code></a> built-in predicates to identify the kind of entity returned.
</p>

<h2 id="protocols_properties">Protocol properties</h2>

<p>
We can find the properties of defined protocols by calling the <a title="Consult reference manual" href="../refman/builtins/protocol_property2.html"><code>protocol_property/2</code></a> built-in predicate:
</p>
<pre>| ?- protocol_property(Protocol, Property).</pre>
<p>
A protocol may have the property <code>static</code>, <code>dynamic</code>, or <code>built_in</code>. Dynamic protocols can be abolished in runtime by calling the <a title="Consult reference manual" href="../refman/builtins/abolish_protocol1.html"><code>abolish_protocol/1</code></a> built-in predicate. Depending on the back-end Prolog compiler, a protocol may have additional properties related to the source file where it is defined.
</p>

<h2 id="protocols_implementing">Implementing protocols</h2>

<p>
Any number of objects or categories can implement a protocol. The syntax is very simple:
</p>
<pre>:- object(Object,
    implements(Protocol)).
    ...
:- end_object.</pre>
<p>
or, in the case of a category:
</p>
<pre>:- category(Object,
    implements(Protocol)).
    ...
:- end_category.</pre>
<p>
To make all public predicates declared via an implemented protocol protected or to make all public and protected predicates private we prefix the protocol's name with the corresponding keyword. For instance:
</p>
<pre>:- object(Object,
    implements(private::Protocol)).
    ...
:- end_object.</pre>
<p>
or:
</p>
<pre>:- object(Object,
    implements(protected::Protocol)).
    ...
:- end_object.</pre>
<p>
Omitting the scope keyword is equivalent to writing:
</p>
<pre>:- object(Object,
    implements(public::Protocol)).
    ...
:- end_object.</pre>
<p>
The same rules applies to protocols implemented by categories.
</p>

<h2 id="protocols_built_in">Built-in protocols</h2>

<p>
Logtalk defines a set of built-in protocols that are always available for any application.
</p>

<h3 id="protocols_expanding">The built-in protocol <em>expanding</em></h3>

<p>
Logtalk defines a built-in protocol named <code>expanding</code> that contains declarations for the <code>term_expansion/2</code> and <code>goal_expansion/2</code> predicates. See the <a href="programming.html#programming_flags">description of the <code>hook</code> compiler flag</a> for more details.
</p>

<h3 id="protocols_monitoring">The built-in protocol <em>monitoring</em></h3>

<p>
Logtalk defines a built-in protocol named <code>monitoring</code> that contains declarations for the <code>before/3</code> and <code>after/3</code> public event handler predicates. See the <a href="events.html">event-driven programming</a> section for more details.
</p>

<h3 id="protocols_forwarding">The built-in protocol <em>forwarding</em></h3>

<p>
Logtalk defines a built-in protocol named <code>forwarding</code> that contains a declaration for the <code>forward/1</code> user-defined message forwarding handler, which is automatically called (if defined) by the runtime for any message that the receiving object does not understand. See also the <a href="../refman/control/delegate1.html">[]/1</a> control construct.
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: March 12, 2013</span>
	</div>
	<div class="navbottom">
		<span><a href="objects.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="categories.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
