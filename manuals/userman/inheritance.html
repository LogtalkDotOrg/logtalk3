

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Inheritance &mdash; The Logtalk Handbook v3.39.0-b02 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Event-driven programming" href="events.html" />
    <link rel="prev" title="Predicates" href="predicates.html" />
   
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Logtalk Handbook
          

          
            
            <img src="../_static/logtalk.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.39.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="declarative.html">Declarative object-oriented programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2"><a class="reference internal" href="nomenclature.html">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#protocol-inheritance">Protocol inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#search-order-for-prototype-hierarchies">Search order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#search-order-for-class-hierarchies">Search order for class hierarchies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-inheritance">Implementation inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-prototype">Search order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-class">Search order for class hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redefining-inherited-predicate-definitions">Redefining inherited predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specializing-inherited-predicate-definitions">Specializing inherited predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#union-of-inherited-and-local-predicate-definitions">Union of inherited and local predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selective-inheritance-of-predicate-definitions">Selective inheritance of predicate definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#public-protected-and-private-inheritance">Public, protected, and private inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-inheritance">Multiple inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-versus-multiple-inheritance">Composition versus multiple inheritance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing and running applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="printing.html">Printing messages and asking questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expansion.html">Term and goal expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Prolog integration and migration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

            
          
	<p class="caption"><span class="caption-text">External Contents</span></p>
    <a href="../docs/index.html">APIs</a>
    <a href="https://logtalk.org">Logtalk website</a>
    <a href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">User Manual</a> &raquo;</li>
        
      <li>Inheritance</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/inheritance.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="inheritance">
<span id="inheritance-inheritance"></span><h1>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h1>
<p>The inheritance mechanisms found on object-oriented programming
languages allow the specialization of previously defined objects,
avoiding the unnecessary repetition of code and allowing the definition
of common functionality for sets of objects. In the context of logic
programming, we can interpret inheritance as a form of <em>theory extension</em>:
an object will virtually contain, besides its own predicates, all the
predicates inherited from other objects that are not redefined locally.</p>
<p>Logtalk uses a depth-first search procedure for finding predicate
declarations and predicate definitions, as explained below. The search
procedures locate the entities holding the <a class="reference internal" href="../glossary.html#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a>
and the <a class="reference internal" href="../glossary.html#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> using the predicate name and arity.
The <a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> predicate directive may be used for defining
alternative names for inherited predicates, for solving inheritance
conflicts, and for giving access to all inherited definitions (thus
overriding the default search procedure).</p>
<p>The search procedures are used when sending a message (using the
<a class="reference internal" href="../refman/control/send_to_object_2.html#control-send-to-object-2"><span class="std std-ref">::/2</span></a>, <a class="reference internal" href="../refman/control/send_to_self_1.html#control-send-to-self-1"><span class="std std-ref">::/1</span></a>, and
<a class="reference internal" href="../refman/control/delegate_message_1.html#control-delegate-message-1"><span class="std std-ref">[]/1</span></a> control constructs) and when making <em>super</em>
calls (using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> control construct). The exact
details of the search procedures depend on the role played by the object
receiving the message or making the <em>super</em> call, as explained next. The
search procedures are also used by the <a class="reference internal" href="../refman/methods/current_predicate_1.html#methods-current-predicate-1"><span class="std std-ref">current_predicate/1</span></a>
and <a class="reference internal" href="../refman/methods/predicate_property_2.html#methods-predicate-property-2"><span class="std std-ref">predicate_property/2</span></a> reflection predicates.</p>
<div class="section" id="protocol-inheritance">
<span id="inheritance-protocol"></span><h2>Protocol inheritance<a class="headerlink" href="#protocol-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Protocol inheritance refers to the inheritance of predicate declarations
(<a class="reference internal" href="../glossary.html#term-predicate-scope-directive"><span class="xref std std-term">scope directives</span></a>). These can be contained
in objects, protocols, or categories. Logtalk supports single and
multi-inheritance of protocols: an object or a category may implement several
protocols and a protocol may extend several protocols.</p>
<div class="section" id="search-order-for-prototype-hierarchies">
<span id="inheritance-protocol-prototype"></span><h3>Search order for prototype hierarchies<a class="headerlink" href="#search-order-for-prototype-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate declarations is first the object, second
the implemented protocols (and the protocols that these may extend),
third the imported categories (and the protocols that they may
implement), and last the objects that the object extends. This search is
performed in depth-first order. When an object inherits two different
declarations for the same predicate, by default, only the first one will
be considered.</p>
</div>
<div class="section" id="search-order-for-class-hierarchies">
<span id="inheritance-protocol-class"></span><h3>Search order for class hierarchies<a class="headerlink" href="#search-order-for-class-hierarchies" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate declarations starts in the object
classes. Following the classes declaration order, the search starts in
the classes implemented protocols (and the protocols that these may
extend), second the classes imported categories (and the protocols that
they may implement), and last the superclasses of the object classes.
This search is performed in depth-first order. If the object inherits
two different declarations for the same predicate, by default only the
first one will be considered.</p>
</div>
</div>
<div class="section" id="implementation-inheritance">
<span id="inheritance-implementation"></span><h2>Implementation inheritance<a class="headerlink" href="#implementation-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Implementation inheritance refers to the inheritance of predicate
definitions. These can be contained in objects or in categories. Logtalk
supports multi-inheritance of implementation: an object may import
several categories or extend, specialize, or instantiate several
objects.</p>
<div class="section" id="inheritance-implementation-prototype">
<span id="id1"></span><h3>Search order for prototype hierarchies<a class="headerlink" href="#inheritance-implementation-prototype" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate definitions is similar to the search for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives).</p>
</div>
<div class="section" id="inheritance-implementation-class">
<span id="id2"></span><h3>Search order for class hierarchies<a class="headerlink" href="#inheritance-implementation-class" title="Permalink to this headline">¶</a></h3>
<p>The search order for predicate definitions is similar to the search for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives) and that the search starts
at the instance itself (that received the message) before proceeding, if
no predicate definition is found there, to the instance classes and then
to the class superclasses.</p>
</div>
<div class="section" id="redefining-inherited-predicate-definitions">
<span id="inheritance-implementation-redefinition"></span><h3>Redefining inherited predicate definitions<a class="headerlink" href="#redefining-inherited-predicate-definitions" title="Permalink to this headline">¶</a></h3>
<p>When we define a predicate that is already inherited from an ancestor object
or an imported category, the inherited definition is hidden by the new
definition. This is called inheritance overriding: a local definition
overrides any inherited definitions. For example, assume that we have the
following two objects:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(bar<span class="o">/</span><span class="m">1</span>).
    bar(root).

<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).
    foo(root).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(descendant).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>After compiling and loading these objects, we can check the overriding
behavior by trying the following queries:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- root::(bar(Bar), foo(Foo)).

Bar = root
Foo = root
yes


| ?- descendant::(bar(Bar), foo(Foo)).

Bar = root
Foo = descendant
yes
</pre></div>
</div>
<p>However, we can explicitly code other behaviors. Some examples follow.</p>
</div>
<div class="section" id="specializing-inherited-predicate-definitions">
<span id="inheritance-specialization"></span><h3>Specializing inherited predicate definitions<a class="headerlink" href="#specializing-inherited-predicate-definitions" title="Permalink to this headline">¶</a></h3>
<p>Specialization of inherited definitions: the new definition calls the
inherited definition and makes additional calls. This is accomplished
by calling the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> <em>super call</em> operator
in the new definition. For example, assume a <code class="docutils literal notranslate"><span class="pre">init/0</span></code> predicate
that must account for object specific initializations along the
inheritance chain:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(init<span class="o">/</span><span class="m">0</span>).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;root init&#39;</span>), <span class="k">nl</span>.

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;descendant init&#39;</span>), <span class="k">nl</span>,
        <span class="o">^^</span>init.

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- descendant::init.

descendant init
root init
yes
</pre></div>
</div>
</div>
<div class="section" id="union-of-inherited-and-local-predicate-definitions">
<span id="inheritance-union"></span><h3>Union of inherited and local predicate definitions<a class="headerlink" href="#union-of-inherited-and-local-predicate-definitions" title="Permalink to this headline">¶</a></h3>
<p>Union of the new with the inherited definitions: all the definitions are
taken into account, the calling order being defined by the inheritance
mechanisms. This can be accomplished by writing a clause that just calls,
using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> <em>super call</em> operator, the inherited
definitions. The relative position of this clause among the other definition
clauses sets the calling order for the local and inherited definitions. For
example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).

    foo(<span class="m">1</span>).
    foo(<span class="m">2</span>).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(<span class="m">3</span>).
    foo(<span class="nv">Foo</span>) <span class="o">:-</span>
        <span class="o">^^</span>foo(<span class="nv">Foo</span>).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- descendant::foo(Foo).

Foo = 3 ;
Foo = 1 ;
Foo = 2 ;
no
</pre></div>
</div>
</div>
<div class="section" id="selective-inheritance-of-predicate-definitions">
<span id="inheritance-selective"></span><h3>Selective inheritance of predicate definitions<a class="headerlink" href="#selective-inheritance-of-predicate-definitions" title="Permalink to this headline">¶</a></h3>
<p>The selective inheritance of predicate definitions (also known as
differential inheritance) is normally used in the representation
of exceptions to inherited default definitions. We can use the
<a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">^^/1</span></a> <em>super call</em> operator to test and possibly
reject some of the inherited definitions. A common example is representing
flightless birds:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(bird).

<span class="p">    :- </span><span class="k">public</span>(mode<span class="o">/</span><span class="m">1</span>).

    mode(walks).
    mode(flies).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(penguin,
    <span class="k">extends</span>(bird)).

    mode(swims).
    mode(<span class="nv">Mode</span>) <span class="o">:-</span>
        <span class="o">^^</span>mode(<span class="nv">Mode</span>),
        <span class="nv">Mode</span> <span class="o">\==</span> flies.

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- penguin::mode(Mode).

Mode = swims ;
Mode = walks ;
no
</pre></div>
</div>
</div>
</div>
<div class="section" id="public-protected-and-private-inheritance">
<span id="inheritance-scope"></span><h2>Public, protected, and private inheritance<a class="headerlink" href="#public-protected-and-private-inheritance" title="Permalink to this headline">¶</a></h2>
<p>To make all <a class="reference internal" href="../glossary.html#term-public-predicate"><span class="xref std std-term">public predicates</span></a>
declared via implemented protocols, imported categories, or ancestor
objects <a class="reference internal" href="../glossary.html#term-protected-predicate"><span class="xref std std-term">protected predicates</span></a> or to make
all public and protected predicates
<a class="reference internal" href="../glossary.html#term-private-predicate"><span class="xref std std-term">private predicates</span></a> we prefix the entity’s
name with the corresponding keyword. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">implements</span>(private<span class="o">::</span><span class="nv">Protocol</span>)).

    <span class="c">% all the Protocol public and protected</span>
    <span class="c">% predicates become private predicates</span>
    <span class="c">% for the Object clients</span>

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>or:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Class</span>,
    <span class="k">specializes</span>(protected<span class="o">::</span><span class="nv">Superclass</span>)).

    <span class="c">% all the Superclass public predicates become</span>
    <span class="c">% protected predicates for the Class clients</span>

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>Omitting the scope keyword is equivalent to using the public scope
keyword. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(public<span class="o">::</span><span class="nv">Category</span>)).

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>This is the same as:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(<span class="nv">Category</span>)).

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>This way we ensure backward compatibility with older Logtalk versions
and a simplified syntax when protected or private inheritance are not
used.</p>
</div>
<div class="section" id="multiple-inheritance">
<span id="inheritance-multiple"></span><h2>Multiple inheritance<a class="headerlink" href="#multiple-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Logtalk supports multi-inheritance by enabling an object to extend,
instantiate, or specialize more than one object. Likewise, a protocol
may extends multiple protocols and a category may extend multiple
categories. In this case, the depth-first search algorithms described
above traverse the list of entities per relation from left to right.
Consider as an example the following object opening directive:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(foo,
    <span class="k">extends</span>((bar, baz))).
</pre></div>
</div>
<p>The search will look first into the parent object <cite>bar</cite> and its related
entities before looking into the parent object <cite>baz</cite>. The
<a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> predicate directive can always be used to
solve multi-inheritance conflicts. It should also be noted that the
multi-inheritance support does not affect performance when we use
single-inheritance.</p>
</div>
<div class="section" id="composition-versus-multiple-inheritance">
<span id="inheritance-composition"></span><h2>Composition versus multiple inheritance<a class="headerlink" href="#composition-versus-multiple-inheritance" title="Permalink to this headline">¶</a></h2>
<p>It is not possible to discuss inheritance mechanisms without referring
to the long and probably endless debate on single versus multiple
inheritance. The single inheritance mechanism can be implemented
efficiently but it imposes several limitations on reusing, even
if the multiple characteristics we intend to inherit are orthogonal. On
the other hand, the multiple inheritance mechanisms are attractive in
their apparent capability of modeling complex situations. However, they
include a potential for conflict between inherited definitions whose
variety does not allow a single and satisfactory solution for all the
cases.</p>
<p>Until now, no solution that we might consider satisfactory for all the
problems presented by the multiple inheritance mechanisms has been
found. From the simplicity of some extensions that use the Prolog search
strategy like <a class="reference internal" href="../bibliography.html#mccabe92" id="id3"><span>[McCabe92]</span></a> or <a class="reference internal" href="../bibliography.html#moss94" id="id4"><span>[Moss94]</span></a> and to the sophisticated algorithms
of CLOS <a class="reference internal" href="../bibliography.html#bobrow-et-al-88" id="id5"><span>[Bobrow_et_al_88]</span></a>, there is no
adequate solution for all the situations. Besides, the use of multiple
inheritance carries some complex problems in the domain of software
engineering, particularly in the reuse and maintenance of the applications.
All these problems are substantially reduced if we preferably use in our
software development composition mechanisms instead of specialization
mechanisms <a class="reference internal" href="../bibliography.html#taenzer89" id="id6"><span>[Taenzer89]</span></a>. Multiple inheritance is best used as an analysis
and project abstraction, rather than as an implementation technique
<a class="reference internal" href="../bibliography.html#shan-et-al-93" id="id7"><span>[Shan_et_al_93]</span></a>. Note that Logtalk provides first-class support for
composition using <a class="reference internal" href="categories.html#categories-categories"><span class="std std-ref">categories</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="events.html" class="btn btn-neutral float-right" title="Event-driven programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="predicates.html" class="btn btn-neutral float-left" title="Predicates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1998-2020, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>