<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Inheritance &mdash; The Logtalk Handbook v3.81.0-b01 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=396eccfe" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=9456dd46"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Event-driven programming" href="events.html" />
    <link rel="prev" title="Predicates" href="predicates.html" />
   
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Logtalk Handbook
              <img src="../_static/logtalk.gif" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.81.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="declarative.html">Declarative object-oriented programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2"><a class="reference internal" href="nomenclature.html">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#protocol-inheritance">Protocol inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lookup-order-for-prototype-hierarchies">Lookup order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lookup-order-for-class-hierarchies">Lookup order for class hierarchies</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-inheritance">Implementation inheritance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-prototype">Lookup order for prototype hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inheritance-implementation-class">Lookup order for class hierarchies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redefining-inherited-predicate-definitions">Redefining inherited predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specializing-inherited-predicate-definitions">Specializing inherited predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#union-of-inherited-and-local-predicate-definitions">Union of inherited and local predicate definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selective-inheritance-of-predicate-definitions">Selective inheritance of predicate definitions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#public-protected-and-private-inheritance">Public, protected, and private inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-inheritance">Multiple inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-versus-multiple-inheritance">Composition versus multiple inheritance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing and running applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="printing.html">Printing messages and asking questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expansion.html">Term and goal expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Prolog integration and migration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ports/index.html">Ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributions/index.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

    <p class="caption"><span class="caption-text">External Contents</span></p>
    <ul>
    <li class="toctree-l1"><a class="reference internal" href="../../docs/index.html">APIs</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://logtalk.org">Logtalk website</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a></li>
    </ul>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">User Manual</a></li>
      <li class="breadcrumb-item active">Inheritance</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/inheritance.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="inheritance">
<span id="inheritance-inheritance"></span><h1>Inheritance<a class="headerlink" href="#inheritance" title="Link to this heading"></a></h1>
<p>The inheritance mechanisms found on object-oriented programming languages
allow the specialization of previously defined objects, avoiding the
unnecessary repetition of code and allowing the definition of common
functionality for sets of objects. In the context of logic programming,
we can interpret inheritance as a form of <em>theory extension</em>: an object
will virtually contain, besides its own predicates, all the predicates
inherited from other objects that are not redefined locally. Inheritance
is not, however, the only mechanism for theory extension. Logtalk also
supports <em>composition</em> using <a class="reference internal" href="categories.html#categories-categories"><span class="std std-ref">categories</span></a>.</p>
<p>Logtalk uses a depth-first lookup procedure for finding predicate declarations
and predicate definitions, as explained below, when a <a class="reference internal" href="messages.html#messages-messages"><span class="std std-ref">message</span></a>
is sent to an object. The lookup procedures locate the entity holding the
<a class="reference internal" href="../glossary.html#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> and the entity holding the <a class="reference internal" href="../glossary.html#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a>
using the predicate name and arity. The <a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> predicate directive
may be used for defining alternative names for inherited predicates, for
solving inheritance conflicts, and for giving access to all inherited
definitions (thus overriding the default lookup procedure).</p>
<p>The lookup procedures are used when sending a message (using the
<a class="reference internal" href="../refman/control/send_to_object_2.html#control-send-to-object-2"><span class="std std-ref">(::)/2</span></a>, <a class="reference internal" href="../refman/control/send_to_self_1.html#control-send-to-self-1"><span class="std std-ref">(::)/1</span></a>, and
<a class="reference internal" href="../refman/control/delegate_message_1.html#control-delegate-message-1"><span class="std std-ref">[]/1</span></a> control constructs) and when making <em>super</em>
calls (using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a> control construct). The exact
details of the lookup procedures depend on the <a class="reference internal" href="objects.html#objects-roles"><span class="std std-ref">role</span></a>
played by the object receiving the message or making the <em>super</em> call, as
explained next. The lookup procedures are also used by the
<a class="reference internal" href="../refman/methods/current_predicate_1.html#methods-current-predicate-1"><span class="std std-ref">current_predicate/1</span></a> and <a class="reference internal" href="../refman/methods/predicate_property_2.html#methods-predicate-property-2"><span class="std std-ref">predicate_property/2</span></a>
reflection predicates.</p>
<section id="protocol-inheritance">
<span id="inheritance-protocol"></span><h2>Protocol inheritance<a class="headerlink" href="#protocol-inheritance" title="Link to this heading"></a></h2>
<p>Protocol inheritance refers to the inheritance of predicate declarations
(<a class="reference internal" href="../glossary.html#term-predicate-scope-directive"><span class="xref std std-term">scope directives</span></a>). These can be contained
in objects, protocols, or categories. Logtalk supports single and
multi-inheritance of protocols: an object or a category may implement several
protocols and a protocol may extend several protocols.</p>
<section id="lookup-order-for-prototype-hierarchies">
<span id="inheritance-protocol-prototype"></span><h3>Lookup order for prototype hierarchies<a class="headerlink" href="#lookup-order-for-prototype-hierarchies" title="Link to this heading"></a></h3>
<p>The lookup order for predicate declarations is first the object, second
the implemented protocols (and the protocols that these may extend),
third the imported categories (and the protocols that they may implement),
and finally the objects that the object extends (following their declaration
order). This lookup is performed in depth-first order. When an object
inherits two different declarations for the same predicate, by default,
only the first one will be considered.</p>
</section>
<section id="lookup-order-for-class-hierarchies">
<span id="inheritance-protocol-class"></span><h3>Lookup order for class hierarchies<a class="headerlink" href="#lookup-order-for-class-hierarchies" title="Link to this heading"></a></h3>
<p>The lookup order for predicate declarations is first the object classes
(following their declaration order), second the classes implemented protocols
(and the protocols that these may extend), third the classes imported
categories (and the protocols that they may implement), and finally the
superclasses of the object classes. This lookup is performed in depth-first
order. If the object inherits two different declarations for the same
predicate, by default, only the first one will be considered.</p>
</section>
</section>
<section id="implementation-inheritance">
<span id="inheritance-implementation"></span><h2>Implementation inheritance<a class="headerlink" href="#implementation-inheritance" title="Link to this heading"></a></h2>
<p>Implementation inheritance refers to the inheritance of predicate
definitions. These can be contained in objects or in categories. Logtalk
supports multi-inheritance of implementation: an object may import
several categories or extend, specialize, or instantiate several
objects.</p>
<section id="inheritance-implementation-prototype">
<span id="id1"></span><h3>Lookup order for prototype hierarchies<a class="headerlink" href="#inheritance-implementation-prototype" title="Link to this heading"></a></h3>
<p>The lookup order for predicate definitions is similar to the lookup for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives).</p>
</section>
<section id="inheritance-implementation-class">
<span id="id2"></span><h3>Lookup order for class hierarchies<a class="headerlink" href="#inheritance-implementation-class" title="Link to this heading"></a></h3>
<p>The lookup order for predicate definitions is similar to the lookup for
predicate declarations except that implemented protocols are ignored (as
they can only contain predicate directives) and that the lookup starts
at the instance itself (that received the message) before proceeding, if
no predicate definition is found there, to the instance classes imported
categories and then to the class superclasses.</p>
</section>
<section id="redefining-inherited-predicate-definitions">
<span id="inheritance-implementation-redefinition"></span><h3>Redefining inherited predicate definitions<a class="headerlink" href="#redefining-inherited-predicate-definitions" title="Link to this heading"></a></h3>
<p>When we define a predicate that is already inherited from an ancestor object
or an imported category, the inherited definition is hidden by the new
definition. This is called inheritance overriding: a local definition
overrides any inherited definitions. For example, assume that we have the
following two objects:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(bar<span class="o">/</span><span class="m">1</span>).
    bar(root).

<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).
    foo(root).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(descendant).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>After compiling and loading these objects, we can check the overriding
behavior by trying the following queries:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- root::(bar(Bar), foo(Foo)).

Bar = root
Foo = root
yes


| ?- descendant::(bar(Bar), foo(Foo)).

Bar = root
Foo = descendant
yes
</pre></div>
</div>
<p>However, we can explicitly code other behaviors. Some examples follow.</p>
</section>
<section id="specializing-inherited-predicate-definitions">
<span id="inheritance-specialization"></span><h3>Specializing inherited predicate definitions<a class="headerlink" href="#specializing-inherited-predicate-definitions" title="Link to this heading"></a></h3>
<p>Specialization of inherited definitions: the new definition calls the
inherited definition and makes additional calls. This is accomplished
by calling the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a> <em>super call</em> operator
in the new definition. For example, assume a <code class="docutils literal notranslate"><span class="pre">init/0</span></code> predicate
that must account for object specific initializations along the
inheritance chain:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(init<span class="o">/</span><span class="m">0</span>).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;root init&#39;</span>), <span class="k">nl</span>.

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    init <span class="o">:-</span>
        <span class="k">write</span>(<span class="s">&#39;descendant init&#39;</span>), <span class="k">nl</span>,
        <span class="o">^^</span>init.

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- descendant::init.

descendant init
root init
yes
</pre></div>
</div>
</section>
<section id="union-of-inherited-and-local-predicate-definitions">
<span id="inheritance-union"></span><h3>Union of inherited and local predicate definitions<a class="headerlink" href="#union-of-inherited-and-local-predicate-definitions" title="Link to this heading"></a></h3>
<p>Union of the new with the inherited definitions: all the definitions are
taken into account, the calling order being defined by the inheritance
mechanisms. This can be accomplished by writing a clause that just calls,
using the <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a> <em>super call</em> operator, the inherited
definitions. The relative position of this clause among the other definition
clauses sets the calling order for the local and inherited definitions. For
example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(root).

<span class="p">    :- </span><span class="k">public</span>(foo<span class="o">/</span><span class="m">1</span>).

    foo(<span class="m">1</span>).
    foo(<span class="m">2</span>).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(descendant,
    <span class="k">extends</span>(root)).

    foo(<span class="m">3</span>).
    foo(<span class="nv">Foo</span>) <span class="o">:-</span>
        <span class="o">^^</span>foo(<span class="nv">Foo</span>).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- descendant::foo(Foo).

Foo = 3 ;
Foo = 1 ;
Foo = 2 ;
no
</pre></div>
</div>
</section>
<section id="selective-inheritance-of-predicate-definitions">
<span id="inheritance-selective"></span><h3>Selective inheritance of predicate definitions<a class="headerlink" href="#selective-inheritance-of-predicate-definitions" title="Link to this heading"></a></h3>
<p>The selective inheritance of predicate definitions (also known as
differential inheritance) is normally used in the representation
of exceptions to inherited default definitions. We can use the
<a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a> <em>super call</em> operator to test and possibly
reject some of the inherited definitions. A common example is representing
flightless birds:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(bird).

<span class="p">    :- </span><span class="k">public</span>(mode<span class="o">/</span><span class="m">1</span>).

    mode(walks).
    mode(flies).

<span class="p">:- </span><span class="k">end_object</span>.


<span class="p">:- </span><span class="k">object</span>(penguin,
    <span class="k">extends</span>(bird)).

    mode(swims).
    mode(<span class="nv">Mode</span>) <span class="o">:-</span>
        <span class="o">^^</span>mode(<span class="nv">Mode</span>),
        <span class="nv">Mode</span> <span class="o">\==</span> flies.

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- penguin::mode(Mode).

Mode = swims ;
Mode = walks ;
no
</pre></div>
</div>
</section>
</section>
<section id="public-protected-and-private-inheritance">
<span id="inheritance-scope"></span><h2>Public, protected, and private inheritance<a class="headerlink" href="#public-protected-and-private-inheritance" title="Link to this heading"></a></h2>
<p>To make all <a class="reference internal" href="../glossary.html#term-public-predicate"><span class="xref std std-term">public predicates</span></a>
declared via implemented protocols, imported categories, or ancestor
objects <a class="reference internal" href="../glossary.html#term-protected-predicate"><span class="xref std std-term">protected predicates</span></a> or to make
all public and protected predicates
<a class="reference internal" href="../glossary.html#term-private-predicate"><span class="xref std std-term">private predicates</span></a> we prefix the entity’s
name with the corresponding keyword. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">implements</span>(private<span class="o">::</span><span class="nv">Protocol</span>)).

    <span class="c">% all the Protocol public and protected</span>
    <span class="c">% predicates become private predicates</span>
    <span class="c">% for the Object clients</span>

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>or:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Class</span>,
    <span class="k">specializes</span>(protected<span class="o">::</span><span class="nv">Superclass</span>)).

    <span class="c">% all the Superclass public predicates become</span>
    <span class="c">% protected predicates for the Class clients</span>

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>Omitting the scope keyword is equivalent to using the public scope
keyword. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(public<span class="o">::</span><span class="nv">Category</span>)).

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>This is the same as:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(<span class="nv">Object</span>,
    <span class="k">imports</span>(<span class="nv">Category</span>)).

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>This way we ensure backward compatibility with older Logtalk versions
and a simplified syntax when protected or private inheritance are not
used.</p>
</section>
<section id="multiple-inheritance">
<span id="inheritance-multiple"></span><h2>Multiple inheritance<a class="headerlink" href="#multiple-inheritance" title="Link to this heading"></a></h2>
<p>Logtalk supports multi-inheritance by enabling an object to extend,
instantiate, or specialize more than one object. Likewise, a protocol
may extends multiple protocols and a category may extend multiple
categories. In this case, the depth-first lookup algorithms described
above traverse the list of entities per relation from left to right.
Consider as an example the following object opening directive:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(foo,
    <span class="k">extends</span>((bar, baz))).
</pre></div>
</div>
<p>The lookup procedure will look first into the parent object <cite>bar</cite> and
its related entities before looking into the parent object <cite>baz</cite>. The
<a class="reference internal" href="../refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> predicate directive can always be used to
solve multi-inheritance conflicts. It should also be noted that the
multi-inheritance support does not affect performance when we use
single-inheritance.</p>
</section>
<section id="composition-versus-multiple-inheritance">
<span id="inheritance-composition"></span><h2>Composition versus multiple inheritance<a class="headerlink" href="#composition-versus-multiple-inheritance" title="Link to this heading"></a></h2>
<p>It is not possible to discuss inheritance mechanisms without referring
to the long and probably endless debate on single versus multiple
inheritance. The single inheritance mechanism can be implemented
efficiently but it imposes several limitations on reusing, even
if the multiple characteristics we intend to inherit are orthogonal. On
the other hand, the multiple inheritance mechanisms are attractive in
their apparent capability of modeling complex situations. However, they
include a potential for conflict between inherited definitions whose
variety does not allow a single and satisfactory solution for all the
cases.</p>
<p>No solution that we might consider satisfactory for all the
problems presented by the multiple inheritance mechanisms has been
found. From the simplicity of some extensions that use the Prolog search
strategy like <a class="reference internal" href="../bibliography.html#mccabe92" id="id3"><span>[McCabe92]</span></a> or <a class="reference internal" href="../bibliography.html#moss94" id="id4"><span>[Moss94]</span></a> and to the sophisticated algorithms
of CLOS <a class="reference internal" href="../bibliography.html#bobrow-et-al-88" id="id5"><span>[Bobrow_et_al_88]</span></a>, there is no
adequate solution for all the situations. Besides, the use of multiple
inheritance carries some complex problems in the domain of software
engineering, particularly in the reuse and maintenance of the applications.
All these problems are substantially reduced if we preferably use in our
software development composition mechanisms instead of specialization
mechanisms <a class="reference internal" href="../bibliography.html#taenzer89" id="id6"><span>[Taenzer89]</span></a>. Multiple inheritance is best used as an analysis
and project abstraction, rather than as an implementation technique
<a class="reference internal" href="../bibliography.html#shan-et-al-93" id="id7"><span>[Shan_et_al_93]</span></a>. Note that Logtalk provides first-class support for
composition using <a class="reference internal" href="categories.html#categories-categories"><span class="std std-ref">categories</span></a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="predicates.html" class="btn btn-neutral float-left" title="Predicates" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="events.html" class="btn btn-neutral float-right" title="Event-driven programming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1998-2024, Paulo Moura.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>