<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<!--
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  
%  This file is part of Logtalk <http://logtalk.org/>    
%  Copyright (c) 1998-2014 Paulo Moura <pmoura@logtalk.org>
%  
%  Logtalk is free software. You can redistribute it and/or modify it under
%  the terms of the FSF GNU General Public License 3  (plus some additional
%  terms per section 7).        Consult the `LICENSE.txt` file for details.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: writing, running, and debugging programs</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div>
<div class="top-right">Writing, running, and debugging programs</div>
<div class="bottom-left"><span class="page"/></div>
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Programming</div>

<h1 id="programming_programming">Writing, running, and debugging programs</h1>


<h2 id="programming_writing">Writing programs</h2>

<p>
For a successful programming in Logtalk, you need a good working knowledge of Prolog and an understanding of the principles of object-oriented programming. All guidelines for writing good Prolog code apply as well to Logtalk programming. To those guidelines, you should add the basics of good object-oriented design.
</p>
<p>
One of the advantages of a system like Logtalk is that it enable us to use the currently available object-oriented methodologies, tools, and metrics <a href="../bibliography.html#Champaux92">[Champaux 92]</a> in Prolog programming. That said, writing programs in Logtalk is similar to writing programs in Prolog: we define new predicates describing what is true about our domain objects, about our problem solution. We encapsulate our predicate directives and definitions inside new objects, categories and protocols that we create by hand with a text editor or by using the Logtalk built-in predicates. Some of the information collected during the analysis and design phases can be integrated in the objects, categories and protocols that we define by using the available entity and predicate documenting directives.
</p>

<h3 id="programming_source_files">Source files</h3>

<p>
Logtalk source files may contain any number of objects, categories, protocols, and plain Prolog code. If you prefer to define each entity in its own source file, then it is recommended that the source file be named after the entity identifier. For parametric objects, the identifier arity can be appended to the identifier functor. By default, all Logtalk source files use the extension <code>.lgt</code> but this is optional and can be set in the adapter files. Intermediate Prolog source files (generated by the Logtalk compiler) have, by default, a <code>.pl</code> extension. Again, this can be set to match the needs of a particular Prolog compiler in the corresponding adapter file. For example, we may define an object named <code>vehicle</code> and save it in a <code>vehicle.lgt</code> source file that will be compiled to a <code>vehicle.pl</code> Prolog file. If we have a <code>sort(_)</code> parametric object we can save it on a <code>sort_1.lgt</code> source file that will be compiled to a <code>sort_1.pl</code> Prolog file. This name scheme helps avoid file name conflicts (remember that all Logtalk entities share the same name space).
</p>
<p>
Logtalk source files may contain arbitrary Prolog directives and clauses interleaved with Logtalk entity definitions. These directives and clauses are  be copied unchanged to the corresponding Prolog output file. This feature is included to help the integration of Logtalk with Prolog extensions such as, for example, constraint programming extensions. The following Prolog directives are processed when read (thus affecting the compilation of the source code that follows): <code>ensure_loaded/1</code>, <code>use_module/1-2</code>, <code>op/3</code>, and <code>set_prolog_flag/2</code>. The <code>initialization/1</code> directive may be used for defining an initialization goal to be executed when loading a source file.
</p>
<p>
The text encoding used in a source file may be declared using the <a title="Consult reference manual" href="../refman/directives/encoding1.html"><code>encoding/1</code></a> directive when running Logtalk with some back-end Prolog compilers that support multiple encodings (check the <code>encoding_directive</code> flag in the adapter file of your Prolog compiler). The encoding used (and, in the case of a Unicode encoding, any BOM present) in a source file will be used for the generated Prolog and XML files. Logtalk uses the encoding names specified by <a title="" href="http://www.iana.org/assignments/character-sets">IANA</a> (in those cases where a preferred MIME name alias is specified, the alias is used instead).
</p>

<h3 id="programming_portability">Portable programs</h3>

<p>
Logtalk is compatible with almost all modern Prolog compilers. However, this does not necessarily imply that your Logtalk programs will have the same level of portability. If possible, you should only use in your programs Logtalk built-in predicates and ISO Prolog specified built-in predicates and arithmetic functions. If you need to use built-in predicates (or built-in arithmetic functions) that may not be available in other Prolog compilers, you should try to encapsulate the non-portable code in a small number of objects and provide a portable <strong>interface</strong> for that code through the use of Logtalk protocols. An example will be code that access operating-system specific features. The Logtalk compiler can warn you of the use of non-ISO specified built-in predicates and arithmetic functions by using the <code>portability/1</code> compiler flag.
</p>

<h3 id="programming_cc">Conditional compilation</h3>

<p>
Logtalk supports conditional compilation within source files using the <a title="Consult reference manual" href="../refman/directives/if1.html"><code>if/1</code></a>, <a title="Consult reference manual" href="../refman/directives/elif1.html"><code>elif/1</code></a>, <a title="Consult reference manual" href="../refman/directives/else0.html"><code>else/0</code></a>, and <a title="Consult reference manual" href="../refman/directives/endif0.html"><code>endif/0</code></a> directives. This support is similar to the support found in some Prolog compilers such as ECLiPSe, SWI-Prolog, or YAP.
</p>

<h3 id="programming_errors">Avoiding common errors</h3>

<p>
Try to write objects and protocol documentation <strong>before</strong> writing any other code; if you are having trouble documenting a predicate perhaps we need to go back to the design stage.
</p>
<p>
Try to avoid lengthy hierarchies. Besides performance penalties, composition is often a better choice over inheritance for defining new objects (Logtalk supports component-based programming through the use of categories). In addition, prototype-based hierarchies are conceptually simpler and more efficient than class-based hierarchies.
</p>
<p>
Dynamic predicates or dynamic entities are sometimes needed, but we should always try to minimize the use of non-logical features like destructive assignment (asserts and retracts).
</p>
<p>
Since each Logtalk entity is independently compiled, if an object inherits a dynamic or a meta-predicate predicate, then we must repeat the respective directives in order to ensure a correct compilation. 
</p>
<p>
In general, Logtalk does not verify if a user predicate call/return arguments comply with the declared modes. On the other hand, Logtalk built-in predicates, built-in methods, and message sending control structures are carefully checked for calling mode errors.
</p>
<p>
Logtalk error handling strongly depends on the ISO compliance of the chosen Prolog compiler. For instance, the error terms that are generated by some Logtalk built-in predicates assume that the Prolog built-in predicates behave as defined in the ISO standard regarding error conditions. In particular, if your Prolog compiler does not support a <code>read_term/3</code> built-in predicate compliant with the ISO Prolog Standard definition, then the current version of the Logtalk compiler may not be able to detect misspell variables in your source code.
</p>

<h3 id="programming_style">Coding style guidelines</h3>

<p>
It is suggested that all code between an entity opening and closing directives be indented by one tab stop. When defining entity code, both directives and predicates, Prolog coding style guidelines may be applied. All Logtalk source files, examples, and standard library entities use tabs (the recommended setting is a tab width equivalent to 4 spaces) for laying out code. Closed related entities should be defined in the same source file. Entities that might be useful in different contexts (such as library entities) are best defined in their own source files.
</p>


<h2 id="programming_session">Running a Logtalk session</h2>

<p>
We run Logtalk inside a normal Prolog session, after loading the necessary files. Logtalk extends but does not modify your Prolog compiler. We can freely mix Prolog queries with the sending of messages and our programs can be made of both normal Prolog clauses and object definitions.
</p>

<h3 id="programming_starting">Starting Logtalk</h3>

<p>
Depending on your Logtalk installation, you may use a script or a shortcut to start Logtalk with your chosen Prolog compiler. On POSIX operating systems, the scripts should be available from the command-line; scripts are named upon the used Prolog compilers. On Windows, the shortcuts should be available from the Start Menu. If no scripts or shortcuts are available for your installation, operating-system, or Prolog compiler, you can always start a Logtalk session by performing the following steps:
</p>
<ol>
	<li>Start your Prolog compiler.</li>
	<li>Load the appropriate adapter file for your compiler. Adapter files for most common Prolog compilers can be found in the <code>adapters</code> subdirectory.</li>
	<li>Load the library paths file corresponding to your Logtalk installation contained in the <code>paths</code> subdirectory.</li>
	<li>Load the Logtalk compiler/runtime files contained in the <code>compiler</code> subdirectory.</li>
</ol>
<p>
Note that the adapter files, compiler/runtime files, and library paths file are Prolog source files. The predicate called to load (and compile) them depends on your Prolog compiler. In case of doubt, consult your Prolog compiler reference manual or take a look at the definition of the predicate <code>'$lgt_load_prolog_code'/3</code> in the corresponding adapter file.
</p>
<p>
Most Prolog compilers support automatic loading of an initialization file, which can include the necessary directives to load both the Prolog adapter file and the Logtalk compiler. This feature, when available, allows automatic loading of Logtalk when you start your Prolog compiler.
</p>

<h3 id="programming_compiling">Compiling and loading your programs</h3>

<p>
Your programs will be made of source files containing your objects, protocols, and categories. The source files can be compiled to disk by calling the Logtalk built-in predicate  
<a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a>:
</p>
<pre>| ?- logtalk_compile([source_file1, source_file2, ...]).</pre>
<p>
This predicate runs the compiler on each file and, if no fatal errors are found, outputs Prolog source files that can then be consulted or compiled in the usual way by your Prolog compiler.
</p>
<p>
To compile to disk and also load into memory the source files we can use the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a>:
</p>
<pre>| ?- logtalk_load([source_file1, source_file2, ...]).</pre>
<p>
This predicate works in the same way of the predicate <code>logtalk_compile/1</code> but also loads the compiled files to memory. 
</p>
<p>
Both predicates expect a source file name or a list of source file names as an argument. The Logtalk source file name extension, as defined in the adapter file (by default, <code>.lgt</code>), can be omitted.
</p>
<p>
If you have more than a few source files then you may want to use a loader helper file containing the calls to the <code>logtalk_load/1-2</code> predicates. Consulting or compiling the loader file will then compile and load all your Logtalk entities into memory (see below for details).
</p>
<p>
With most Prolog back-end compilers, you can use the shorthands <code>{File}</code> for <code>logtalk_load(File)</code> and <code>{File1, File2, ...}</code> for <code>logtalk_load([File1, File2, ...])</code>. The use these shorthands should be restricted to the Logtalk/Prolog top-level interpreter as their are not part of the language specification and may be commented out in case of conflicts with backend Prolog compiler features.
</p>
<p>
The built-in predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_make0.html"><code>logtalk_make/0</code></a> can be used to reload all modified source files. Note, however, that only Logtalk source files are reloaded. An extended version of this predicate, <a title="Consult reference manual" href="../refman/builtins/logtalk_make1.html"><code>logtalk_make/1</code></a>, accepts <code>all</code> and <code>clean</code> arguments for, respectively, reloading modified Logtalk source files and deleting any intermediate files generated by the compilation of Logtalk source files. With most Prolog backend compilers, you can use the shorthands <code>{*}</code> for <code>logtalk_make(all)</code> and <code>{!}</code> for <code>logtalk_make(clean)</code>. The <code>logtalk_make(clean)</code> goal can be specially useful when reloading unmodified source files after changing compiler flags such as <code>debug</code> or before switching backend Prolog compilers.
</p>

<h3 id="programming_loaders">Loader utility files</h3>

<p>
Most examples directories contain a Logtalk utility file that can be used to load all included source files. These loader utility files are usually named <code>loader.lgt</code> or contain the word "loader" in their name. Loader files are ordinary source file and thus compiled and loaded like any source file. For an example loader file named <code>loader.lgt</code> we would type:
</p>
<pre>| ?- logtalk_load(loader).</pre>
<p>
Usually these files contain a call to the Logtalk built-in predicates <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> (e.g. for setting global, <em>project-specific</em>, flag values) and <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a> or <a title="Consult reference manual" href="../refman/builtins/logtalk_load2.html"><code>logtalk_load/2</code></a> (for loading project files), wrapped inside an <code>initialization/1</code> directive. For instance, if your code is split in three Logtalk source files named <code>source1.lgt</code>, <code>source2.lgt</code>, and <code>source3.lgt</code>, then the contents of your loader file could be:
</p>
<pre>:- initialization((
    set_logtalk_flag(events, allow),           % set project-specific flags
    logtalk_load([source1, source2, source3])  % load the project source files
)).</pre>
<p>
Another example of directives that are often used in a loader file would be <code>op/3</code> directives declaring global operators needed by your application. Loader files are also often used for setting source file-specific compiler options (this is useful even when you only have a single source file if you always load it with using the same set of compiler options). For example:
</p>
<pre>:- initialization((
    set_logtalk_flag(underscore_variables, dont_care),
    set_logtalk_flag(source_data, off),
    logtalk_load(
        [source1, source2, source3],
        [portability(warning)]),               % source file-specific flags
    logtalk_load(
        [source4, source5],
        [portability(silent)])                 % source file-specific flags
)).</pre>
<p>
To take the best advantage of loader files, assert a clause to the dynamic predicate <code>logtalk_library_path/2</code> for the directory containing your source files as explained in the next section.
</p>
<p>
A common mistake is to try to set compiler options using <code>logtalk_load/2</code> with a loader file. For example, by writing:
</p>
<pre>| ?- logtalk_load(loader, [underscore_variables(dont_care), source_data(off)]).</pre>
<p>
This will not work as you might expect as the compiler options will only be used in the compilation of the <code>loader.lgt</code> file itself and will not affect the compilation of files loaded through the <code>initialization/1</code> directive contained on the loader file.	
</p>
<p>
When developing new applications, it's a good idea to set the <code>reload</code> flag for the loader file to <code>always</code> by adding the directive:
</p>
<pre>:- set_logtalk_flag(reload, always).</pre>
<p>
Note that, by using a directive, the flag is local to the loader file. If one of the files loaded by the loader file fails to compile and load due to syntax errors, you can then simply reload the loader file after fixing those errors to load that file. If the <code>reload</code> flag was set to its default value, <code>changed</code>, you would not be able to simply reload the loader file to load the now fixed files. The <code>logtalk_make/0-1</code> predicates (which reload modified files since loaded) would also be of no avail as those files with syntax errors were never loaded in the first place.
</p>

<h3 id="programming_libraries">Libraries of source files</h3>

<p>
Logtalk defines a <em>library</em> simply as a directory containing source files. Library locations can be specified by defining or asserting clauses for the dynamic and multifile predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_library_path2.html"><code>logtalk_library_path/2</code></a>. For example:
</p>
<pre>| ?- assertz(logtalk_library_path(shapes, '$LOGTALKUSER/examples/shapes/')). </pre>
<p>
The first argument of the predicate is used as an alias for the path on the second argument. Library aliases may also be used on the second argument. For example:
</p>
<pre>| ?- assertz(logtalk_library_path(lgtuser, '$LOGTALKUSER/')),
     assertz(logtalk_library_path(examples, lgtuser('examples/'))),
     assertz(logtalk_library_path(viewpoints, examples('viewpoints/'))).</pre>
<p>
This allows us to load a library source file without the need to first change the current working directory to the library directory and then back to the original directory. For example, in order to load a <code>loader.lgt</code> file, contained in a library named <code>viewpoints</code>, we just need to type:
</p>
<pre>| ?- logtalk_load(viewpoints(loader)). </pre>
<p>
The best way to take advantage of this feature is to load at startup a source file containing an <code>initialization/1</code> directive which asserts all the <code>logtalk_library_path/2</code> clauses needed for all available libraries. This allows us to load library source files or entire libraries without worrying about libraries paths, improving code portability. The directory paths on the second argument should always end with the path directory separator character. Most back-end Prolog compilers allows the use of environment variables in the second argument of the <code>logtalk_library_path/2</code> predicate. Use of POSIX relative paths (e.g. <code>'../'</code> or <code>'./'</code>) for top-level library directories (e.g. <code>lgtuser</code> in the example above) is not advised as different back-end Prolog compilers may start with different initial working directories, which may result in portability problems of your loader files.
</p>
<p>
The library notation provides functionality inspired by the <code>file_search_path/2</code> mechanism introduced by Quintus Prolog and later adopted by some other Prolog compilers.
</p>

<h3 id="programming_flags">Compiler flags</h3>

<p>
The <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a> and <a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a> always use the current set of default compiler flags as specified in your settings file and the Logtalk adapter files or changed for the current session using the built-in predicate <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a>. Although the default flag values cover the usual cases, you may want to use a different set of flag values while compiling or loading some of your Logtalk source files. This can be accomplished by using the <a title="Consult reference manual" href="../refman/builtins/logtalk_load2.html"><code>logtalk_load/2</code></a> or the <a title="Consult reference manual" href="../refman/builtins/logtalk_compile2.html"><code>logtalk_compile/2</code></a> built-in predicates. These two predicates accept a list of flag values affecting how a Logtalk source file is compiled and loaded:
</p>
<pre>| ?- logtalk_compile(Files, Flags).</pre>
<p>
or:
</p>
<pre>| ?- logtalk_load(Files, Flags).</pre>
<p>
In fact, the <code>logtalk_load/1</code> and <code>logtalk_compile/1</code> predicates are just shortcuts to the extended versions called with the default compiler flag values.
</p>
<p>
We may also change the default flag values from the ones loaded from the adapter file by using the <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> built-in predicate. For example:
</p>
<pre>| ?- set_logtalk_flag(unknown_entities, silent).</pre>
<p>
The current default flags values can be enumerated using the <a title="Consult reference manual" href="../refman/builtins/current_logtalk_flag2.html"><code>current_logtalk_flag/2</code></a> built-in predicate:
</p>
<pre>| ?- current_logtalk_flag(unknown_entities, Value).

Value = silent
yes</pre>
<p>
Logtalk also implements a <a title="Consult reference manual" href="../refman/directives/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> directive, which can be used to set flags within a source file or within an entity. For example:
</p>
<pre>
% compile all objects in the source file with event support
:- set_logtalk_flag(events, allow).

:- object(foo).

    % compile this object with support for dynamic predicate declarations
    :- set_logtalk_flag(dynamic_declarations, allow).
    ...

:- end_object.

...</pre>
<p>
Note that the scope of the <code>set_logtalk_flag/2</code> directive is local to the entity or to the source file containing it.
</p>

<h4>Version flags</h4>

	<dl>
		<dt><code>version_data(Value)</code></dt>
			<dd>Read-only flag whose value is the compound term <code>logtalk(Major,Minor,Patch,Status)</code>. The first three arguments are integers and the last argument is an atom, possibly empty, representing alpha or beta version status. The <code>version_data</code> flag is also a de facto standard for Prolog compilers.</dd>
	</dl>
	<dl>
		<dt><code>version(Value)</code></dt>
		<dd>Deprecated read-only flag, inherited from Logtalk 2.x, whose value is the compound term <code>version(Major,Minor,Patch)</code>. The arguments are integers. New applications that are not required to support Logtalk 2.x should use the <code>version_data</code> flag instead.</dd>
	</dl>

<h4>Lint flags</h4>

	<dl>
		<dt><code>unknown_entities(Option)</code></dt>
			<dd>Controls the unknown entity warnings, resulting from loading an entity that references some other entity that is not currently loaded. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>. Note that these warnings are not always avoidable, specially when using reflective designs of class-based hierarchies.</dd>
	</dl>
	<dl>
		<dt><code>misspelt_calls(Option)</code></dt>
			<dd>Controls the misspelt predicate call warnings. A misspelt call is a call to a predicate which is not defined in the object or category containing the call, is not declared as dynamic, and is not a Logtalk/Prolog built-in predicate. Possible option values are <code>error</code>, <code>warning</code> (the usual default), and <code>silent</code> (not recommended).</dd>
	</dl>
	<dl>
		<dt><code>portability(Option)</code></dt>
			<dd>Controls the non-ISO specified Prolog built-in predicate and non-ISO specified Prolog built-in arithmetic function calls warnings plus use of non-standard Prolog flags and/or flag values. Possible option values are <code>warning</code> and <code>silent</code> (the usual default).</dd>
	</dl>
	<dl>
		<dt><code>missing_directives(Option)</code></dt>
			<dd>Controls the missing predicate directive warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code> (not recommended).</dd>
	</dl>
	<dl>
		<dt><code>redefined_built_ins(Option)</code></dt>
			<dd>Controls the Logtalk and Prolog built-in predicate redefinition warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>. Warnings about redefined Prolog built-in predicates are often the result of running a Logtalk application on several Prolog compilers as each Prolog compiler defines its set of built-in predicates.</dd>
	</dl>
	<dl>
		<dt><code>singleton_variables(Option)</code></dt>
			<dd>Controls the singleton variable warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code> (not recommended).</dd>
	</dl>
	<dl>
		<dt><code>underscore_variables(Option)</code></dt>
			<dd>Controls the interpretation of variables that start with an underscore (excluding the anonymous variable) that occur once in a term as either don't care variables or singleton variables. Possible option values are <code>dont_care</code> and <code>singletons</code> (the usual default). Note that, depending on your Prolog compiler, the <code>read_term/3</code> built-in predicate may report variables that start with an underscore as singleton variables. There is no standard behavior, hence this option.</dd>
	</dl>

<h4>Optional features compilation flags</h4>

	<dl>
		<dt><code>complements(Option)</code></dt>
			<dd>Allows objects to be compiled with support for complementing categories turned off in order to improve performance and security. Possible option values are <code>allow</code> (allow complementing categories to override local object predicate declarations and definitions), <code>restrict</code> (allow complementing categories to add predicate declarations and definitions to an object but not to override them), and <code>deny</code> (ignore complementing categories; the usual default). This option can be used on a per-object basis. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>dynamic_declarations(Option)</code></dt>
			<dd>Allows objects to be compiled with support for dynamic declaration of new predicates turned off in order to improve performance and security. Possible option values are <code>allow</code> and <code>deny</code> (the usual default). This option can be used on a per-object basis. Note that changing this option is of no consequence for objects already compiled and loaded. This option is only checked when sending an <code>asserta/1</code> or <code>assertz/1</code> message to an object. Local asserting of new predicates is always allowed.</dd>
	</dl>
	<dl>
		<dt><code>events(Option)</code></dt>
			<dd>Allows message sending calls to be compiled with event-driven programming support disable in order to improve performance. Possible option values are <code>allow</code> and <code>deny</code> (the usual default). Objects (and categories) compiled with this option set to <code>deny</code> use optimized code for message-sending calls that does not trigger events. As such, this option can be used on a per-object (or per-category) basis. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>context_switching_calls(Option)</code></dt>
			<dd>Allows context switching calls (<code>&lt;&lt;/2</code>) to be either allowed or denied. Possible option values are <code>allow</code> and <code>deny</code>. The default flag vale is <code>allow</code>. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>

<h4>Back-end Prolog compiler and loader flags</h4>

	<dl>
		<dt><code>prolog_compiler(Options)</code></dt>
			<dd>Compiler options for the generated Prolog files. The usual default is the empty list. These options are passed to the back-end Prolog compiler built-in predicate that is responsible for compiling to disk a Prolog file. For Prolog compilers that don't provide separate predicates for compiling and loading a file, use instead the <code>prolog_loader/1</code> flag.</dd>
	</dl>
	<dl>
		<dt><code>prolog_loader(Options)</code></dt>
			<dd>Loader options for the generated Prolog files. The usual default is the empty list. These options are passed to the back-end Prolog compiler built-in predicate that is responsible for loading a (compiled) Prolog file.</dd>
	</dl>

<h4>Other flags</h4>

	<dl>
		<dt><code>scratch_directory(Directory)</code></dt>
			<dd>Sets the directory to be used to store the temporary files generated when compiling Logtalk source files. The default value is a sub-directory of the source files directory, either <code>./lgt_tmp</code> or <code>./.lgt_tmp</code> (depending on the back-end Prolog compiler and operating-system). Relative directories must always start with <code>./</code> due to the lack of a portable solution to check if a path is relative or absolute.</dd>
	</dl>

	<dl>
		<dt><code>report(Option)</code></dt>
			<dd>Controls the default printing of messages. Possible option values are <code>on</code> (by usual default, print all messages that are not intercepted by the user), <code>warnings</code> (only print warning messages that are not intercepted by the user), and <code>off</code> (do not print any messages that are not intercepted by the user).</dd>
	</dl>
	<dl>
		<dt><code>code_prefix(Option)</code></dt>
			<dd>Enables the definition of prefix for all functors of Prolog code generated by the Logtalk compiler. The option value must be an atom; the default value is <code>'$'</code>. Specifying a code prefix provides a way to solve possible conflicts between Logtalk compiled code and other Prolog code. In addition, some Prolog compilers automatically hide predicates whose functor start with a specific prefix such as the character <code>$</code>.</dd>
	</dl>
	<dl>
		<dt><code>optimize(Option)</code></dt>
			<dd>Controls the compiler optimizations. Possible option values are <code>on</code> (used by default for deployment) and <code>off</code> (used by default for development). Compiler optimizations include the use of static binding whenever possible, the removal of redundant calls to <code>true/0</code> from predicate clauses, and the removal of redundant unifications when compiling grammar rules. Care should be taken when developing applications with this flag turned on as changing and reloading a file may render static binding optimizations invalid for code defining in other loaded files.</dd>
	</dl>
	<dl>
		<dt><code>source_data(Option)</code></dt>
			<dd>Defines how much information is retained when compiling a source file. Possible option values are <code>on</code> (the usual default) and <code>off</code>. With this flag set to <code>on</code>, Logtalk will keep the information represented using documenting directives plus source location data (including source file names and line numbers). This information can be retrieved using reflection and is useful both for debugging and for integration with development tools. This flag can be turned off in order to generate more compact code.</dd>
	</dl>
	<dl>
		<dt><code>debug(Option)</code></dt>
			<dd>Controls the compilation of source files in debug mode (the Logtalk default debugger can only be used with files compiled in this mode). Possible option values are <code>on</code> and <code>off</code> (the usual default).</dd>
	</dl>
	<dl>
		<dt><code>reload(Option)</code></dt>
			<dd>Defines the reloading behavior for source files. Possible option values are <code>skip</code> (skip loading of already loaded files; this value can be used to get similar functionality to the Prolog directive <code>ensure_loaded/1</code>), <code>changed</code> (reload files that are changed since last loaded provided that the any explicit flags are the same as the before), and <code>always</code> (always reload files).</dd>
	</dl>
	<dl>
		<dt><code>hook(Object)</code></dt>
			<dd>Allows the definition of compiler hooks that are called for each term read form a source file and for each compiled goal. This option specifies an object (which can be the pseudo-object <code>user</code>) implementing the <code>expanding</code> built-in protocol. It's also possible to specify a Prolog module instead of a Logtalk object but the module must be pre-loaded and its identifier must be different from any object identifier. The object is expected to define clauses for the <a title="Consult reference manual" href="../refman/methods/term_expansion2.html"><code>term_expansion/2</code></a> and <a title="Consult reference manual" href="../refman/methods/goal_expansion2.html"><code>goal_expansion/2</code></a> predicates. In the case of the <code>term_expansion/2</code> predicate, the first argument is the term read form the source file while the second argument returns a list of terms corresponding to the expansion of the first argument. In the case of the <code>goal_expansion/2</code> predicate, the second argument should be a goal resulting from the expansion of the goal in the first argument. The predicate <code>goal_expansion/2</code> is called on the expanded goals so care must be taken to avoid compilation loops.</dd>
	</dl>
	<dl>
		<dt><code>clean(Option)</code></dt>
			<dd>Controls cleaning of the intermediate Prolog files generated when compiling Logtalk source files. Possible option values are <code>off</code> and <code>on</code> (the usual default). When turned on, this flag also forces recompilation of all source files, disregarding any existing intermediate files. Thus, it is strong advisable to turn off this flag when switching backend Prolog compilers as the intermediate files generated by the compilation of source files may not be portable (due to differences in the implementation of the standard <code>write_canonical/2</code> predicate).</dd>
	</dl>

<h3 id="programming_smart">Reloading and smart compilation of source files</h3>

<p>
As a general rule, reloading source files should never occur in production code and should be handled with care in development code. Reloading a Logtalk source file usually requires reloading the intermediate Prolog file that is generated by the Logtalk compiler. The problem is that there is no standard behavior for reloading Prolog files. For static predicates, almost all Prolog compilers replace the old definitions with the new ones. However, for dynamic predicates, the behavior depends on the Prolog compiler. Most compilers replace the old definitions but some of them simply append the new ones, which usually leads to trouble. See the compatibility notes for the back-end Prolog compiler you intend to use for more information. There is an additional potential problem when using multi-threading programming. Reloading a threaded object does not recreate from scratch its old message queue, which may still be in use (e.g. threads may be waiting on it).
</p>
<p>
When using library entities and stable code, you can avoid reloading the corresponding source files (and, therefore, recompiling them) by setting the compiler option <code>reload</code> to <code>skip</code>. For code under development, you can turn off the <code>clean</code> to avoid recompiling files that have not been modified since last compilation (assuming that back-end Prolog compiler that you are using supports retrieving of file modification dates). You can disable deleting the intermediate files generated when compiling source files by changing the default flag value in your settings file, by using the corresponding compiler flag with the compiling and loading built-in predicates, or, for the remaining of a working session, by using the call:
</p>
<pre>| ?- set_logtalk_flag(clean, off).</pre>
<p>
Some caveats that you should be aware. First, some warnings that might be produced when compiling a source file will not show up if the corresponding object file is up-to-date because the source file is not being (re)compiled. Second, if you are using several Prolog compilers with Logtalk, be sure to perform the first compilation of your source files with smart compilation turned off: the intermediate Prolog files generated by the Logtalk compiler may be not compatible across Prolog compilers or even for the same Prolog compiler across operating systems (e.g. due to the use of different character encodings or end-of-line characters).
</p>

<h3 id="programming_batch">Using Logtalk for batch processing</h3>

<p>
If you use Logtalk for batch processing, you probably want to suppress most, if not all, banners, messages, and warnings that are normally printed by the core system. To suppress printing of all core messages (including compiling warnings but not compiling error messages), turn off the option <code>report</code>.
</p>


<h2 id="programming_debugging">Debugging Logtalk programs</h2>

<p>
The Logtalk distribution includes in its <code>tools</code> directory a command-line debugger, implemented as an object (named <code>debugger</code>). It can be loaded by typing:
</p>
<pre>| ?- logtalk_load(debugger(loader)).</pre>
<p>
This tool implements debugging features similar to those found on most Prolog compilers. However, there are some differences between the usual implementation of Prolog debuggers and the current implementation of the Logtalk debugger that you should be aware. First, unlike some Prolog debuggers, the Logtalk debugger is not implemented as a meta-interpreter. This translates to a different, although similar, set of debugging features with some limitations when compared with some Prolog debuggers. Second, debugging is only possible for objects compiled in debug mode. When compiling an object in debug mode, Logtalk keeps each clause goal in both source form and compiled form in order to allow tracing of the goal execution. Third, implementation of spy points allows the user to specify the execution context for entering the debugger. This feature is a consequence of the encapsulation of predicates inside objects.
</p>

<h3 id="programming_debugmode">Compiling entities in debug mode</h3>

<p>
Compilation of source files in debug mode is controlled by the compiler flag <code>debug</code>. The default value for this flag, usually <code>off</code>, is defined in the adapter files. Its value may be changed at runtime by writing:
</p>
<pre>| ?- set_logtalk_flag(debug, on).</pre>
<p>
In alternative, if we want to compile only some entities in debug mode, we may instead write:
</p>
<pre>| ?- logtalk_load([file1, file2, ...], [debug(on)]).</pre>
<p>
The compiler flag <code>clean</code> is automatically turned on whenever the debug flag is turned on at runtime. This is necessary because debug code would not be generated for files previously compiled in normal mode if there are no changes to the source files.
</p>
<p>After loading the debugger, we may check or enumerate, by backtracking, all loaded entities compiled in debug mode as follows:
</p>
<pre>| ?- debugger::debugging(Entity).</pre>

<h3 id="programming_boxmodel">Logtalk Procedure Box model</h3>

<p>
Logtalk uses a <em>Procedure Box model</em> similar to those found on most Prolog compilers. The traditional Prolog procedure box model uses four ports (<em>call</em>, <em>exit</em>, <em>redo</em>, and <em>fail</em>) for describing control flow when a predicate clause is used during program execution: 
</p>
<dl>
	<dt><code>call</code></dt>
		<dd>predicate call</dd>
	<dt><code>exit</code></dt>
		<dd>success of a predicate call</dd>
	<dt><code>redo</code></dt>
		<dd>backtracking into a predicate</dd>
	<dt><code>fail</code></dt>
		<dd>failure of a predicate call</dd>
</dl>
<p>
Logtalk, as found on some recent Prolog compilers, adds a port for dealing with exceptions thrown when calling a predicate:
</p>
<dl>
	<dt><code>exception</code></dt>
		<dd>predicate call throws an exception</dd>
</dl>
<p>
In addition to the ports described above, Logtalk adds two more ports, <em>fact</em> and <em>rule</em>, which show the result of the unification of a goal with, respectively, a fact and a rule head:
</p>
<dl>
	<dt><code>fact</code></dt>
		<dd>unification success between a goal and a fact</dd>
	<dt><code>rule</code></dt>
		<dd>unification success between a goal and a rule head</dd>
</dl>
<p>
For static predicates, the debugger prints the clause number at the unification ports: <code>Fact #N</code> or <code>Rule #N</code> indicates that clause <code>N</code> is being used for proving a goal.
</p>
<p>
The user may define for which ports the debugger should pause for user interaction by specifying a list of leashed ports. For example:
</p>
<pre>| ?- debugger::leash([call, exit, fail]).</pre>
<p>
Alternatively, the user may use an atom abbreviation for a pre-defined set of ports. For example:
</p>
<pre>| ?- debugger::leash(loose).</pre>
<p>
The abbreviations defined in Logtalk are similar to those defined on some Prolog compilers:
</p>
<dl>
	<dt><code>none</code></dt>
		<dd><code>[]</code></dd>
	<dt><code>loose</code></dt>
		<dd><code>[fact, rule, call]</code></dd>
	<dt><code>half</code></dt>
		<dd><code>[fact, rule, call, redo]</code></dd>
	<dt><code>tight</code></dt>
		<dd><code>[fact, rule, call, redo, fail, exception]</code></dd>
	<dt><code>full</code></dt>
		<dd><code>[fact, rule, call, exit, redo, fail, exception]</code></dd>
</dl>

<h3>Defining spy points<a id="programming_spypoints"></a></h3>

<p>
Logtalk spy points can be defined by simply stating which predicates should be spied, as in most Prolog debuggers, or by fully specifying the context for activating a spy point. 
</p>

<h4>Defining predicate spy points<a id="programming_pspypoints"></a></h4>

<p>
Predicate spy points are specified using the method <code>spy/1</code>. The argument can be either a predicate indicator (<code>Functor/Arity</code>) or a list of predicate indicators. For example:
</p>
<pre>| ?- debugger::spy(foo/2).

Spy points set.
yes

| ?- debugger::spy([foo/4, bar/1]).

Spy points set.
yes</pre>
<p>
Predicate spy points can be removed by using the method <code>nospy/1</code>. The argument can be a predicate indicator, a list of predicate indicators, or a non-instantiated variable in which case all predicate spy points will be removed. For example:
</p>
<pre>| ?- debugger::nospy(_).

All matching predicate spy points removed.
yes</pre>

<h4>Defining context spy points<a id="programming_cspypoints"></a></h4>

<p>
A context spy point is a term describing a message execution context and a goal:
</p>
<pre>(Sender, This, Self, Goal)</pre>
<p>
The debugger is evoked whenever the execution context is true and when the spy point goal unifies with the goal currently being executed. Variable bindings resulting from the unification between the current goal and the goal argument are discarded. The user may establish any number of context spy points as necessary. For example, in order to call the debugger whenever a predicate defined on an object named <code>foo</code> is called we may define the following spy point:
</p>
<pre>| ?- debugger::spy(_, foo, _, _).

Spy point set.
yes</pre>
<p>
For example, we can spy all calls to a <code>foo/2</code> predicate by setting the condition:
</p>
<pre>| ?- debugger::spy(_, _, _, foo(_, _)).

Spy point set.
yes</pre>
<p>
The method <code>nospy/4</code> may be used to remove all matching spy points. For example, the call: 
</p>
<pre>| ?- debugger::nospy(_, _, foo, _).

All matching context spy points removed.
yes</pre>
<p>
will remove all context spy points where the value of <em>Self</em> matches the name <code>foo</code>.
</p>

<h4>Removing all spy points<a id="programming_nospyall"></a></h4>

<p>
We may remove all predicate spy points and all context spy points by using the method <code>nospyall/0</code>:
</p>
<pre>| ?- debugger::nospyall.

All predicate spy points removed.
All context spy points removed.
yes</pre>

<h3 id="programming_trace">Tracing program execution</h3>

<p>
Logtalk allows tracing of execution for all objects compiled in debug mode. To start the debugger in trace mode, write:
</p>
<pre>| ?- debugger::trace.

yes</pre>
<p>
Note that, when tracing, spy points will be ignored. While tracing, the debugger will pause for user input at each leashed port, printing an informative message with the port name and the current goal. After the port name, the debugger prints the goal invocation number (except for the unification ports). This invocation number is unique and can be used to correlate the port trace messages.
</p>
<p>
To stop tracing and turning off the debugger, write:
</p>
<pre>| ?- debugger::notrace.

yes</pre>


<h3 id="programming_debug">Debugging using spy points</h3>

<p>
Tracing a program execution may generate large amounts of debugging data. Debugging using spy points allows the user to concentrate its attention in specific points of its code. To start a debugging session using spy points, write:
</p>
<pre>| ?- debugger::debug.

yes</pre>
<p>
At the beginning of a port description, the debugger will print a <code>+</code> or a <code>*</code> before the current goal if there is, respectively, a predicate spy point or a context spy point defined.
</p>
<p>
To stop the debugger, write:
</p>
<pre>| ?- debugger::nodebug.

yes</pre>
<p>
Note that stopping the debugger does not remove any defined spy points.
</p>

<h3 id="programming_commands">Debugging commands</h3>

<p>
The debugger pauses at leashed posts when tracing or when finding a spy point for user interaction. The commands available are as follows:
</p>
<dl>
	<dt><code>c</code> &mdash; creep</dt>
		<dd>go on; you may use the spacebar, return, or enter keys in alternative</dd>
	<dt><code>l</code> &mdash; leap</dt>
		<dd>continues execution until the next spy point is found</dd>
	<dt><code>s</code> &mdash; skip</dt>
		<dd>skips debugging for the current goal; only meaningful at call and redo ports</dd>
	<dt><code>i</code> &mdash; ignore</dt>
		<dd>ignores goal, assumes that it succeeded; only valid at call and redo ports</dd>
	<dt><code>f</code> &mdash; fail</dt>
		<dd>forces backtracking; may also be used to convert an exception into a failure</dd>
	<dt><code>n</code> &mdash; nodebug</dt>
		<dd>turns off debugging</dd>
	<dt><code>@</code> &mdash; command; <code>!</code> can be used in alternative</dt>
		<dd>reads and executes a query</dd>
	<dt><code>b</code> &mdash; break</dt>
		<dd>suspends execution and starts new interpreter; type <code>end_of_file</code> to terminate</dd>
	<dt><code>a</code> &mdash; abort</dt>
		<dd>returns to top level interpreter</dd>
	<dt><code>Q</code> &mdash; quit</dt>
		<dd>quits Logtalk</dd>
	<dt><code>p</code> &mdash; print</dt>
		<dd>writes current goal using the print/1 predicate if available</dd>
	<dt><code>d</code> &mdash; display</dt>
		<dd>writes current goal without using operator notation</dd>
	<dt><code>w</code> &mdash; write</dt>
		<dd>writes current goal quoting atoms if necessary</dd>
	<dt><code>$</code> &mdash; dollar</dt>
		<dd>outputs the compiled form of the current goal (for low-level debugging)</dd>
	<dt><code>x</code> &mdash; context</dt>
		<dd>prints execution context</dd>
	<dt><code>e</code> &mdash; exception</dt>
		<dd>prints exception term thrown by the current goal</dd>
	<dt><code>=</code> &mdash; debugging</dt>
		<dd>prints debugging information</dd>
	<dt><code>*</code> &mdash; add</dt>
		<dd>adds a context spy point for the current goal</dd>
	<dt><code>/</code> &mdash; remove</dt>
		<dd>removes a context spy point for the current goal</dd>
	<dt><code>+</code> &mdash; add</dt>
		<dd>adds a predicate spy point for the current goal</dd>
	<dt><code>-</code> &mdash; remove</dt>
		<dd>removes a predicate spy point for the current goal</dd>
	<dt><code>h</code> &mdash; help</dt>
		<dd>prints list of command options; <code>?</code> can be used in alternative</dd>
</dl>

<h3 id="programming_context">Context-switching calls</h3>

<p>
Logtalk provides a control construct, <a title="Consult reference manual" href="../refman/control/context2.html"><code>&lt;&lt;/2</code></a>, which allows the execution of a query within the context of an object. Common debugging uses include checking an object local predicates (e.g. predicates representing internal dynamic state) and sending a message from within an object. This control construct may also be used to write unit tests.
</p>
<p>
Consider the following toy example:
</p>
<pre>:- object(broken).

    :- public(a/1).
    :- private([b/2, c/1]).
    :- dynamic(c/1).

    a(A) :- b(A, B), c(B).
    b(1, 2). b(2, 4). b(3, 6).
    c(3).    % in a real-life example, this would be a clause asserted at runtime

:- end_object.
</pre>
<p>
Something is wrong when we try the object public predicate, <code>a/1</code>:
</p>
<pre>| ?- broken::a(A).

no</pre>
<p>
For helping diagnosing the problem, instead of compiling the object in debug mode and doing a <em>trace</em> of the query to check the clauses for the non-public predicates, we can instead simply type:
</p>
<pre>| ?- broken &lt;&lt; c(C).

C = 3
yes
</pre>
<p>
The <code>&lt;&lt;/2</code> control construct works by switching the execution context to the object in the first argument and then compiling and executing the second argument within that context:
</p>
<pre>| ?- broken &lt;&lt; (self(Self), sender(Sender), this(This)).

Self = broken
Sender = broken
This = broken

yes</pre>
<p>
As exemplified above, the <code>&lt;&lt;/2</code> control construct allows you to call an object local and private predicates. However, it is important to stress that we are not bypassing or defeating an object predicate scope directives. The calls take place within the context of the specified object, not within the context of the object making the <code>&lt;&lt;/2</code> call. Thus, the <code>&lt;&lt;/2</code> control construct  implements a form of <em>execution-context switching</em>.
</p>
<p>
The availability of the <code>&lt;&lt;/2</code> control construct is controlled by the compiler flag <code>context_switching_calls</code>, which default value is defined in the adapter files of the back-end Prolog compilers.
</p>

<h3 id="programming_hooks">Using compilation hooks and term expansion for debugging</h3>

<p>
It is possible to use compilation hooks and the term expansion mechanism for conditional compilation of debugging goals. Assume that we chose the predicate <code>debug/1</code> to represent debug goals. For example:
</p>
<pre>append([], List, List) :-
    debug((write('Base case: '), writeq(append([], List, List)), nl)).
append([Head| Tail], List, [Head| Tail2]) :-
    debug((write('Recursive case: '), writeq(append(Tail, List, Tail2)), nl)),
    append(Tail, List, Tail2).</pre>
<p>
When debugging, we want to call the argument of the predicate <code>debug/1</code>. This can be easily accomplished by defining a hook object containing the following definition for <code>goal_expansion/2</code>:
</p>
<pre>goal_expansion(debug(Goal), Goal).</pre>
<p>
When not debugging, we can use a second hook object to discard the <code>debug/1</code> calls by defining the predicate <code>goal_expansion/2</code> as follows:
</p>
<pre>goal_expansion(debug(_), true).</pre>
<p>
The Logtalk compiler automatically removes any redundant calls to the built-in predicate <code>true/0</code> when compiling object predicates.
</p>

<h3 id="programming_dcgs">Debugging grammar rules</h3>

<p>
When objects or categories containing grammar rules are compiled in debug mode, calls to non-terminals in grammar rules are printed by the debugger as call to the predicate <code>phrase/3</code>. This makes it possible to distinguish between calls to predicates resulting from the compilation of grammar rules from calls to other predicates. In addition, in debug mode, Logtalk tries to print any exception, in particular, existence errors, in terms of non-terminals instead of in terms of the predicates that would resulted from the compilation of grammar rules.
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: December 8, 2013</span>
	</div>
	<div class="navbottom">
		<span><a href="installing.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="migration.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
