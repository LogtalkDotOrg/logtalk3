<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nomenclature &mdash; The Logtalk Handbook v3.81.0-b01 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=396eccfe" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=9456dd46"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Messages" href="messages.html" />
    <link rel="prev" title="Main features" href="features.html" />
   
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Logtalk Handbook
              <img src="../_static/logtalk.gif" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.81.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="declarative.html">Declarative object-oriented programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nomenclature</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#prolog-nomenclature">Prolog nomenclature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smalltalk-nomenclature">Smalltalk nomenclature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-nomenclature">C++ nomenclature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#java-nomenclature">Java nomenclature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-nomenclature">Python nomenclature</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing and running applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="printing.html">Printing messages and asking questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expansion.html">Term and goal expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2"><a class="reference internal" href="migration.html">Prolog integration and migration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ports/index.html">Ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributions/index.html">Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

    <p class="caption"><span class="caption-text">External Contents</span></p>
    <ul>
    <li class="toctree-l1"><a class="reference internal" href="../../docs/index.html">APIs</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://logtalk.org">Logtalk website</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a></li>
    </ul>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">User Manual</a></li>
      <li class="breadcrumb-item active">Nomenclature</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/nomenclature.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="nomenclature">
<span id="nomenclature-nomenclature"></span><h1>Nomenclature<a class="headerlink" href="#nomenclature" title="Link to this heading"></a></h1>
<p>Depending on your logic programming and object-oriented programming background
(or lack of it), you may find Logtalk nomenclature either familiar or at odds
with the terms used in other languages. In addition, being a superset of Prolog,
terms such as <em>predicate</em> and <em>method</em> are often used interchangeably. Logtalk
inherits most of its nomenclature from Prolog and Smalltalk.</p>
<p>Note that the same terms can have different meanings in different languages.
A good example is <em>class</em>. The support for meta-classes in e.g. Smalltalk
translates to a concept of class that is different in key aspects from the
concept of class in e.g. Java or C++. Other terms that can have different
meanings are <em>delegation</em> and <em>forwarding</em>. There are also cases where the
same concept is found under different names in some languages (e.g. <em>self</em>
and <em>this</em>) but that can also mean different concepts in Logtalk and other
languages. Always be aware of these differences and be cautious with assumptions
carried from other programming languages.</p>
<p>In this section, we map nomenclatures from Prolog and popular OOP languages
such as Smalltalk, C++, Java, and Python to the Logtalk nomenclature. The
Logtalk distribution includes several examples of how to implement common
concepts found in other languages, complementing the information in this
section. This Handbook also features a
<a class="reference internal" href="predicates.html#predicates-prolog"><span class="std std-ref">Prolog interoperability section</span></a> and
an extensive <a class="reference internal" href="../glossary.html#id1"><span class="std std-ref">glossary</span></a> providing the exact meaning of the
names commonly used in Logtalk programming.</p>
<section id="prolog-nomenclature">
<span id="nomenclature-prolog"></span><h2>Prolog nomenclature<a class="headerlink" href="#prolog-nomenclature" title="Link to this heading"></a></h2>
<p>Being a superset of Prolog, Logtalk inherits its nomenclature. But Logtalk
also aims to fix several Prolog shortcomings, thus introducing new concepts
and refining existing Prolog concepts. Logtalk object-oriented nature also
introduces names and concepts that are not common when discussing logic
programming semantics. We mention here the most relevant ones, notably
those where semantics or common practice differ. Further details can be
found elsewhere in this Handbook.</p>
<dl class="simple">
<dt><strong>arbitrary goals as directives</strong></dt><dd><p>Although not ISO Prolog Core standard compliant, several Prolog systems
accept using arbitrary goal as directives. This is not supported in
Logtalk source files. Always use an <a class="reference internal" href="../refman/directives/initialization_1.html#directives-initialization-1"><span class="std std-ref">initialization/1</span></a>
directive to wrap those goals. This ensure that any initialization goals,
which often have side-effects, are only called if the source file is
successfully compiled and loaded.</p>
</dd>
<dt><strong>calling a predicate</strong></dt><dd><p>Sending a <a class="reference internal" href="../glossary.html#term-message"><span class="xref std std-term">message</span></a> to an object is similar to <em>calling a goal</em> with
the difference that the actual predicate that is called is determined not
just by the message <em>term</em> but also by the object receiving the message and
possibly its ancestors. This is also different from calling a Prolog module
predicate: a message may result e.g. in calling a predicate
<a class="reference internal" href="../glossary.html#term-inheritance"><span class="xref std std-term">inherited</span></a> by the object but calling a module predicate
requires the predicate to exist in (or be reexported by) the module.</p>
</dd>
<dt><strong>closed world assumption semantics</strong></dt><dd><p>Logtalk provides clear closed world assumption semantics: messages or calls
for declared but undefined predicates fail. Messages or calls for unknown
(i.e. not declared) predicates throw an error. Crucially, this semantics
apply to both <em>static</em> and <em>dynamic</em> predicates. But in Prolog workarounds
are required to have a static predicate being known by the runtime without
it being also defined (so that calling it would fail instead of throwing a
predicate existence error).</p>
</dd>
<dt><strong>compiling and loading source files</strong></dt><dd><p>Logtalk provides its own built-in predicates for
<a class="reference internal" href="../refman/predicates/compiling_predicates.html#compiling-predicates"><span class="std std-ref">compiling and loading</span></a> source files. It also
provides convenient top-level interpreter <a class="reference internal" href="../refman/predicates/logtalk_load_1.html#predicates-logtalk-load-1"><span class="std std-ref">shorthands</span></a>
for these and other frequent operations. In general, the traditional
Prolog built-in predicates and top-level interpreter shorthands cannot
be used to load Logtalk source files.</p>
</dd>
<dt><strong>debugging</strong></dt><dd><p>In most (if not all) Prolog systems, debugging support is a built-in
feature made available using a set of built-in predicates like <code class="docutils literal notranslate"><span class="pre">trace/0</span></code>
and <code class="docutils literal notranslate"><span class="pre">spy/1</span></code>. But in Logtalk the <a class="reference internal" href="debugging.html#debugging-debugging"><span class="std std-ref">default debugger</span></a>
is a regular application, implemented using a public
<a class="reference internal" href="reflection.html#reflection-reflection"><span class="std std-ref">reflection API</span></a>. This means that the debugger
must be explicitly loaded (either automatically from a <a class="reference internal" href="../glossary.html#term-settings-file"><span class="xref std std-term">settings file</span></a>
at startup or from the top-level). It also means that the debugger can be
easily extended or replaced by an alternative application.</p>
</dd>
<dt><strong>directive operators</strong></dt><dd><p>Some Prolog systems declare directive names as operators (e.g. <code class="docutils literal notranslate"><span class="pre">dynamic</span></code>,
<code class="docutils literal notranslate"><span class="pre">multifile</span></code>, …). This is not required by the ISO Prolog Core standard.
It’s a practice that should be avoided as it makes code non-portable.</p>
</dd>
<dt><strong>encapsulation</strong></dt><dd><p>Logtalk enforces encapsulation of object predicates, generating a permission
error when a predicate is not within the scope of the caller. In contrast,
most Prolog module systems allow any module predicate to be called by using
explicit qualification, even if not exported. Worse, some Prolog systems
also allow defining clauses for a module predicate outside the module,
without declaring the predicate as multifile, by simply writing clauses
with explicit module-qualified heads.</p>
</dd>
<dt><strong>entity loading</strong></dt><dd><p>When using Prolog modules, <code class="docutils literal notranslate"><span class="pre">use_module/1-2</span></code> (or equivalent) directives
both load the module files and declare that the (implicitly or explicitly)
imported predicates can be used with implicit module qualification.
But Logtalk separates entity (object, protocol, category, or module)
predicate <em>usage</em> declarations (via <a class="reference internal" href="../refman/directives/uses_1.html#directives-uses-1"><span class="std std-ref">uses/1</span></a> and
<a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> or its own <a class="reference internal" href="../refman/directives/use_module_1.html#directives-use-module-1"><span class="std std-ref">use_module/1</span></a> and
<a class="reference internal" href="../refman/directives/use_module_2.html#directives-use-module-2"><span class="std std-ref">use_module/2</span></a> directives) from <em>loading</em> goals (using the
<a class="reference internal" href="../refman/predicates/logtalk_load_1.html#predicates-logtalk-load-1"><span class="std std-ref">logtalk_load/1</span></a> and <a class="reference internal" href="../refman/predicates/logtalk_load_2.html#predicates-logtalk-load-2"><span class="std std-ref">logtalk_load/2</span></a>
predicates), called using an explicit and disciplined approach from
<a class="reference internal" href="../glossary.html#term-loader-file"><span class="xref std std-term">loader files</span></a>.</p>
</dd>
<dt><strong>flags scope</strong></dt><dd><p>The <a class="reference internal" href="../refman/directives/set_logtalk_flag_2.html#directives-set-logtalk-flag-2"><span class="std std-ref">set_logtalk_flag/2</span></a> <strong>directive</strong> is always local
to the entity or source file that contains it. Only calls to the
<a class="reference internal" href="../refman/predicates/set_logtalk_flag_2.html#predicates-set-logtalk-flag-2"><span class="std std-ref">set_logtalk_flag/2</span></a> <strong>predicate</strong> set the global default
value for a flag. This distinction is lacking in Prolog (where directives
usually have a global scope) and Prolog modules (where some flags are
local to modules in some systems and global in other systems).</p>
</dd>
<dt><strong>meta-predicate call semantics</strong></dt><dd><p>Logtalk provides consistent <a class="reference internal" href="../glossary.html#term-meta-predicate"><span class="xref std std-term">meta-predicate</span></a> call semantics:
meta-arguments are always called in the meta-predicate
calling context. This contrasts with Prolog module meta-predicates
where the semantics of implicitly qualified calls is different from
explicitly qualified calls.</p>
</dd>
<dt><strong>operators scope</strong></dt><dd><p>Operators declared inside an entity (object, protocol, or category) are
local to the entity. But operators defined in a source file but outside
and entity are global for compatibility with existing Prolog code.</p>
</dd>
<dt><strong>predicates scope</strong></dt><dd><p>In plain Prolog, all predicates are visible. In a Prolog module, a
predicate can be exported or local. In Logtalk, a predicate can be
<a class="reference internal" href="../glossary.html#term-public-predicate"><span class="xref std std-term">public</span></a>, <a class="reference internal" href="../glossary.html#term-protected-predicate"><span class="xref std std-term">protected</span></a>,
<a class="reference internal" href="../glossary.html#term-private-predicate"><span class="xref std std-term">private</span></a>, or <a class="reference internal" href="../glossary.html#term-local-predicate"><span class="xref std std-term">local</span></a>.</p>
</dd>
<dt><strong>predicate declaration</strong></dt><dd><p>Logtalk provides a clear distinction between
<a class="reference internal" href="../glossary.html#term-predicate-declaration"><span class="xref std std-term">declaring</span></a> a predicate
and <a class="reference internal" href="../glossary.html#term-predicate-definition"><span class="xref std std-term">defining</span></a> a predicate. This is a
fundamental requirement for the concept of <a class="reference internal" href="../glossary.html#term-protocol"><span class="xref std std-term">protocol</span></a> (aka interface)
in Logtalk: we must be able to <em>declare</em> a predicate without necessarily
<em>defining</em> it. This clear distinction is missing in Prolog and Prolog
modules. Notably, it’s a compiler error for a module to try to export a
predicate that it does not define.</p>
</dd>
<dt><strong>predicate loading conflicts</strong></dt><dd><p>Logtalk does not use predicate import/export semantics. Thus, there are
never conflicts when loading entities (objects, protocols, or categories)
that declare the same public predicates. But attempting to load two Prolog
modules that export the same predicate results in a conflict, usually a
compilation error (this is specially problematic when the <code class="docutils literal notranslate"><span class="pre">use_module/1</span></code>
directive is used; e.g. adding a new exported predicate can break
applications that use the module but not the new predicate).</p>
</dd>
</dl>
</section>
<section id="smalltalk-nomenclature">
<span id="nomenclature-smalltalk"></span><h2>Smalltalk nomenclature<a class="headerlink" href="#smalltalk-nomenclature" title="Link to this heading"></a></h2>
<p>The Logtalk name originates from a combination of the Prolog and Smalltalk
names. Smalltalk had a significant influence in the design of Logtalk and
thus inherits some of its ideas and nomenclature. The following list relates
the most commonly used Smalltalk terms with their Logtalk counterparts.</p>
<dl class="simple">
<dt><strong>abstract class</strong></dt><dd><p>Similar to Smalltalk, an abstract class is just a class not meant to be
instantiated by not understanding a message to create instances.</p>
</dd>
<dt><strong>assignment statement</strong></dt><dd><p>Logtalk, as a superset of Prolog, uses <em>logic variables</em> and <em>unification</em>
and thus provides no equivalent to the Smalltalk assignment statement.</p>
</dd>
<dt><strong>block</strong></dt><dd><p>Logtalk supports lambda expressions and meta-predicates, which can be used
to provide similar functionality to Smalltalk blocks.</p>
</dd>
<dt><strong>class</strong></dt><dd><p>In Logtalk, <em>class</em> is a just a <em>role</em> that an object can play. This is
similar to Smalltalk where classes are also objects.</p>
</dd>
<dt><strong>class method</strong></dt><dd><p>Class methods in Logtalk are simply instance methods declared and defined
in the class metaclass.</p>
</dd>
<dt><strong>class variable</strong></dt><dd><p>Logtalk objects, which can play the roles of class and instance,
encapsulate predicates, not state. Class variables, which in Smalltalk are
really shared instance variables, can be emulated in a class by defining a
predicate locally instead of defining it in the class instances.</p>
</dd>
<dt><strong>inheritance</strong></dt><dd><p>While Smalltalk only supports single inheritance, Logtalk supports
single inheritance, multiple inheritance, and multiple instantiation.</p>
</dd>
<dt><strong>instance</strong></dt><dd><p>While in Smalltalk every object is an <em>instance</em> of same class, objects
in Logtalk can play different roles, including the role of a prototype
where the concepts of instance and class don’t apply. Moreover, instances
can be either created dynamically or defined statically.</p>
</dd>
<dt><strong>instance method</strong></dt><dd><p>Instance methods in Logtalk are simply predicates declared and defined
in a class and thus inherited by the class instances.</p>
</dd>
<dt><strong>instance variable</strong></dt><dd><p>Logtalk being a <em>declarative</em> language, objects encapsulate a set of
predicates instead of encapsulating <em>state</em>. But different objects may
provide different definitions of the same predicates. Mutable internal
state as in Smalltalk can be emulated by using dynamic predicates.</p>
</dd>
<dt><strong>message</strong></dt><dd><p>Similar to Smalltalk, a <em>message</em> is a request for an operation, which is
interpreted in Logtalk as a logic query, asking for the construction of a
proof that something is true.</p>
</dd>
<dt><strong>message selector</strong></dt><dd><p>Logtalk uses the predicate template (i.e. the predicate callable term with
all its arguments unbound) as message selector. The actual type of the
message arguments is not considered. Like Smalltalk, Logtalk uses <em>single
dispatch</em> on the message receiver.</p>
</dd>
<dt><strong>metaclass</strong></dt><dd><p>Metaclasses are optional in Logtalk (except for a root class) and can be
shared by several classes. When metaclasses are used, infinite regression
is simply avoided by making a class an instance of itself.</p>
</dd>
<dt><strong>method</strong></dt><dd><p>Same as in Smalltalk, a <em>method</em> is the actual code (i.e. predicate
definition) that is run to answer a message. Logtalk uses the words
<em>method</em> and <em>predicate</em> interchangeably.</p>
</dd>
<dt><strong>method categories</strong></dt><dd><p>There is no support in Logtalk for partitioning the methods of an object
in different categories. The Logtalk concept of <em>category</em> (a first-class
entity) was, however, partially inspired by Smalltalk method categories.</p>
</dd>
<dt><strong>object</strong></dt><dd><p>Unlike Smalltalk, where <em>everything</em> is an object, Logtalk language
constructs includes both <em>terms</em> (as in Prolog representing e.g. numbers
and structures) and three first-class entities: objects, protocols, and
categories.</p>
</dd>
<dt><em>pool variables*</em></dt><dd><p>Logtalk, as a superset of Prolog, uses <em>predicates</em> with no distinction
between <em>variables</em> and <em>methods</em>. Categories can be used to share a set
of predicate definitions between any number of objects.</p>
</dd>
<dt><strong>protocol</strong></dt><dd><p>In Smalltalk, an object <em>protocol</em> is the set of messages it understands.
The same concept applies in Logtalk. But Logtalk also supports protocols
as first-class entities where a protocol can be implemented by multiple
objects and an object can implement multiple protocols.</p>
</dd>
<dt><strong>self</strong></dt><dd><p>Logtalk uses the same definition of <em>self</em> found in Smalltalk: the object
that received the message being processed. Note, however, that <em>self</em> is
not a keyword in Logtalk but implicit in the <a class="reference internal" href="../refman/control/send_to_self_1.html#control-send-to-self-1"><span class="std std-ref">(::)/1</span></a>
message to <em>self</em> control construct.</p>
</dd>
<dt><strong>subclass</strong></dt><dd><p>Same definition in Logtalk.</p>
</dd>
<dt><strong>super</strong></dt><dd><p>As in Smalltalk, the idea of <em>super</em> is to allow calling an inherited
predicate (that is usually being redefined). Note, however, that <em>super</em> is
not a keyword in Logtalk, which provides instead a <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a>
<em>super</em> call control construct.</p>
</dd>
<dt><strong>superclass</strong></dt><dd><p>Same definition in Logtalk. But while in Smalltalk a class can only have a
single superclass, Logtalk support for multiple inheritance allows a class
to have multiple superclasses.</p>
</dd>
</dl>
</section>
<section id="c-nomenclature">
<span id="nomenclature-cpp"></span><h2>C++ nomenclature<a class="headerlink" href="#c-nomenclature" title="Link to this heading"></a></h2>
<p>There are several C++ glossaries available on the Internet. The list
that follows relates the most commonly used C++ terms with their Logtalk
equivalents.</p>
<dl class="simple">
<dt><strong>abstract class</strong></dt><dd><p>Logtalk uses an <em>operational</em> definition of abstract class: any class
that does not inherit a method for creating new instances can be
considered an abstract class. Moreover, Logtalk supports
<a class="reference internal" href="../glossary.html#term-protocol"><span class="xref std std-term">interfaces/protocols</span></a>, which are often a better way to provide the
functionality of C++ abstract classes.</p>
</dd>
<dt><strong>base class</strong></dt><dd><p>Logtalk uses the term <a class="reference internal" href="../glossary.html#term-superclass"><span class="xref std std-term">superclass</span></a> with the same meaning.</p>
</dd>
<dt><strong>data member</strong></dt><dd><p>Logtalk uses <a class="reference internal" href="../glossary.html#term-predicate"><span class="xref std std-term">predicates</span></a> for representing both behavior and data.</p>
</dd>
<dt><strong>constructor function</strong></dt><dd><p>There are no special methods for creating new objects in Logtalk.
Instead, Logtalk provides a built-in predicate, <a class="reference internal" href="../refman/predicates/create_object_4.html#predicates-create-object-4"><span class="std std-ref">create_object/4</span></a>,
which can be used as a building block to define more sophisticated
object creation predicates.</p>
</dd>
<dt><strong>derived class</strong></dt><dd><p>Logtalk uses the term <a class="reference internal" href="../glossary.html#term-subclass"><span class="xref std std-term">subclass</span></a> with the same meaning.</p>
</dd>
<dt><strong>destructor function</strong></dt><dd><p>There are no special methods for deleting new objects in Logtalk.
Instead, Logtalk provides a built-in predicate, <a class="reference internal" href="../refman/predicates/abolish_object_1.html#predicates-abolish-object-1"><span class="std std-ref">abolish_object/1</span></a>,
which is often used to define more sophisticated object deletion
predicates.</p>
</dd>
<dt><strong>friend function</strong></dt><dd><p>Not supported in Logtalk. Nevertheless, see the User Manual section on
<a class="reference internal" href="predicates.html#predicates-meta"><span class="std std-ref">meta-predicates</span></a>.</p>
</dd>
<dt><strong>instance</strong></dt><dd><p>In Logtalk, an instance can be either created dynamically at runtime
or defined statically in a source file in the same way as classes.</p>
</dd>
<dt><strong>member</strong></dt><dd><p>Logtalk uses the term <a class="reference internal" href="../glossary.html#term-predicate"><span class="xref std std-term">predicate</span></a>.</p>
</dd>
<dt><strong>member function</strong></dt><dd><p>Logtalk uses <a class="reference internal" href="../glossary.html#term-predicate"><span class="xref std std-term">predicates</span></a> for representing both behavior
and data.</p>
</dd>
<dt><strong>namespace</strong></dt><dd><p>Logtalk does not support multiple identifier namespaces. All Logtalk
entity identifiers share the same namespace (Logtalk entities are
objects, categories, and protocols).</p>
</dd>
<dt><strong>nested class</strong></dt><dd><p>Logtalk does not support nested classes.</p>
</dd>
<dt><strong>static member</strong></dt><dd><p>Logtalk does not support a <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword. But the equivalent to
static members can be declared in a class metaclass.</p>
</dd>
<dt><strong>template</strong></dt><dd><p>Logtalk supports <a class="reference internal" href="objects.html#objects-parametric"><span class="std std-ref">parametric objects</span></a>, which
allows you to get the similar functionality of templates at runtime.</p>
</dd>
<dt><strong>this</strong></dt><dd><p>Logtalk uses the built-in context method <a class="reference internal" href="../refman/methods/self_1.html#methods-self-1"><span class="std std-ref">self/1</span></a> for retrieving
the instance that received the message being processed. Logtalk also provides
a <a class="reference internal" href="../refman/methods/this_1.html#methods-this-1"><span class="std std-ref">this/1</span></a> method but for returning the class containing the
method being executed. Why the name clashes? Well, the notion of <a class="reference internal" href="../glossary.html#term-self"><span class="xref std std-term">self</span></a>
was inherited from Smalltalk, which predates C++.</p>
</dd>
<dt><strong>virtual member function</strong></dt><dd><p>There is no <code class="docutils literal notranslate"><span class="pre">virtual</span></code> keyword in Logtalk. Any inherited or imported
predicate can be redefined (either overridden or specialized).
Logtalk can use <a class="reference internal" href="../glossary.html#term-static-binding"><span class="xref std std-term">static binding</span></a> or <a class="reference internal" href="../glossary.html#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> for
locating both method declarations and method definitions. Moreover,
methods that are declared but not defined simply fail when called
(as per <a class="reference internal" href="../glossary.html#term-closed-world-assumption"><span class="xref std std-term">closed-world assumption</span></a>).</p>
</dd>
</dl>
</section>
<section id="java-nomenclature">
<span id="nomenclature-java"></span><h2>Java nomenclature<a class="headerlink" href="#java-nomenclature" title="Link to this heading"></a></h2>
<p>There are several Java glossaries available on the Internet. The list
that follows relates the most commonly used Java terms with their
Logtalk equivalents.</p>
<dl class="simple">
<dt><strong>abstract class</strong></dt><dd><p>Logtalk uses an <em>operational</em> definition of abstract class: any class
that does not inherit a method for creating new instances is an
abstract class. I.e. there is no <code class="docutils literal notranslate"><span class="pre">abstract</span></code> keyword in Logtalk.</p>
</dd>
<dt><strong>abstract method</strong></dt><dd><p>In Logtalk, you may simply declare a method (<a class="reference internal" href="../glossary.html#term-predicate"><span class="xref std std-term">predicate</span></a>) in a
class without defining it, leaving its definition to some descendant
subclass.</p>
</dd>
<dt><strong>assertion</strong></dt><dd><p>There is no <code class="docutils literal notranslate"><span class="pre">assertion</span></code> keyword in Logtalk. Assertions are
supported using Logtalk compilation hooks and developer tools.</p>
</dd>
<dt><strong>class</strong></dt><dd><p>Logtalk objects can play the role of classes, instances, or protocols
(depending on their relations with other objects).</p>
</dd>
<dt><strong>extends</strong></dt><dd><p>There is no <code class="docutils literal notranslate"><span class="pre">extends</span></code> keyword in Logtalk. Class inheritance is
indicated using <em>specialization relations</em>. Moreover, the <em>extends
relation</em> is used in Logtalk to indicate protocol, category, or
prototype extension.</p>
</dd>
<dt><strong>interface</strong></dt><dd><p>Logtalk uses the term <a class="reference internal" href="../glossary.html#term-protocol"><span class="xref std std-term">protocol</span></a> with similar meaning. But note
that Logtalk objects and categories declared as implementing a protocol
are not required to provide definitions for the declared predicates
(<a class="reference internal" href="../glossary.html#term-closed-world-assumption"><span class="xref std std-term">closed-world assumption</span></a>).</p>
</dd>
<dt><strong>callback method</strong></dt><dd><p>Logtalk supports <a class="reference internal" href="events.html#events-events"><span class="std std-ref">event-driven programming</span></a>,
the most common usage context of callback methods. Callback methods
can also be implemented using <a class="reference internal" href="../glossary.html#term-meta-predicate"><span class="xref std std-term">meta-predicates</span></a>.</p>
</dd>
<dt><strong>constructor</strong></dt><dd><p>There are no special methods for creating new objects in Logtalk.
Instead, Logtalk provides a built-in predicate, <a class="reference internal" href="../refman/predicates/create_object_4.html#predicates-create-object-4"><span class="std std-ref">create_object/4</span></a>,
which is often used to define more sophisticated object creation
predicates.</p>
</dd>
<dt><strong>final</strong></dt><dd><p>There is no <code class="docutils literal notranslate"><span class="pre">final</span></code> keyword in Logtalk. Predicates can always be
redeclared and redefined in subclasses (and instances!).</p>
</dd>
<dt><strong>inner class</strong></dt><dd><p>Inner classes are not supported in Logtalk.</p>
</dd>
<dt><strong>instance</strong></dt><dd><p>In Logtalk, an instance can be either created dynamically at runtime
or defined statically in a source file in the same way as classes.</p>
</dd>
<dt><strong>method</strong></dt><dd><p>Logtalk uses the term <a class="reference internal" href="../glossary.html#term-predicate"><span class="xref std std-term">predicate</span></a> interchangeably with the term
<em>method</em>.</p>
</dd>
<dt><strong>method call</strong></dt><dd><p>Logtalk usually uses the expression <em>message sending</em> for method
calls, true to its Smalltalk heritage.</p>
</dd>
<dt><strong>method signature</strong></dt><dd><p>Logtalk selects the method/predicate to execute in order to answer a
method call based only on the method name and number of arguments.
Logtalk (and Prolog) are not typed languages in the same sense as Java.</p>
</dd>
<dt><strong>package</strong></dt><dd><p>There is no concept of packages in Logtalk. All Logtalk entities
(objects, protocols, categories) share a single namespace. But
Logtalk does support a concept of <a class="reference internal" href="../glossary.html#term-library"><span class="xref std std-term">library</span></a> that allows
grouping of entities whose source files share a common path prefix.</p>
</dd>
<dt><strong>reflection</strong></dt><dd><p>Logtalk features a <em>white box</em> API supporting <em>structural</em> reflection
about <a class="reference internal" href="../refman/predicates/enumerating_entity_property_predicates.html#enumerating-entity-property-predicates"><span class="std std-ref">entity contents</span></a>,
a <em>black box</em> API supporting <em>behavioral</em> reflection about
<a class="reference internal" href="../refman/methods/reflection_methods.html#reflection-methods"><span class="std std-ref">object protocols</span></a>, and an
<a class="reference internal" href="../refman/predicates/event_handling_predicates.html#event-handling-predicates"><span class="std std-ref">events</span></a> API for reasoning about messages
exchanged at runtime.</p>
</dd>
<dt><strong>static</strong></dt><dd><p>There is no <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword in Logtalk. See the entries below on
<em>static method</em> and <em>static variable</em>.</p>
</dd>
<dt><strong>static method</strong></dt><dd><p>Static methods may be implemented in Logtalk by using a <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>
for the class and defining the static methods in the metaclass. I.e. static
methods are simply instance methods of the class metaclass.</p>
</dd>
<dt><strong>static variable</strong></dt><dd><p>Static variables are <em>shared instance variables</em> and can simply be both
declared and defined in a class. The built-in database methods can be
used to implement destructive updates if necessary by accessing and
updated a single clause of a dynamic predicate stored in the class.</p>
</dd>
<dt><strong>super</strong></dt><dd><p>Instead of a <code class="docutils literal notranslate"><span class="pre">super</span></code> keyword, Logtalk provides a super operator and
control construct, <a class="reference internal" href="../refman/control/call_super_1.html#control-call-super-1"><span class="std std-ref">(^^)/1</span></a>, for calling overridden
methods.</p>
</dd>
<dt><strong>synchronized</strong></dt><dd><p>Logtalk supports <a class="reference internal" href="threads.html#threads-threads"><span class="std std-ref">multi-threading programming</span></a> in
selected Prolog compilers, including a <a class="reference internal" href="../refman/directives/synchronized_1.html#directives-synchronized-1"><span class="std std-ref">synchronized/1</span></a>
predicate directive. Logtalk allows you to synchronize a predicate or a
set of predicates using per-predicate or per-predicate-set <em>mutexes</em>.</p>
</dd>
<dt><strong>this</strong></dt><dd><p>Logtalk uses the built-in context method <a class="reference internal" href="../refman/methods/self_1.html#methods-self-1"><span class="std std-ref">self/1</span></a> for retrieving
the instance that received the message being processed. Logtalk also provides
a <a class="reference internal" href="../refman/methods/this_1.html#methods-this-1"><span class="std std-ref">this/1</span></a> method but for returning the class containing the
method being executed. Why the name clashes? Well, the notion of <a class="reference internal" href="../glossary.html#term-self"><span class="xref std std-term">self</span></a>
was inherited from Smalltalk, which predates C++.</p>
</dd>
</dl>
</section>
<section id="python-nomenclature">
<span id="nomenclature-python"></span><h2>Python nomenclature<a class="headerlink" href="#python-nomenclature" title="Link to this heading"></a></h2>
<p>The list that follows relates the commonly used Python concepts with
their Logtalk equivalents.</p>
<dl class="simple">
<dt><strong>abstract class</strong></dt><dd><p>Logtalk uses a different definition of abstract class: a class that
does not inherit a method for creating new instances. Notably, the
presence of <em>abstract methods</em> (i.e. predicates that are declared
but not defined) does not make a class abstract.</p>
</dd>
<dt><strong>abstract method</strong></dt><dd><p>Logtalk uses the term <em>predicate</em> interchangeably with <em>method</em>. Predicates
can be declared without being also defined in an object (or category).</p>
</dd>
<dt><strong>class</strong></dt><dd><p>Logtalk objects can play the role of classes, instances, or protocols
(depending on their relations with other objects).</p>
</dd>
<dt><strong>dictionary</strong></dt><dd><p>There is no native, built-in associative data type. But the library
provides several implementations of a dictionary protocol.</p>
</dd>
<dt><strong>function</strong></dt><dd><p>The closest equivalent is a predicate defined in <code class="docutils literal notranslate"><span class="pre">user</span></code>, a pseudo-object
for predicates not defined in regular objects, and thus callable from
anywhere without requiring a scope directive.</p>
</dd>
<dt><strong>function object</strong></dt><dd><p>Predicates calls (goals) can be passed or returned from other predicates
and unified with other terms (e.g. variables).</p>
</dd>
<dt><strong>import path</strong></dt><dd><p>Logtalk uses the term <em>library</em> to refer to a directory of source files
and supports defining aliases (symbolic names) to library paths to abstract
the actual locations.</p>
</dd>
<dt><strong>lambda</strong></dt><dd><p>Logtalk natively supports lambda expressions.</p>
</dd>
<dt><strong>list</strong></dt><dd><p>Lists are compound terms with native syntax support.</p>
</dd>
<dt><strong>list comprehensions</strong></dt><dd><p>There is no native, built-in support for list comprehensions. But the
standard <code class="docutils literal notranslate"><span class="pre">findall/3</span></code> predicate can be used to construct a list by
calling a goal that generates the list elements.</p>
</dd>
<dt><strong>loader</strong></dt><dd><p>Logtalk uses the term <em>loader</em> to refer to source files whose main or
sole purpose is to load other source files.</p>
</dd>
<dt><strong>loop</strong></dt><dd><p>There are no native loop control constructs based on a counter. But the
library provides implementations of several loop predicates.</p>
</dd>
<dt><strong>metaclass</strong></dt><dd><p>Logtalk objects play the role of metaclasses when instantiated by
objects that play the role of classes.</p>
</dd>
<dt><strong>method</strong></dt><dd><p>Logtalk uses the terms <em>method</em> and <em>predicate</em> interchangeably.
Predicates can be defined in objects (and categories). The value
of <em>self</em> is implicit unlike in Python where it is the first parameter
of any method.</p>
</dd>
<dt><strong>method resolution order</strong></dt><dd><p>Logtalk uses a depth-first algorithm to lookup method (predicate)
declarations and definitions. It’s possible to use predicate <em>aliases</em>
to access predicate declarations and definitions other than the first
ones found by the lookup algorithm.</p>
</dd>
<dt><strong>object</strong></dt><dd><p>Objects are first-class entities that can play multiple roles, including
prototype, class, instance, and metaclass.</p>
</dd>
<dt><strong>package</strong></dt><dd><p>Logtalk uses the term <em>library</em> to refer to a directory of source files
defining objects, categories, and protocols.</p>
</dd>
<dt><strong>set</strong></dt><dd><p>There is no native, built-in set type. But the library provides set
implementations.</p>
</dd>
<dt><strong>string</strong></dt><dd><p>The interpretation of text between double-quotes depends on the
<code class="docutils literal notranslate"><span class="pre">double_quotes</span></code> flag. Depending on this flag, double-quoted text
can be interpreted as a list of characters, a list of character codes,
or an atom. Some backend Prolog compilers allow double-quoted text
to be interpreted as a string in the Python sense.</p>
</dd>
<dt><strong>tuple</strong></dt><dd><p>Compound terms can be used to represent tuples of any complexity.</p>
</dd>
<dt><strong>variable</strong></dt><dd><p>Logtalk works with <em>logical variables</em>, which are close to the
mathematical concept of variables and distinct from variables in
imperative or imperative-based OOP languages where they are
symbolic names for memory locations. Logical variables can be
<em>unified</em> with any term, including other variables.</p>
</dd>
<dt><strong>while loop</strong></dt><dd><p>The built-in <code class="docutils literal notranslate"><span class="pre">forall/2</span></code> predicate implements a <em>generate-and-test</em>
loop.</p>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Main features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="messages.html" class="btn btn-neutral float-right" title="Messages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1998-2024, Paulo Moura.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>