

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Prolog integration and migration &mdash; The Logtalk Handbook v3.39.0-b02 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reference Manual" href="../refman/index.html" />
    <link rel="prev" title="Installing Logtalk" href="installing.html" />
   
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Logtalk Handbook
          

          
            
            <img src="../_static/logtalk.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.39.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="declarative.html">Declarative object-oriented programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Main features</a></li>
<li class="toctree-l2"><a class="reference internal" href="nomenclature.html">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="messages.html">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="objects.html">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="categories.html">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="predicates.html">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="inheritance.html">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event-driven programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads.html">Multi-threading programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="errors.html">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="reflection.html">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="programming.html">Writing and running applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="printing.html">Printing messages and asking questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="expansion.html">Term and goal expansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="documenting.html">Documenting</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing.html">Installing Logtalk</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Prolog integration and migration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#source-files-with-both-prolog-code-and-logtalk-code">Source files with both Prolog code and Logtalk code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#encapsulating-plain-prolog-code-in-objects">Encapsulating plain Prolog code in objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#prolog-multifile-predicates">Prolog multifile predicates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#converting-prolog-modules-into-objects">Converting Prolog modules into objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-prolog-modules-as-objects">Compiling Prolog modules as objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#supported-module-directives">Supported module directives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unsupported-module-directives">Unsupported module directives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#modules-using-a-term-expansion-mechanism">Modules using a term-expansion mechanism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dealing-with-proprietary-prolog-directives-and-predicates">Dealing with proprietary Prolog directives and predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-prolog-module-predicates">Calling Prolog module predicates</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

            
          
	<p class="caption"><span class="caption-text">External Contents</span></p>
    <a href="../docs/index.html">APIs</a>
    <a href="https://logtalk.org">Logtalk website</a>
    <a href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">User Manual</a> &raquo;</li>
        
      <li>Prolog integration and migration</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/userman/migration.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="prolog-integration-and-migration">
<span id="migration-migration"></span><h1>Prolog integration and migration<a class="headerlink" href="#prolog-integration-and-migration" title="Permalink to this headline">¶</a></h1>
<p>An application may include plain Prolog files, Prolog modules, and
Logtalk objects. This is a perfectly valid way of developing a complex
application and, in some cases, it might be the most appropriated
solution. Modules may be used for legacy code or when a simple
encapsulation mechanism is adequate. Logtalk objects may be used when
more powerful encapsulation, abstraction, and reuse features are
required.</p>
<p>This section provides tips for integrating and migrating plain Prolog code
and Prolog module code to Logtalk. Step-by-step instructions are provided
for encapsulating plain Prolog code in objects, converting Prolog modules
into objects, and compiling and reusing Prolog modules as objects from
inside Logtalk. An interesting application of the techniques described
in this section is a solution for running a Prolog application which uses
modules on a Prolog compiler with no module system. The <code class="docutils literal notranslate"><span class="pre">wrapper</span></code> tool
can be used to help in migrating Prolog code.</p>
<div class="section" id="source-files-with-both-prolog-code-and-logtalk-code">
<span id="migration-hybrid"></span><h2>Source files with both Prolog code and Logtalk code<a class="headerlink" href="#source-files-with-both-prolog-code-and-logtalk-code" title="Permalink to this headline">¶</a></h2>
<p>Logtalk source files may contain plain Prolog code intermixed with
Logtalk code. The Logtalk compiler simply copies the plain Prolog code
as-is to the generated Prolog file. With Prolog modules, it is assumed
that the module code starts with a <code class="docutils literal notranslate"><span class="pre">module/1-2</span></code> directive and ends at
the end of the file. There is no module ending directive which would
allowed us to define more than one module per file. In fact, most if not
all Prolog module systems always define a single module per file. Some
of them mandate that the <code class="docutils literal notranslate"><span class="pre">module/1-2</span></code> directive be the first term on a
source file. As such, when the Logtalk compiler finds a <code class="docutils literal notranslate"><span class="pre">module/1-2</span></code>
directive, it assumes that all code that follows until the end of the
file belongs to the module.</p>
</div>
<div class="section" id="encapsulating-plain-prolog-code-in-objects">
<span id="migration-encapsulating"></span><h2>Encapsulating plain Prolog code in objects<a class="headerlink" href="#encapsulating-plain-prolog-code-in-objects" title="Permalink to this headline">¶</a></h2>
<p>Most applications consist of several plain Prolog source files, each one
defining a few top-level predicates and auxiliary predicates that are
not meant to be directly called by the user. Encapsulating plain Prolog
code in objects allows us to make clear the different roles of each
predicate, to hide implementation details, to prevent auxiliary
predicates from being called outside the object, and to take advantage
of Logtalk advanced code encapsulating and reusing features.</p>
<p>Encapsulating Prolog code using Logtalk objects is simple. First, for
each source file, add an opening object directive,
<a class="reference internal" href="../refman/directives/object_1_5.html#directives-object-1-5"><span class="std std-ref">object/1-5</span></a>, to the
beginning of the file and an ending object directive,
<a class="reference internal" href="../refman/directives/end_object_0.html#directives-end-object-0"><span class="std std-ref">end_object/0</span></a>, to end of
the file. Choose an object name that reflects the purpose of source file
code (this is a good opportunity for code refactoring if necessary).
Second, add <a class="reference internal" href="../refman/directives/public_1.html#directives-public-1"><span class="std std-ref">public/1</span></a> predicate directives for the
top-level predicates that are used directly by the user or called from
other source files. Third, we need to be able to call from inside an object
predicates defined in other source files/objects. The easiest solution,
which has the advantage of not requiring any changes to the predicate
definitions, is to use the <a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> directive. If your
Prolog compiler supports cross-referencing tools, you may use them to
help you make sure that all calls to predicates on other source
files/objects are listed in the <a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> directives.
The Logtalk <code class="docutils literal notranslate"><span class="pre">wrapper</span></code> tool can also help in detecting cross predicate
calls. Compiling the resulting objects with the Logtalk
<a class="reference internal" href="programming.html#flag-unknown-predicates"><span class="std std-ref">unknown_predicates</span></a> and
<a class="reference internal" href="programming.html#flag-portability"><span class="std std-ref">portability</span></a> flags set to <code class="docutils literal notranslate"><span class="pre">warning</span></code> will
help you identify calls to predicates defined on other converted source
files and possible portability issues.</p>
<div class="section" id="prolog-multifile-predicates">
<span id="migration-multifile"></span><h3>Prolog multifile predicates<a class="headerlink" href="#prolog-multifile-predicates" title="Permalink to this headline">¶</a></h3>
<p>Prolog <em>multifile</em> predicates are used when clauses for the same
predicate are spread among several source files. When encapsulating
plain Prolog code that uses multifile predicates, is often the case that
the clauses of the multifile predicates get spread between different
objects and categories but conversion is straight-forward. In the
Logtalk object (or category) holding the multifile predicate
<a class="reference internal" href="../glossary.html#term-primary-predicate-declaration"><span class="xref std std-term">primary declaration</span></a>, add a
<a class="reference internal" href="predicates.html#predicates-scope"><span class="std std-ref">predicate scope directive</span></a> and a
<a class="reference internal" href="predicates.html#predicates-multifile"><span class="std std-ref">multifile/1</span></a> directive. In
all other objects (or categories) defining clauses for the multifile
predicate, add a <code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> directive and predicate clauses using
the format:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">multifile</span>(<span class="nv">Entity</span><span class="o">::</span><span class="nv">Name</span><span class="o">/</span><span class="nv">Arity</span>).

<span class="nv">Entity</span><span class="o">::</span><span class="nv">Functor</span>(...) <span class="o">:-</span>
    ...
</pre></div>
</div>
<p>See the User Manual section on the <code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> predicate directive
for more information. An alternative solution is to simply keep the
clauses for the multifile predicates as plain Prolog code and define, if
necessary, a parametric object to encapsulate all predicates working
with the multifile predicate clauses. For example, assume the following
<code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> directive:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="c">% city(Name, District, Population, Neighbors)</span>
<span class="p">:- </span><span class="k">multifile</span>(city<span class="o">/</span><span class="m">4</span>).
</pre></div>
</div>
<p>We can define a parametric object with <code class="docutils literal notranslate"><span class="pre">city/4</span></code> as its identifier:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(city(<span class="nv">_Name</span>, <span class="nv">_District</span>, <span class="nv">_Population</span>, <span class="nv">_Neighbors</span>)).

    <span class="c">% predicates for working with city/4 clauses</span>

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>This solution is preferred when the multifile predicates are used to
represent large tables of data. See the section on <a class="reference internal" href="objects.html#objects-parametric"><span class="std std-ref">Parametric objects</span></a>
for more details.</p>
</div>
</div>
<div class="section" id="converting-prolog-modules-into-objects">
<span id="migration-converting"></span><h2>Converting Prolog modules into objects<a class="headerlink" href="#converting-prolog-modules-into-objects" title="Permalink to this headline">¶</a></h2>
<p>Converting Prolog modules into objects may allow an application to run
on a wider range of Prolog compilers, overcoming compatibility problems.
Some Prolog compilers don’t support a module system. Among those Prolog
compilers which support a module system, the lack of standardization
leads to several issues, specially with semantics, operators, and
meta-predicates. In addition, the conversion allows you to take
advantage of Logtalk more powerful abstraction and reuse mechanisms such
as separation between interface from implementation, inheritance,
parametric objects, and categories.</p>
<p>Converting a Prolog module into an object is easy as long as the
directives used in the module are supported by Logtalk (see below).
Assuming that this is the case, apply the following steps:</p>
<ol class="arabic simple">
<li><p>Convert the module <code class="docutils literal notranslate"><span class="pre">module/1</span></code> directive into an opening object
directive, <a class="reference internal" href="../refman/directives/object_1_5.html#directives-object-1-5"><span class="std std-ref">object/1-5</span></a>,
using the module name as the object name. For <code class="docutils literal notranslate"><span class="pre">module/2</span></code> directives
apply the same conversion and convert the list of exported predicates
into Logtalk <a class="reference internal" href="../refman/directives/public_1.html#directives-public-1"><span class="std std-ref">public/1</span></a>
predicate directives.</p></li>
<li><p>Add a closing object directive,
<a class="reference internal" href="../refman/directives/end_object_0.html#directives-end-object-0"><span class="std std-ref">end_object/0</span></a>, at the
end of the module code.</p></li>
<li><p>Convert any <code class="docutils literal notranslate"><span class="pre">export/1</span></code> directives into <code class="docutils literal notranslate"><span class="pre">public/1</span></code> predicate
directives.</p></li>
<li><p>Convert any <code class="docutils literal notranslate"><span class="pre">use_module/1</span></code> directives into <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code>
directives (see next section).</p></li>
<li><p>Convert any <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives referencing other modules
also being converted to objects into Logtalk
<a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> directives. If the
referenced modules are not being converted into objects, keep
the <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives but change the first argument to be
the module name.</p></li>
<li><p>Convert each <code class="docutils literal notranslate"><span class="pre">reexport/1</span></code> directive into a <a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a>
directive and <code class="docutils literal notranslate"><span class="pre">public/1</span></code> predicate directives (see next section).</p></li>
<li><p>Convert any <code class="docutils literal notranslate"><span class="pre">meta_predicate/1</span></code> directives into Logtalk
<a class="reference internal" href="../refman/directives/meta_predicate_1.html#directives-meta-predicate-1"><span class="std std-ref">meta_predicate/1</span></a>
directives by replacing the module meta-argument indicator, <code class="docutils literal notranslate"><span class="pre">:</span></code>,
with the Logtalk meta-argument indicator, <code class="docutils literal notranslate"><span class="pre">0</span></code>. Closures must be
represented using an integer denoting the number of additional
arguments that will be appended to construct a goal. Arguments which
are not meta-arguments are represented by the <code class="docutils literal notranslate"><span class="pre">*</span></code> character.</p></li>
<li><p>Convert any explicit qualified calls to module predicates to messages
by replacing the <code class="docutils literal notranslate"><span class="pre">:/2</span></code> operator with the
<a class="reference internal" href="../refman/control/send_to_object_2.html#control-send-to-object-2"><span class="std std-ref">::/2</span></a> message
sending operator when the referenced modules are also being
converted into objects. Calls in the pseudo-module <code class="docutils literal notranslate"><span class="pre">user</span></code> can
be encapsulated using the <a class="reference internal" href="../refman/control/external_call_1.html#control-external-call-1"><span class="std std-ref">{}/1</span></a> Logtalk
external call control construct. You can also use instead an
<a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> directive where the
first argument would be the atom <code class="docutils literal notranslate"><span class="pre">user</span></code> and the second argument a
list of all external predicates. This alternative has the advantage
of not requiring changes to the code making the predicate calls.</p></li>
<li><p>If your module uses the database built-in predicates to implement
module local mutable state using dynamic predicates, add both
<a class="reference internal" href="../refman/directives/private_1.html#directives-private-1"><span class="std std-ref">private/1</span></a> and
<a class="reference internal" href="../refman/directives/dynamic_1.html#directives-dynamic-1"><span class="std std-ref">dynamic/1</span></a> directives
for each dynamic predicate.</p></li>
<li><p>If your module declares or defines clauses for multifile module
predicates, replace the <code class="docutils literal notranslate"><span class="pre">:/2</span></code> functor by <code class="docutils literal notranslate"><span class="pre">::/2</span></code> in the
<code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> directives and in the clause heads for all modules
defining the multifile predicates that are also being converted into
objects; if that is not the case, just keep the <code class="docutils literal notranslate"><span class="pre">multifile/1</span></code>
directives and the clause heads as-is).</p></li>
<li><p>Compile the resulting objects with the Logtalk
<a class="reference internal" href="programming.html#flag-unknown-predicates"><span class="std std-ref">unknown_predicates</span></a>, and
<a class="reference internal" href="programming.html#flag-portability"><span class="std std-ref">portability</span></a> flags set to <code class="docutils literal notranslate"><span class="pre">warning</span></code>
to help you locate possible issues and calls to proprietary Prolog
built-in predicates and to predicates defined on other converted
modules. In order to improve code portability, check the Logtalk
library for possible alternatives to the use of proprietary Prolog
built-in predicates.</p></li>
</ol>
<p>Before converting your modules to objects, you may try to compile them
first as objects (using the <a class="reference internal" href="../refman/predicates/logtalk_compile_1.html#predicates-logtalk-compile-1"><span class="std std-ref">logtalk_compile/1</span></a>
Logtalk built-in predicates) to help identify any issues that must be
dealt with when doing the conversion to objects. Note that Logtalk
supports compiling Prolog files as Logtalk source code without requiring
changes to the file name extensions.</p>
</div>
<div class="section" id="compiling-prolog-modules-as-objects">
<span id="migration-compiling"></span><h2>Compiling Prolog modules as objects<a class="headerlink" href="#compiling-prolog-modules-as-objects" title="Permalink to this headline">¶</a></h2>
<p>A possible alternative to port Prolog code to Logtalk is to compile the Prolog
source files using the <code class="docutils literal notranslate"><span class="pre">logtalk_load/1-2</span></code> and <code class="docutils literal notranslate"><span class="pre">logtalk_compile/1-2</span></code>
predicates. The Logtalk compiler provides partial support for compiling Prolog
modules as Logtalk objects. This support may allow using modules from a backend
Prolog system in a different backend Prolog system although its main purpose is
to help in porting existing Prolog code to Logtalk in order to benefit from its
extended language features and its developer tools. Why partial support?
Although there is a ISO Prolog standard for modules, it is (rightfully)
ignored by most implementers and vendors (due to its flaws and deviation
from common practice). In addition, there is no de facto standard for module
systems, despite otherwise frequent bogus claims. Systems differences include
the set of implemented module directives, the directive semantics, the
handling of operators, the locality of flags, and on the integration of
term-expansion mechanisms (when provided). Follows a discussion of the
limitations of this approach that you should be aware.</p>
<div class="section" id="supported-module-directives">
<span id="migration-compatibility"></span><h3>Supported module directives<a class="headerlink" href="#supported-module-directives" title="Permalink to this headline">¶</a></h3>
<p>Currently, Logtalk supports the following module directives:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">module/1</span></code></dt><dd><p>The module name becomes the object name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module/2</span></code></dt><dd><p>The module name becomes the object name. The exported predicates
become public object predicates. The exported grammar rule
non-terminals become public grammar rule non-terminals. The exported
operators become public object operators but are not active elsewhere
when loading the code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_module/2</span></code></dt><dd><p>This directive is compiled as a Logtalk
<a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> directive in order
to ensure correct compilation of the module predicate clauses. The
first argument of this directive must be the module <strong>name</strong> (an
atom), not a module file specification (the adapter files attempt to
use the Prolog dialect level term-expansion mechanism to find the
module name from the module file specification). Note that the module
is not automatically loaded by Logtalk (as it would be when compiling
the directive using Prolog instead of Logtalk; the programmer may
also want the specified module to be compiled as an object). The
second argument must be a predicate indicator (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>), a
grammar rule non-terminal indicator (<code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>), a operator
declaration, or a list of predicate indicators, grammar rule
non-terminal indicators, and operator declarations. Predicate aliases
can be declared using the notation <code class="docutils literal notranslate"><span class="pre">Name/Arity</span> <span class="pre">as</span> <span class="pre">Alias/Arity</span></code> or,
in alternative, the notation <code class="docutils literal notranslate"><span class="pre">Name/Arity:Alias/Arity</span></code>. Similar for
non-terminal aliases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">export/1</span></code></dt><dd><p>Exported predicates are compiled as public object predicates. The
argument must be a predicate indicator (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>), a grammar
rule non-terminal indicator (<code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>), an operator
declaration, or a list of predicate indicators, grammar rule
non-terminal indicators, and operator declarations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reexport/2</span></code></dt><dd><p>Reexported predicates are compiled as public object predicates. The
first argument is the module name. The second argument must be a
predicate indicator (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>), a grammar rule non-terminal
indicator (<code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>), an operator declaration, or a list of
predicate indicators, grammar rule non-terminal indicators, and
operator declarations. Predicate aliases can be declared using the
notation <code class="docutils literal notranslate"><span class="pre">Name/Arity</span> <span class="pre">as</span> <span class="pre">Alias/Arity</span></code> or, in alternative, the notation
<code class="docutils literal notranslate"><span class="pre">Name/Arity:Alias/Arity</span></code>. Similar for non-terminal aliases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">meta_predicate/1</span></code></dt><dd><p>Module meta-predicates become object meta-predicates. Only predicate
arguments marked as goals or <a class="reference internal" href="../glossary.html#term-closure"><span class="xref std std-term">closures</span></a> (using an integer)
are interpreted as meta-arguments. In addition, Prolog module
meta-predicates and Logtalk meta-predicates don’t share the same
explicit-qualification calling semantics: in Logtalk, meta-arguments
are always called in the context of the <em>sender</em>.</p>
</dd>
</dl>
<p>A common issue when compiling modules as objects is the use of the atoms
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>, <code class="docutils literal notranslate"><span class="pre">discontiguous</span></code>, and <code class="docutils literal notranslate"><span class="pre">multifile</span></code> as operators in
directives. For better portability avoid this usage. For example, write:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">dynamic</span>([foo<span class="o">/</span><span class="m">1</span>, bar<span class="o">/</span><span class="m">2</span>]).
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>:- dynamic foo/1, bar/2.
</pre></div>
</div>
<p>Another common issue is missing <code class="docutils literal notranslate"><span class="pre">meta_predicate/1</span></code>, <code class="docutils literal notranslate"><span class="pre">dynamic/1</span></code>,
<code class="docutils literal notranslate"><span class="pre">discontiguous/1</span></code>, and <code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> predicate directives. The Logtalk
compiler supports detection of missing directives (by setting its
<a class="reference internal" href="programming.html#flag-missing-directives"><span class="std std-ref">missing_directives</span></a> flag to <code class="docutils literal notranslate"><span class="pre">warning</span></code>).</p>
<p>When compiling modules as objects, you probably don’t need event support
turned on. You may use the <a class="reference internal" href="programming.html#flag-events"><span class="std std-ref">events</span></a> compiler flag to
<code class="docutils literal notranslate"><span class="pre">deny</span></code> with the Logtalk compiling and loading built-in methods for a
small performance gain for the compiled code.</p>
</div>
<div class="section" id="unsupported-module-directives">
<span id="migration-unsupported-module-directives"></span><h3>Unsupported module directives<a class="headerlink" href="#unsupported-module-directives" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">reexport/1</span></code> and <code class="docutils literal notranslate"><span class="pre">use_module/1</span></code> directives are not directly
supported by the Logtalk compiler. But most Prolog adapter files provide
support for compiling these directives using Logtalk first stage of
its <a class="reference internal" href="expansion.html#expansion-expansion"><span class="std std-ref">term-expansion mechanism</span></a>. Nevertheless,
these directives can be converted, respectively, into a sequence of
<code class="docutils literal notranslate"><span class="pre">:-</span> <span class="pre">use_module/2</span></code> and <code class="docutils literal notranslate"><span class="pre">export/1</span></code> directives and <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code>
directives by finding which predicates exported by the
specified modules are reexported or imported into the module containing
the directive. For <code class="docutils literal notranslate"><span class="pre">use_module/1</span></code> directives, finding the names of the
imported predicates that are actually used is easy. First, comment out the
and compile the file (making sure that the
<a class="reference internal" href="programming.html#flag-unknown-predicates"><span class="std std-ref">unknown_predicates</span></a> compiler flag is set
to <code class="docutils literal notranslate"><span class="pre">warning</span></code>). Logtalk will print a warning with a list of predicates
that are called but never defined. Second, use these list to replace the
<code class="docutils literal notranslate"><span class="pre">use_module/1</span></code> directives by <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives. You should
then be able to compile the modified Prolog module as an object.</p>
</div>
<div class="section" id="modules-using-a-term-expansion-mechanism">
<span id="migration-module-expansions"></span><h3>Modules using a term-expansion mechanism<a class="headerlink" href="#modules-using-a-term-expansion-mechanism" title="Permalink to this headline">¶</a></h3>
<p>Although Logtalk supports
<a class="reference internal" href="expansion.html#expansion-expansion"><span class="std std-ref">term and goal expansion mechanisms</span></a>, the
semantics are different from similar mechanisms found in some Prolog
compilers. In particular, Logtalk does not support defining term and
goal expansions clauses in a source file for expanding the source file
itself. Logtalk forces a clean separation between expansions clauses and
the source files that will be subject to source-to-source expansions by
using <a class="reference internal" href="../glossary.html#term-hook-object"><span class="xref std std-term">hook objects</span></a>. But hook objects also provide
a working solution here when the expansion code is separated from the
code to be expanded. Logtalk supports using a module as a hook object
as long as its name doesn’t coincide with the name of an object and
that the module uses <code class="docutils literal notranslate"><span class="pre">term_expansion/2</span></code> and <code class="docutils literal notranslate"><span class="pre">goal_expansion/2</span></code>
predicates. Assuming that’s the case, before attempting to compile
the modules as objects, the default hook object is set to the module
containing the expansion code. For example, if the expansions stored
in a <code class="docutils literal notranslate"><span class="pre">system</span></code> module:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- set_logtalk_flag(hook, system).
...
</pre></div>
</div>
<p>This, however, may not be enough as some expansions may stored in more
than one module. A common example is to use a module named <code class="docutils literal notranslate"><span class="pre">prolog</span></code>.
It is also common to store the expansions in <code class="docutils literal notranslate"><span class="pre">user</span></code>. The Logtalk library
provides a solution for these scenarios. Using the <code class="docutils literal notranslate"><span class="pre">hook_flows</span></code> library
we can select multiple hook objects or hook modules. For example,
assuming expansions stored on both <code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">system</span></code> modules:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| ?- logtalk_load(hook_flows(loader)).
...

| ?- set_logtalk_flag(hook, hook_set([user, system])).
...
</pre></div>
</div>
<p>After these queries, we can try to compile the modules and look for
other porting or portability issues.</p>
</div>
</div>
<div class="section" id="dealing-with-proprietary-prolog-directives-and-predicates">
<span id="migration-proprietary"></span><h2>Dealing with proprietary Prolog directives and predicates<a class="headerlink" href="#dealing-with-proprietary-prolog-directives-and-predicates" title="Permalink to this headline">¶</a></h2>
<p>Most Prolog compilers define proprietary, non-standard, directives and
predicates that may be used in both plain code and module code.
Non-standard Prolog built-in predicates are usually not problematic, as
Logtalk is usually able to identify and compile them correctly (but see
the notes on built-in meta-predicates for possible caveats). However,
Logtalk will generate compilation errors on source files containing
proprietary directives unless you first specify how the directives
should be handled. Several actions are possible on a per-directive
basis: ignoring the directive (i.e. do not copy the directive, although
a goal can be proved as a consequence), rewriting and copy the directive
to the generated Prolog files, or rewriting and recompiling the
resulting directive. To specify these actions, the adapter files contain
clauses for the <code class="docutils literal notranslate"><span class="pre">'$lgt_prolog_term_expansion'/2</span></code> predicate. For
example, assume that a given Prolog compiler defines a <code class="docutils literal notranslate"><span class="pre">comment/2</span></code>
directive for predicates using the format:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span>comment(foo<span class="o">/</span><span class="m">2</span>, <span class="s">&quot;Brief description of the predicate&quot;</span>).
</pre></div>
</div>
<p>We can rewrite this predicate into a Logtalk <code class="docutils literal notranslate"><span class="pre">info/2</span></code> directive by
defining a suitable clause for the <code class="docutils literal notranslate"><span class="pre">'$lgt_prolog_term_expansion'/2</span></code>
predicate:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="s">&#39;$lgt_prolog_term_expansion&#39;</span>(
        comment(<span class="nv">F</span><span class="o">/</span><span class="nv">A</span>, <span class="nv">String</span>),
        info(<span class="nv">F</span><span class="o">/</span><span class="nv">A</span>, [comment <span class="k">is</span> <span class="nv">Atom</span>])
) <span class="o">:-</span>
    <span class="k">atom_codes</span>(<span class="nv">Atom</span>, <span class="nv">String</span>).
</pre></div>
</div>
<p>This Logtalk feature can be used to allow compilation of legacy Prolog
code without the need of changing the sources. When used, is advisable
to set the <a class="reference internal" href="programming.html#flag-portability"><span class="std std-ref">portability</span></a> compiler flag to
<code class="docutils literal notranslate"><span class="pre">warning</span></code> in order to more easily identify source files that are
likely non-portable across Prolog compilers.</p>
<p>A second example, where a proprietary Prolog directive is discarded
after triggering a side effect:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="s">&#39;$lgt_prolog_term_expansion&#39;</span>(
        load_foreign_files(<span class="nv">Files</span>,<span class="nv">Libs</span>,<span class="nv">InitRoutine</span>),
        []
) <span class="o">:-</span>
    load_foreign_files(<span class="nv">Files</span>,<span class="nv">Libs</span>,<span class="nv">InitRoutine</span>).
</pre></div>
</div>
<p>In this case, although the directive is not copied to the generated
Prolog file, the foreign library files are loaded as a side effect of
the Logtalk compiler calling the <code class="docutils literal notranslate"><span class="pre">'$lgt_prolog_term_expansion'/2</span></code> hook
predicate.</p>
</div>
<div class="section" id="calling-prolog-module-predicates">
<span id="migration-calling"></span><h2>Calling Prolog module predicates<a class="headerlink" href="#calling-prolog-module-predicates" title="Permalink to this headline">¶</a></h2>
<p>Prolog module predicates can be called from within objects or categories
by simply using explicit module qualification, i.e. by writing
<code class="docutils literal notranslate"><span class="pre">Module:Goal</span></code> or <code class="docutils literal notranslate"><span class="pre">Goal&#64;Module</span></code> (depending on the module system).
Logtalk also supports the use of <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives in object
and categories (with the restriction that the first argument of the
directive must be the actual module name and not the module file name or
the module file path). In this case, these directives are parsed in a
similar way to Logtalk <a class="reference internal" href="../refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a>
directives, with calls to the specified module predicates being
automatically translated to <code class="docutils literal notranslate"><span class="pre">Module:Goal</span></code> calls.</p>
<p>As a general rule, the Prolog modules should be loaded (e.g. in the
auxiliary Logtalk loader files) <em>before</em> compiling objects that make use
of module predicates. Moreover, the Logtalk compiler does not generate
code for the automatic loading of modules referenced in
<code class="docutils literal notranslate"><span class="pre">use_module/1-2</span></code> directives. This is a consequence of the lack of
standardization of these directives, whose first argument can be a
module name, a straight file name, or a file name using some kind of
library notation, depending on the <a class="reference internal" href="../glossary.html#term-backend-Prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>. Worse,
modules are sometimes defined in files with names different from the
module names requiring finding, opening, and reading the file in order
to find the actual module name.</p>
<p>Logtalk supports the declaration of <a class="reference internal" href="../glossary.html#term-predicate-alias"><span class="xref std std-term">predicate aliases</span></a>
in <code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives used within object and categories. For
example, the ECLiPSe IC Constraint Solvers define a <code class="docutils literal notranslate"><span class="pre">::/2</span></code> variable
domain operator that clashes with the Logtalk <code class="docutils literal notranslate"><span class="pre">::/2</span></code> message sending
operator. We can solve the conflict by writing:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">use_module</span>(ic, [(<span class="o">::</span>)<span class="o">/</span><span class="m">2</span> <span class="o">as</span> ins<span class="o">/</span><span class="m">2</span>]).
</pre></div>
</div>
<p>With this directive, calls to the <code class="docutils literal notranslate"><span class="pre">ins/2</span></code> predicate alias will be
automatically compiled by Logtalk to calls to the <code class="docutils literal notranslate"><span class="pre">::/2</span></code> predicate in
the <code class="docutils literal notranslate"><span class="pre">ic</span></code> module.</p>
<p>Logtalk allows you to send a message to a module in order to call one of
its predicates. This is usually not advised as it implies a performance
penalty when compared to just using the <code class="docutils literal notranslate"><span class="pre">Module:Call</span></code> notation.
Moreover, this works only if there is no object with the same name as
the module you are targeting. This feature is necessary, however, in
order to properly support compilation of modules containing
<code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives as objects. If the modules specified in the
<code class="docutils literal notranslate"><span class="pre">use_module/2</span></code> directives are not compiled as objects but are instead
loaded as-is by Prolog, the exported predicates would need to be called
using the <code class="docutils literal notranslate"><span class="pre">Module:Call</span></code> notation but the converted module will be
calling them through message sending. Thus, this feature ensures that,
on a module compiled as an object, any predicate calling other module
predicates will work as expected either these other modules are loaded
as-is or also compiled as objects.</p>
<p>For more details, see the <a class="reference internal" href="predicates.html#predicates-prolog"><span class="std std-ref">Calling Prolog predicates</span></a> section.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../refman/index.html" class="btn btn-neutral float-right" title="Reference Manual" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installing.html" class="btn btn-neutral float-left" title="Installing Logtalk" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1998-2020, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>