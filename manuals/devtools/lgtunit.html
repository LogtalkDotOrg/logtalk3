

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>lgtunit &mdash; The Logtalk Handbook v3.39.0-b02 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="linter" href="linter.html" />
    <link rel="prev" title="lgtdoc" href="lgtdoc.html" />
   
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Logtalk Handbook
          

          
            
            <img src="../_static/logtalk.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.39.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userman/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="asdf.html"><code class="docutils literal notranslate"><span class="pre">asdf</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="assertions.html"><code class="docutils literal notranslate"><span class="pre">assertions</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="code_metrics.html"><code class="docutils literal notranslate"><span class="pre">code_metrics</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="dead_code_scanner.html"><code class="docutils literal notranslate"><span class="pre">dead_code_scanner</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="debug_messages.html"><code class="docutils literal notranslate"><span class="pre">debug_messages</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="debugger.html"><code class="docutils literal notranslate"><span class="pre">debugger</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="diagrams.html"><code class="docutils literal notranslate"><span class="pre">diagrams</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="doclet.html"><code class="docutils literal notranslate"><span class="pre">doclet</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="help.html"><code class="docutils literal notranslate"><span class="pre">help</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="lgtdoc.html"><code class="docutils literal notranslate"><span class="pre">lgtdoc</span></code></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">lgtunit</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-files">Main files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-documentation">API documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading">Loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-and-loading-tests">Writing and loading tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-unit-tests">Running unit tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parametric-test-objects">Parametric test objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-dialects">Test dialects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-defined-test-dialects">User-defined test dialects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quickcheck">QuickCheck</a></li>
<li class="toctree-l3"><a class="reference internal" href="#skipping-tests">Skipping tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-test-goal-results">Checking test goal results</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-local-predicates">Testing local predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-non-deterministic-predicates">Testing non-deterministic predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-generators">Testing generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-input-output-predicates">Testing input/output predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#suppressing-tested-predicates-output">Suppressing tested predicates output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tests-with-timeout-limits">Tests with timeout limits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup-and-cleanup-goals">Setup and cleanup goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-annotations">Test annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-failed-tests">Debugging failed tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-coverage">Code coverage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automating-running-tests">Automating running tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#utility-predicates">Utility predicates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exporting-test-results-in-xunit-xml-format">Exporting test results in xUnit XML format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exporting-test-results-in-the-tap-output-format">Exporting test results in the TAP output format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exporting-code-coverage-results-in-xml-format">Exporting code coverage results in XML format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minimizing-test-results-output">Minimizing test results output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#known-issues">Known issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-notes">Other notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="linter.html"><code class="docutils literal notranslate"><span class="pre">linter</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="make.html"><code class="docutils literal notranslate"><span class="pre">make</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="ports_profiler.html"><code class="docutils literal notranslate"><span class="pre">ports_profiler</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="profiler.html"><code class="docutils literal notranslate"><span class="pre">profiler</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutor.html"><code class="docutils literal notranslate"><span class="pre">tutor</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="wrapper.html"><code class="docutils literal notranslate"><span class="pre">wrapper</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

            
          
	<p class="caption"><span class="caption-text">External Contents</span></p>
    <a href="../docs/index.html">APIs</a>
    <a href="https://logtalk.org">Logtalk website</a>
    <a href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Developer Tools</a> &raquo;</li>
        
      <li><code class="docutils literal notranslate"><span class="pre">lgtunit</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/devtools/lgtunit.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="lgtunit">
<h1><code class="docutils literal notranslate"><span class="pre">lgtunit</span></code><a class="headerlink" href="#lgtunit" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> tool provides testing support for Logtalk. It can also
be used for testing plain Prolog code and Prolog module code.</p>
<p>This tool is inspired by the xUnit frameworks architecture and by the
works of Joachim Schimpf (ECLiPSe library <code class="docutils literal notranslate"><span class="pre">test_util</span></code>) and Jan
Wielemaker (SWI-Prolog <code class="docutils literal notranslate"><span class="pre">plunit</span></code> package).</p>
<p>Tests are defined in objects, which represent a <em>test set</em> or <em>test
suite</em>. In simple cases, we usually define a single object containing
the tests. But it is also possible to use parametric test objects or
multiple objects defining parametrizable tests or test subsets for
testing more complex units and facilitate tests maintenance. Parametric
test objects are specially useful to test multiple implementations of
the same protocol using a single set of tests by passing the
implementation object as a parameter value.</p>
<div class="section" id="main-files">
<h2>Main files<a class="headerlink" href="#main-files" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">lgtunit.lgt</span></code> source file implements a framework for defining and
running unit tests in Logtalk. The <code class="docutils literal notranslate"><span class="pre">lgtunit_messages.lgt</span></code> source file
defines the default translations for the messages printed when running
unit tests. These messages can be intercepted to customize output, e.g.
to make it less verbose, or for integration with e.g. GUI IDEs and
continuous integration servers.</p>
<p>Other files part of this tool provide support for alternative output
formats of test results and are discussed below.</p>
</div>
<div class="section" id="api-documentation">
<h2>API documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h2>
<p>This tool API documentation is available at:</p>
<p><a class="reference external" href="../../docs/library_index.html#lgtunit">../../docs/library_index.html#lgtunit</a></p>
</div>
<div class="section" id="loading">
<h2>Loading<a class="headerlink" href="#loading" title="Permalink to this headline">¶</a></h2>
<p>This tool can be loaded using the query:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(lgtunit(loader)).
</pre></div>
</div>
</div>
<div class="section" id="writing-and-loading-tests">
<h2>Writing and loading tests<a class="headerlink" href="#writing-and-loading-tests" title="Permalink to this headline">¶</a></h2>
<p>In order to write your own unit tests, define objects extending the
<code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> object. You may start by copying the <code class="docutils literal notranslate"><span class="pre">tests-sample.lgt</span></code>
file (at the root of the Logtalk distribution) to a <code class="docutils literal notranslate"><span class="pre">tests.lgt</span></code> file
in your project directory and edit it to add your tests:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(tests,
    <span class="k">extends</span>(lgtunit)).

    <span class="c">% test definitions</span>
    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>The section on <a class="reference external" href="#test-dialects">test dialects</a> below describes in
detail how to write tests. See the <code class="docutils literal notranslate"><span class="pre">tests</span></code> top directory for examples
of actual unit tests. Other sources of examples are the <code class="docutils literal notranslate"><span class="pre">library</span></code> and
<code class="docutils literal notranslate"><span class="pre">examples</span></code> directories.</p>
<p>The tests must be term-expanded by the <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> object by compiling
the source files defining the test objects using the option
<code class="docutils literal notranslate"><span class="pre">hook(lgtunit)</span></code>. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(tests, [hook(lgtunit)]).
</pre></div>
</div>
<p>As the term-expansion mechanism applies to all the contents of a source
file, the source files defining the test objects should preferably not
contain entities other than the test objects. Additional code necessary
for the tests should go to separate files.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tester-sample.lgt</span></code> file (at the root of the Logtalk distribution)
exemplifies how to compile and load <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> tool, the source code
under testing, the unit tests, and for automatically run all the tests
after loading. You may copy this file to a <code class="docutils literal notranslate"><span class="pre">tester.lgt</span></code> file in your
project directory and edit it to load your project and tests files.</p>
<p>Debugged test sets should preferably be compiled in optimal mode,
specially when containing deterministic tests and when using the utility
benchmarking predicates.</p>
</div>
<div class="section" id="running-unit-tests">
<h2>Running unit tests<a class="headerlink" href="#running-unit-tests" title="Permalink to this headline">¶</a></h2>
<p>Assuming that your test object is named <code class="docutils literal notranslate"><span class="pre">tests</span></code>, after compiling and
loading its source file, you can run the tests by typing:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> tests<span class="o">::</span>run.
</pre></div>
</div>
<p>Usually, this goal is called automatically from an <code class="docutils literal notranslate"><span class="pre">initialization/1</span></code>
directive in a <code class="docutils literal notranslate"><span class="pre">tester.lgt</span></code> loader file. You can also run a single
test (or a list of tests) using the <code class="docutils literal notranslate"><span class="pre">run/1</span></code> predicate:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> tests<span class="o">::</span>run(test_identifier).
</pre></div>
</div>
<p>When testing complex <em>units</em>, it is often desirable to split the tests
between several test objects or using parametric test objects to be able
to run the same tests using different parameters (e.g. different data
sets). In this case, you can run all test subsets using the goal:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>run_test_sets([...])
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">run_test_sets/1</span></code> predicate argument is a list of test
object identifiers. This predicate makes possible to get a single code
coverage report that takes into account all the tests.</p>
<p>It’s also possible to automatically run loaded tests when using the
<code class="docutils literal notranslate"><span class="pre">make</span></code> tool by calling the goal that runs the tests from a definition
of the hook predicate <code class="docutils literal notranslate"><span class="pre">logtalk_make_target_action/1</span></code>. For example, by
adding to the tests <code class="docutils literal notranslate"><span class="pre">tester.lgt</span></code> driver file the following code:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="c">% integrate the tests with logtalk_make/1</span>
<span class="p">:- </span><span class="k">multifile</span>(logtalk_make_target_action<span class="o">/</span><span class="m">1</span>).
<span class="p">:- </span><span class="k">dynamic</span>(logtalk_make_target_action<span class="o">/</span><span class="m">1</span>).

<span class="k">logtalk_make_target_action</span>(check) <span class="o">:-</span>
    tests<span class="o">::</span>run.
</pre></div>
</div>
<p>Alternatively, you can define the predicate <code class="docutils literal notranslate"><span class="pre">make/1</span></code> inside the test
set object. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>make(check).
</pre></div>
</div>
<p>This clause will cause all tests to be run when calling the
<code class="docutils literal notranslate"><span class="pre">logtalk_make/1</span></code> predicate with the target <code class="docutils literal notranslate"><span class="pre">check</span></code> (or its top-level
shortcut, <code class="docutils literal notranslate"><span class="pre">{?}</span></code>). The other possible target is <code class="docutils literal notranslate"><span class="pre">all</span></code> (with top-level
shortcut <code class="docutils literal notranslate"><span class="pre">{*}</span></code>).</p>
<p>Note that you can have multiple test driver files. For example, one
driver file that runs the tests collecting code coverage data and a
quicker driver file that skips code coverage and compiles the code to be
tested in optimized mode.</p>
</div>
<div class="section" id="parametric-test-objects">
<h2>Parametric test objects<a class="headerlink" href="#parametric-test-objects" title="Permalink to this headline">¶</a></h2>
<p>Parameterized unit tests can be easily defined by using parametric test
objects. A typical example is testing multiple implementations of the
same protocol. In this case, we can use a parameter to pass the specific
implementation being tested. For example, assume that we want to run the
same set of tests for the library <code class="docutils literal notranslate"><span class="pre">randomp</span></code> protocol. We can write:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(tests(<span class="nv">_RandomObject_</span>),
    <span class="k">extends</span>(lgtunit)).

<span class="p">    :- </span><span class="k">uses</span>(<span class="nv">_RandomObject_</span>, [
        random<span class="o">/</span><span class="m">1</span>, between<span class="o">/</span><span class="m">3</span>, member<span class="o">/</span><span class="m">2</span>,
        ...
    ]).

    test(between_3_in_interval) <span class="o">:-</span>
        between(<span class="m">1</span>, <span class="m">10</span>, <span class="nv">Random</span>),
        <span class="m">1</span> <span class="o">=&lt;</span> <span class="nv">Random</span>, <span class="nv">Random</span> <span class="o">=&lt;</span> <span class="m">10.</span>

    ...

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>We can then test a specific implementation by instantiating the
parameter. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> tests(fast_random)<span class="o">::</span>run.
</pre></div>
</div>
<p>Or use the <code class="docutils literal notranslate"><span class="pre">lgtunit::run_test_sets/1</span></code> predicate to test all the
implementations:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>run_test_sets([
        tests(backend_random),
        tests(fast_random),
        tests(random)
    ]).
</pre></div>
</div>
</div>
<div class="section" id="test-dialects">
<h2>Test dialects<a class="headerlink" href="#test-dialects" title="Permalink to this headline">¶</a></h2>
<p>Multiple test <em>dialects</em> are supported by default. See the next section
on how to define your own test dialects. In all dialects, a callable
term, usually an atom, is used to uniquely identify a test. This
simplifies reporting failed tests and running tests selectively. An
error message is printed if duplicated test identifiers are found. These
errors must be corrected otherwise the reported test results can be
misleading. Ideally, tests should have descriptive names that clearly
state the purpose of the test and what is being tested.</p>
<p>Unit tests can be written using any of the following predefined
dialects:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(<span class="nv">Test</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
</pre></div>
</div>
<p>This is the most simple dialect, allowing the specification of tests
that are expected to succeed. The argument of the <code class="docutils literal notranslate"><span class="pre">test/1</span></code> predicate
is the test identifier, which must be unique. A more versatile dialect
is:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>succeeds(<span class="nv">Test</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
deterministic(<span class="nv">Test</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
fails(<span class="nv">Test</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
throws(<span class="nv">Test</span>, <span class="nv">Ball</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
throws(<span class="nv">Test</span>, <span class="nv">Balls</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
</pre></div>
</div>
<p>This is a straightforward dialect. For <code class="docutils literal notranslate"><span class="pre">succeeds/1</span></code> tests, <code class="docutils literal notranslate"><span class="pre">Goal</span></code> is
expected to succeed. For <code class="docutils literal notranslate"><span class="pre">deterministic/1</span></code> tests, <code class="docutils literal notranslate"><span class="pre">Goal</span></code> is expected
to succeed once without leaving a choice-point. For <code class="docutils literal notranslate"><span class="pre">fails/1</span></code> tests,
<code class="docutils literal notranslate"><span class="pre">Goal</span></code> is expected to fail. For <code class="docutils literal notranslate"><span class="pre">throws/2</span></code> tests, <code class="docutils literal notranslate"><span class="pre">Goal</span></code> is
expected to throw the exception term <code class="docutils literal notranslate"><span class="pre">Ball</span></code> or one of the exception
terms in the list <code class="docutils literal notranslate"><span class="pre">Balls</span></code>. The specified exception must subsume the
generated exception for the test to succeed.</p>
<p>An alternative test dialect that can be used with more expressive power
is:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(<span class="nv">Test</span>, <span class="nv">Outcome</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
</pre></div>
</div>
<p>The possible values of the outcome argument are:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">true</span></code></div>
<div class="line">the test is expected to succeed</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">true(Assertion)</span></code></div>
<div class="line">the test is expected to succeed and satisfy the <code class="docutils literal notranslate"><span class="pre">Assertion</span></code> goal</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">deterministic</span></code></div>
<div class="line">the test is expected to succeed once without leaving a choice-point</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">deterministic(Assertion)</span></code></div>
<div class="line">the test is expected to succeed once without leaving a choice-point
and satisfy the <code class="docutils literal notranslate"><span class="pre">Assertion</span></code> goal</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fail</span></code></div>
<div class="line">the test is expected to fail</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">false</span></code></div>
<div class="line">the test is expected to fail</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">error(Error)</span></code></div>
<div class="line">the test is expected to throw the exception term
<code class="docutils literal notranslate"><span class="pre">error(Error,</span> <span class="pre">_)</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">errors(Errors)</span></code></div>
<div class="line">the test is expected to throw an exception term <code class="docutils literal notranslate"><span class="pre">error(Error,</span> <span class="pre">_)</span></code>
where <code class="docutils literal notranslate"><span class="pre">Error</span></code> is an element of the list <code class="docutils literal notranslate"><span class="pre">Errors</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">ball(Ball)</span></code></div>
<div class="line">the test is expected to throw the exception term <code class="docutils literal notranslate"><span class="pre">Ball</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">balls(Balls)</span></code></div>
<div class="line">the test is expected to throw an exception term <code class="docutils literal notranslate"><span class="pre">Ball</span></code> where
<code class="docutils literal notranslate"><span class="pre">Ball</span></code> is an element of the list <code class="docutils literal notranslate"><span class="pre">Balls</span></code></div>
</div>
</li>
</ul>
<p>In the case of the <code class="docutils literal notranslate"><span class="pre">true(Assertion)</span></code> and <code class="docutils literal notranslate"><span class="pre">deterministic(Assertion)</span></code>
outcomes, a message that includes the assertion goal is printed for
assertion failures and errors to help to debug failed unit tests. Note
that this message is only printed when the test goal succeeds as its
failure will prevent the assertion goal from being called. This allows
distinguishing between test goal failure and assertion failure.</p>
<p>Some tests may require individual condition, setup, or cleanup goals. In
this case, the following alternative test dialect can be used:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(<span class="nv">Test</span>, <span class="nv">Outcome</span>, <span class="nv">Options</span>) <span class="o">:-</span> <span class="nv">Goal</span>.
</pre></div>
</div>
<p>The currently supported options are (non-recognized options are
ignored):</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">condition(Goal)</span></code></div>
<div class="line">condition for deciding if the test should be run or skipped
(default goal is <code class="docutils literal notranslate"><span class="pre">true</span></code>)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">setup(Goal)</span></code></div>
<div class="line">setup goal for the test (default goal is <code class="docutils literal notranslate"><span class="pre">true</span></code>)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">cleanup(Goal)</span></code></div>
<div class="line">cleanup goal for the test (default goal is <code class="docutils literal notranslate"><span class="pre">true</span></code>)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">note(Term)</span></code></div>
<div class="line">annotation to print (between parenthesis by default) after the test
result (default is <code class="docutils literal notranslate"><span class="pre">''</span></code>); the annotation term can share variables
with the test goal, which can be used to pass additional
information about the test result</div>
</div>
</li>
</ul>
<p>Also supported is QuickCheck testing where random tests are
automatically generated and run given a predicate mode template with
type information for each argument (see the section below for more
details):</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>quick_check(<span class="nv">Test</span>, <span class="nv">Template</span>, <span class="nv">Options</span>).
quick_check(<span class="nv">Test</span>, <span class="nv">Template</span>).
</pre></div>
</div>
<p>The valid options are the same as for the <code class="docutils literal notranslate"><span class="pre">test/3</span></code> dialect plus all
the supported QuickCheck specific options (see the QuickCheck section
below for details).</p>
<p>For examples of how to write unit tests, check the <code class="docutils literal notranslate"><span class="pre">tests</span></code> folder or
the <code class="docutils literal notranslate"><span class="pre">testing</span></code> example in the <code class="docutils literal notranslate"><span class="pre">examples</span></code> folder in the Logtalk
distribution. Most of the provided examples also include unit tests,
some of them with code coverage.</p>
</div>
<div class="section" id="user-defined-test-dialects">
<h2>User-defined test dialects<a class="headerlink" href="#user-defined-test-dialects" title="Permalink to this headline">¶</a></h2>
<p>Additional test dialects can be easily defined by extending the
<code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> object and by term-expanding the new dialect into one of the
default dialects. As an example, suppose that you want a dialect where
you can simply write a file with clauses using the format:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test_identifier <span class="o">:-</span>
    test_goal.
</pre></div>
</div>
<p>First, we define an expansion for this file into a test object:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(simple_dialect,
    <span class="k">implements</span>(expanding)).

    <span class="k">term_expansion</span>(begin_of_file, [(<span class="o">:-</span> object(tests,extends(lgtunit)))]).
    <span class="k">term_expansion</span>((<span class="nv">Head</span> <span class="o">:-</span> <span class="nv">Body</span>), [test(<span class="nv">Head</span>) <span class="o">:-</span> <span class="nv">Body</span>]).
    <span class="k">term_expansion</span>(end_of_file, [(<span class="o">:-</span> end_object)]).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>Then we can use this hook object to expand and run tests written in this
dialect by using a <code class="docutils literal notranslate"><span class="pre">tester.lgt</span></code> driver file with contents such as:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">initialization</span>((
    <span class="k">set_logtalk_flag</span>(report, warnings),
    <span class="k">logtalk_load</span>(lgtunit(loader)),
    <span class="k">logtalk_load</span>(library(hook_flows_loader)),
    <span class="k">logtalk_load</span>(simple_dialect),
    <span class="k">logtalk_load</span>(tests, [hook(hook_pipeline([simple_dialect,lgtunit]))]),
    tests<span class="o">::</span>run
)).
</pre></div>
</div>
<p>The hook pipeline first applies our <code class="docutils literal notranslate"><span class="pre">simple_dialect</span></code> expansion
followed by the default <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> expansion. This solution allows
other hook objects (e.g. required by the code being tested) to also be
used by updating the pipeline.</p>
</div>
<div class="section" id="quickcheck">
<h2>QuickCheck<a class="headerlink" href="#quickcheck" title="Permalink to this headline">¶</a></h2>
<p>QuickCheck was originally developed for Haskell. Implementations for
several other programming languages soon followed. QuickCheck provides
support for <em>property-based testing</em>. The idea is to express properties
that predicates must comply with and automatically generate tests for
those properties. The <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> tool supports both <code class="docutils literal notranslate"><span class="pre">quick_check/2-3</span></code>
test dialects, as described above, and <code class="docutils literal notranslate"><span class="pre">quick_check/1-3</span></code> public
predicates for interactive use:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>quick_check(<span class="nv">Template</span>, <span class="nv">Result</span>, <span class="nv">Options</span>).
quick_check(<span class="nv">Template</span>, <span class="nv">Options</span>).
quick_check(<span class="nv">Template</span>).
</pre></div>
</div>
<p>The following options are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n/1</span></code>: number of random tests that will be generated and run
(default is 100).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s/1</span></code>: maximum number of shrink operations when a counter-example
is found (default is 64).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ec/1</span></code>: boolean option deciding if type edge cases are tested
before generating random tests (default is <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rs/1</span></code>: starting seed to be used when generating the random tests
(no default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pc/1</span></code>: pre-condition closure for generated tests (extended with
the test arguments; no default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l/1</span></code>: label closure for classifying the generated tests (extended
with the test arguments plus the labels argument; no default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v/1</span></code>: boolean option for verbose reporting of generated random
tests (default is <code class="docutils literal notranslate"><span class="pre">false</span></code>).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">quick_check/1</span></code> uses the default option values. When using the
<code class="docutils literal notranslate"><span class="pre">quick_check/2-3</span></code> predicates, invalid options are ignored and replaced
with the default value if applicable. The <code class="docutils literal notranslate"><span class="pre">quick_check/3</span></code> predicate
returns results in reified form:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">passed(Seed,</span> <span class="pre">Discarded,</span> <span class="pre">Labels)</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">failed(Goal,</span> <span class="pre">Seed)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error(Error,</span> <span class="pre">Culprit)</span></code> or <code class="docutils literal notranslate"><span class="pre">error(Error,</span> <span class="pre">Goal,</span> <span class="pre">Seed)</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Goal</span></code> argument is the random test that failed. The <code class="docutils literal notranslate"><span class="pre">Seed</span></code>
argument is the starting seed used to generate the random tests and
should be regarded as an opaque term. See below how to use it when
testing bug fixes. The <code class="docutils literal notranslate"><span class="pre">error(Error,</span> <span class="pre">Culprit)</span></code> result only occurs when
the template is not callable (e.g. a non-existing predicate) or when
there’s a problem with the pre-condition closure or with the label
closure (e.g. a pre-condition that always fails or a label that fails to
classify a generated test).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Discarded</span></code> argument returns the number of generated tests that
were discarded for failing to comply a pre-condition specified using the
<code class="docutils literal notranslate"><span class="pre">pc/1</span></code> option. This option is specially useful when constraining or
enforcing a relation between the generated arguments and is often used
as an alternative to define a custom type. For example, if we define the
following predicate:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>condition(<span class="nv">I</span>) <span class="o">:-</span>
    between(<span class="m">0</span>, <span class="m">127</span>, <span class="nv">I</span>).
</pre></div>
</div>
<p>we can then use it to filter the generated tests:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(<span class="k">integer</span>(<span class="o">+</span>byte), [pc(condition)]).
<span class="c">% 100 random tests passed, 94 discarded</span>
<span class="c">% starting seed: seed(416,18610,17023)</span>
yes
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Labels</span></code> argument returns a list of pairs <code class="docutils literal notranslate"><span class="pre">Label-N</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code>
is the number of generated tests that are classified as <code class="docutils literal notranslate"><span class="pre">Label</span></code> by a
closure specified using the <code class="docutils literal notranslate"><span class="pre">l/1</span></code> option. For example, assuming the
following predicate definition:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>label(<span class="nv">I</span>, <span class="nv">Label</span>) <span class="o">:-</span>
    (   <span class="nv">I</span> <span class="o">mod</span> <span class="m">2</span> <span class="o">=:=</span> <span class="m">0</span> <span class="o">-&gt;</span>
        <span class="nv">Label</span> <span class="o">=</span> even
    <span class="o">;</span>   <span class="nv">Label</span> <span class="o">=</span> odd
    ).
</pre></div>
</div>
<p>we can try:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(<span class="k">integer</span>(<span class="o">+</span>byte), [l(label), n(<span class="m">10000</span>)]).
<span class="c">% 10000 random tests passed, 0 discarded</span>
<span class="c">% starting seed: seed(25513,20881,16407)</span>
<span class="c">% even: 5037/10000 (50.370000%)</span>
<span class="c">% odd: 4963/10000 (49.630000%)</span>
yes
</pre></div>
</div>
<p>The label statistics are key to verify that the generated tests provide
the necessary coverage. The labelling predicates can return a single
test label or a list of test labels. Labels should be ground and are
typically atoms. To examine the generated tests themselves, you can use
the verbose option, <code class="docutils literal notranslate"><span class="pre">v/1</span></code>. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(<span class="k">integer</span>(<span class="o">+</span>integer), [v(<span class="k">true</span>), n(<span class="m">7</span>), pc([<span class="nv">I</span>]<span class="o">&gt;&gt;</span>(<span class="nv">I</span><span class="o">&gt;</span><span class="m">5</span>))]).
<span class="c">% Discarded: integer(0)</span>
<span class="c">% Passed:    integer(786)</span>
<span class="c">% Passed:    integer(590)</span>
<span class="c">% Passed:    integer(165)</span>
<span class="c">% Discarded: integer(-412)</span>
<span class="c">% Passed:    integer(440)</span>
<span class="c">% Discarded: integer(-199)</span>
<span class="c">% Passed:    integer(588)</span>
<span class="c">% Discarded: integer(-852)</span>
<span class="c">% Discarded: integer(-214)</span>
<span class="c">% Passed:    integer(196)</span>
<span class="c">% Passed:    integer(353)</span>
<span class="c">% 7 random tests passed, 5 discarded</span>
<span class="c">% starting seed: seed(23671,3853,29824)</span>
yes
</pre></div>
</div>
<p>When a counter-example is found, the verbose option also prints the
shrink steps. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(<span class="k">atom</span>(<span class="o">+</span>atomic), [v(<span class="k">true</span>), ec(<span class="k">false</span>)]).
<span class="c">% Passed:    atom(&#39;}U&#39;)</span>
<span class="o">*</span>     <span class="nv">Failure</span><span class="o">:</span>   <span class="k">atom</span>(<span class="o">-</span><span class="m">13</span>)
<span class="o">*</span>     <span class="nv">Shrinked</span><span class="o">:</span>  <span class="k">atom</span>(<span class="o">-</span><span class="m">6</span>)
<span class="o">*</span>     <span class="nv">Shrinked</span><span class="o">:</span>  <span class="k">atom</span>(<span class="o">-</span><span class="m">3</span>)
<span class="o">*</span>     <span class="nv">Shrinked</span><span class="o">:</span>  <span class="k">atom</span>(<span class="o">-</span><span class="m">1</span>)
<span class="o">*</span>     <span class="nv">Shrinked</span><span class="o">:</span>  <span class="k">atom</span>(<span class="m">0</span>)
<span class="o">*</span>     quick check test failure (at test <span class="m">2</span> after <span class="m">4</span> shrinks)<span class="o">:</span>
<span class="o">*</span>       <span class="k">atom</span>(<span class="m">0</span>)
<span class="o">*</span>     starting seed<span class="o">:</span> seed(<span class="m">1341</span>,<span class="m">12174</span>,<span class="m">18263</span>)
no
</pre></div>
</div>
<p>The other two predicates print the test results. The template can be a
<code class="docutils literal notranslate"><span class="pre">::/2</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;/2</span></code>, or <code class="docutils literal notranslate"><span class="pre">:/2</span></code> qualified callable term. When the
template is an unqualified callable term, it will be used to construct a
goal to be called in the context of the <em>sender</em> using the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;/2</span></code>
debugging control construct. A simple example by passing a template that
will trigger a failed test (as the <code class="docutils literal notranslate"><span class="pre">random::random/1</span></code> predicate always
returns non-negative floats):</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(random<span class="o">::</span>random(<span class="o">-</span>negative_float)).
<span class="o">*</span>     quick check test failure (at test <span class="m">1</span> after <span class="m">0</span> shrinks)<span class="o">:</span>
<span class="o">*</span>       random<span class="o">::</span>random(<span class="m">0.09230089279334841</span>)
<span class="o">*</span>     starting seed<span class="o">:</span> seed(<span class="m">3172</span>,<span class="m">9814</span>,<span class="m">20125</span>)
no
</pre></div>
</div>
<p>When QuickCheck exposes a bug in the tested code, we can use the
reported counter-example to help diagnose it and fix it. As tests are
randomly generated, we can use the starting seed reported with the
counter-example to confirm the bug fix by calling the
<code class="docutils literal notranslate"><span class="pre">quick_check/2-3</span></code> predicates with the <code class="docutils literal notranslate"><span class="pre">rs(Seed)</span></code> option. For
example, assume the following broken predicate definition:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>every_other([], []).
every_other([<span class="nv">_</span>, <span class="nv">X</span>| <span class="nv">L</span>], [<span class="nv">X</span> | <span class="nv">R</span>]) <span class="o">:-</span>
        every_other(<span class="nv">L</span>, <span class="nv">R</span>).
</pre></div>
</div>
<p>The predicate is supposed to construct a list by taking every other
element of an input list. Cursory testing may fail to notice the bug:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> every_other([<span class="m">1</span>,<span class="m">2</span>,<span class="m">3</span>,<span class="m">4</span>,<span class="m">5</span>,<span class="m">6</span>], <span class="nv">List</span>).
<span class="nv">List</span> <span class="o">=</span> [<span class="m">2</span>, <span class="m">4</span>, <span class="m">6</span>]
yes
</pre></div>
</div>
<p>But QuickCheck will report a bug with lists with an odd number of
elements with a simple property that verifies that the predicate always
succeed and returns a list of integers:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(every_other(<span class="o">+</span>list(integer), <span class="o">-</span>list(integer))).
<span class="o">*</span>     quick check test failure (at test <span class="m">2</span> after <span class="m">0</span> shrinks)<span class="o">:</span>
<span class="o">*</span>       every_other([<span class="m">0</span>],<span class="nv">A</span>)
<span class="o">*</span>     starting seed<span class="o">:</span> seed(<span class="m">3172</span>,<span class="m">9814</span>,<span class="m">20125</span>)
no
</pre></div>
</div>
<p>We could fix this particular bug by rewriting the predicate:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>every_other([], []).
every_other([<span class="nv">H</span>| <span class="nv">T</span>], <span class="nv">L</span>) <span class="o">:-</span>
    every_other(<span class="nv">T</span>, <span class="nv">H</span>, <span class="nv">L</span>).

every_other([], <span class="nv">X</span>, [<span class="nv">X</span>]).
every_other([<span class="nv">_</span>| <span class="nv">T</span>], <span class="nv">X</span>, [<span class="nv">X</span>| <span class="nv">L</span>]) <span class="o">:-</span>
    every_other(<span class="nv">T</span>, <span class="nv">L</span>).
</pre></div>
</div>
<p>By retesting with the same seed that uncovered the bug, the same random
test that found the bug will be generated and run again:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(
         every_other(<span class="o">+</span>list(integer), <span class="o">-</span>list(integer)),
         [rs(seed(<span class="m">3172</span>,<span class="m">9814</span>,<span class="m">20125</span>))]
     ).
<span class="c">% 100 random tests passed, 0 discarded</span>
<span class="c">% starting seed: seed(3172,9814,20125)</span>
yes
</pre></div>
</div>
<p>When retesting using the <code class="docutils literal notranslate"><span class="pre">logtalk_tester</span></code> automation script, the
starting seed can be set using the <code class="docutils literal notranslate"><span class="pre">-r</span></code> option. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ logtalk_tester -r &quot;seed(3172,9814,20125)&quot;
</pre></div>
</div>
<p>We could now move to other properties that the predicate should comply
(e.g. all elements in the output list being present in the input list).
Often, both traditional unit tests and QuickCheck tests are used,
complementing each other to ensure the required code coverage.</p>
<p>Another example using a Prolog module predicate:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(
        pairs<span class="o">:</span>pairs_keys_values(
            <span class="o">+</span>list(pair(atom,integer)),
            <span class="o">-</span>list(atom),
            <span class="o">-</span>list(integer)
        )
    ).
<span class="c">% 100 random tests passed, 0 discarded</span>
<span class="c">% starting seed: seed(3172,9814,20125)</span>
yes
</pre></div>
</div>
<p>As illustrated by the examples above, properties are expressed using
predicates. In the most simple cases, that can be the predicate that we
are testing itself. But, in general, it will be an auxiliary predicate
calling the predicate or predicates being tested and checking properties
that the results must comply with.</p>
<p>The QuickCheck test dialects and predicates take as argument the mode
template for a property, generate random values for each input argument
based on the type information, and check each output argument. For
common types, the implementation tries first (by default) common edge
cases (e.g. empty atom, empty list, or zero) before generating arbitrary
values. When the output arguments check fails, the QuickCheck
implementation tries (by default) up to 64 shrink operations of the
counter-example to report a simpler case to help debugging the failed
test. Edge cases, generating of arbitrary terms, and shrinking terms
make use of the library <code class="docutils literal notranslate"><span class="pre">arbitrary</span></code> category via the <code class="docutils literal notranslate"><span class="pre">type</span></code> object
(both entities can be extended by the user by defining clauses for
multifile predicates).</p>
<p>The mode template syntax is the same used in the <code class="docutils literal notranslate"><span class="pre">info/2</span></code> predicate
directives with an additional notation, <code class="docutils literal notranslate"><span class="pre">{}/1</span></code>, for passing argument
values as-is instead of generating random values for these arguments.
For example, assume that we want to verify the <code class="docutils literal notranslate"><span class="pre">type::valid/2</span></code>
predicate, which takes as first argument a type. Randomly generating
random types would be cumbersome at best but the main problem is that we
need to generate random values for the second argument according to the
first argument. Using the <code class="docutils literal notranslate"><span class="pre">{}/1</span></code> notation we can solve this problem
for any specific type, e.g. integer, by writing:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> lgtunit<span class="o">::</span>quick_check(type<span class="o">::</span>valid(<span class="k">{</span>integer<span class="k">}</span>, <span class="o">+</span>integer)).
</pre></div>
</div>
<p>We can also test all (ground, i.e. non-parametric) types with arbitrary
value generators by writing:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">forall</span>(
        (type<span class="o">::</span>type(<span class="nv">Type</span>), <span class="k">ground</span>(<span class="nv">Type</span>), type<span class="o">::</span>arbitrary(<span class="nv">Type</span>)),
        lgtunit<span class="o">::</span>quick_check(type<span class="o">::</span>valid(<span class="k">{</span><span class="nv">Type</span><span class="k">}</span>, <span class="o">+</span><span class="nv">Type</span>))
     ).
</pre></div>
</div>
<p>You can find the list of the basic supported types for using in the
template in the API documentation for the library entities <code class="docutils literal notranslate"><span class="pre">type</span></code> and
<code class="docutils literal notranslate"><span class="pre">arbitrary</span></code>. Note that other library entities, including third-party
or your own, can contribute with additional type definitions as both
<code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">arbitrary</span></code> entities are user extensible by defining
clauses for their multifile predicates.</p>
<p>The user can define new types to use in the property mode templates to
use with its QuickCheck tests by defining clauses for the <code class="docutils literal notranslate"><span class="pre">arbitrary</span></code>
library category multifile predicates.</p>
</div>
<div class="section" id="skipping-tests">
<h2>Skipping tests<a class="headerlink" href="#skipping-tests" title="Permalink to this headline">¶</a></h2>
<p>A test object can define the <code class="docutils literal notranslate"><span class="pre">condition/0</span></code> predicate (which defaults
to <code class="docutils literal notranslate"><span class="pre">true</span></code>) to test if some necessary condition for running the tests
holds. The tests are skipped if the call to this predicate fails or
generates an error.</p>
<p>Individual tests that for some reason should be unconditionally skipped
can have the test clause head prefixed with the <code class="docutils literal notranslate"><span class="pre">(-)/1</span></code> operator. For
example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> test(not_yet_ready) <span class="o">:-</span>
    ...
</pre></div>
</div>
<p>The number of skipped tests is reported together with the numbers of
passed and failed tests. To skip a test depending on some condition, use
the <code class="docutils literal notranslate"><span class="pre">test/3</span></code> dialect and the <code class="docutils literal notranslate"><span class="pre">condition/1</span></code> option. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(test_id, <span class="k">true</span>, [condition(<span class="k">current_prolog_flag</span>(bounded,<span class="k">true</span>))) <span class="o">:-</span>
    ...
</pre></div>
</div>
<p>The conditional compilation directives can also be used in alternative
but note that in this case there will be no report on the number of
skipped tests.</p>
</div>
<div class="section" id="checking-test-goal-results">
<h2>Checking test goal results<a class="headerlink" href="#checking-test-goal-results" title="Permalink to this headline">¶</a></h2>
<p>Checking test goal results can be performed using the <code class="docutils literal notranslate"><span class="pre">test/2-3</span></code>
dialect <code class="docutils literal notranslate"><span class="pre">true/1</span></code> and <code class="docutils literal notranslate"><span class="pre">deterministic/1</span></code> assertions. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(compare_3_order_less, deterministic(<span class="nv">Order</span> <span class="o">==</span> (<span class="o">&lt;</span>))) <span class="o">:-</span>
    <span class="k">compare</span>(<span class="nv">Order</span>, <span class="m">1</span>, <span class="m">2</span>).
</pre></div>
</div>
<p>For the other test dialects, checking test goal results can be performed
by calling the <code class="docutils literal notranslate"><span class="pre">assertion/1-2</span></code> utility predicates or by writing the
checking goals directly in the test body. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(compare_3_order_less) <span class="o">:-</span>
    <span class="k">compare</span>(<span class="nv">Order</span>, <span class="m">1</span>, <span class="m">2</span>),
    <span class="o">^^</span>assertion(<span class="nv">Order</span> <span class="o">==</span> (<span class="o">&lt;</span>)).
</pre></div>
</div>
<p>or:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>succeeds(compare_3_order_less) <span class="o">:-</span>
    <span class="k">compare</span>(<span class="nv">Order</span>, <span class="m">1</span>, <span class="m">2</span>),
    <span class="nv">Order</span> <span class="o">==</span> (<span class="o">&lt;</span>).
</pre></div>
</div>
<p>Using assertions is preferable as it facilitates debugging by printing
the unexpected results when the tests fail.</p>
<p>Ground results can be compared using the standard <code class="docutils literal notranslate"><span class="pre">==/2</span></code> term equality
built-in predicate. Non-ground results can be compared using the
<code class="docutils literal notranslate"><span class="pre">variant/2</span></code> predicate provided by <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code>. The standard
<code class="docutils literal notranslate"><span class="pre">subsumes_term/2</span></code> built-in predicate can be used when testing a
compound term structure while abstracting some of its arguments.
Floating-point numbers can be compared using the <code class="docutils literal notranslate"><span class="pre">=~=/2</span></code>,
<code class="docutils literal notranslate"><span class="pre">approximately_equal/3</span></code>, <code class="docutils literal notranslate"><span class="pre">essentially_equal/3</span></code>, and
<code class="docutils literal notranslate"><span class="pre">tolerance_equal/4</span></code> predicates provided by <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code>. Using the
<code class="docutils literal notranslate"><span class="pre">=/2</span></code> term unification built-in predicate is almost always an error as
it would mask test goals failing to bind output arguments.</p>
</div>
<div class="section" id="testing-local-predicates">
<h2>Testing local predicates<a class="headerlink" href="#testing-local-predicates" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">(&lt;&lt;)/2</span></code> debugging control construct can be used to access and
test object local predicates (i.e. predicates without a scope
directive). In this case, make sure that the <code class="docutils literal notranslate"><span class="pre">context_switching_calls</span></code>
compiler flag is set to <code class="docutils literal notranslate"><span class="pre">allow</span></code> for those objects. This is seldom
required, however, as local predicates are usually auxiliary predicates
called by public predicates and thus tested when testing those public
predicates. The code coverage support can pinpoint any local predicate
clause that is not being exercised by the tests.</p>
</div>
<div class="section" id="testing-non-deterministic-predicates">
<h2>Testing non-deterministic predicates<a class="headerlink" href="#testing-non-deterministic-predicates" title="Permalink to this headline">¶</a></h2>
<p>For testing non-deterministic predicates (with a finite and manageable
number of solutions), you can wrap the test goal using the standard
<code class="docutils literal notranslate"><span class="pre">findall/3</span></code> predicate to collect all solutions and check against the
list of expected solutions. When the expected solutions are a set, use
in alternative the standard <code class="docutils literal notranslate"><span class="pre">setof/3</span></code> predicate.</p>
</div>
<div class="section" id="testing-generators">
<h2>Testing generators<a class="headerlink" href="#testing-generators" title="Permalink to this headline">¶</a></h2>
<p>To test all solutions of a predicate that acts as a <em>generator</em>, we can
use the <code class="docutils literal notranslate"><span class="pre">forall/2</span></code> predicate as the test goal with the <code class="docutils literal notranslate"><span class="pre">assertion/2</span></code>
predicate called to report details on any solution that fails the test.
For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">uses</span>(lgtunit, [assertion<span class="o">/</span><span class="m">2</span>]).
...

test(test_solution_generator) <span class="o">:-</span>
    <span class="k">forall</span>(
        generator(<span class="nv">X</span>, <span class="nv">Y</span>, <span class="nv">Z</span>),
        assertion(generator(<span class="nv">X</span>,<span class="nv">Y</span>,<span class="nv">Z</span>), test(<span class="nv">X</span>,<span class="nv">Y</span>,<span class="nv">Z</span>))
    ).
</pre></div>
</div>
</div>
<div class="section" id="testing-input-output-predicates">
<span id="id1"></span><h2>Testing input/output predicates<a class="headerlink" href="#testing-input-output-predicates" title="Permalink to this headline">¶</a></h2>
<p>Extensive support for testing input/output predicates is provided, based
on similar support found on the Prolog conformance testing framework
written by Péter Szabó and Péter Szeredi.</p>
<p>Two sets of predicates are provided, one for testing text input/output
and one for testing binary input/output. In both cases, temporary files
(possibly referenced by a user-defined alias) are used. The predicates
allow setting, checking, and cleaning text/binary input/output.</p>
<p>As an example of testing an input predicate, consider the standard
<code class="docutils literal notranslate"><span class="pre">get_char/1</span></code> predicate. This predicate reads a single character (atom)
from the current input stream. Some test for basic functionality could
be:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(get_char_1_01, <span class="k">true</span>(<span class="nv">Char</span> <span class="o">==</span> <span class="s">&#39;q&#39;</span>)) <span class="o">:-</span>
    <span class="o">^^</span>set_text_input(<span class="s">&#39;qwerty&#39;</span>),
    <span class="k">get_char</span>(<span class="nv">Char</span>).

test(get_char_1_02, <span class="k">true</span>(<span class="nv">Assertion</span>)) <span class="o">:-</span>
    <span class="o">^^</span>set_text_input(<span class="s">&#39;qwerty&#39;</span>),
    <span class="k">get_char</span>(<span class="nv">_Char</span>),
    <span class="o">^^</span>text_input_assertion(<span class="s">&#39;werty&#39;</span>, <span class="nv">Assertion</span>).
</pre></div>
</div>
<p>As you can see in the above example, the testing pattern consist on
setting the input for the predicate being tested, calling it, and then
checking the results. It is also possible to work with streams other
than the current input/output streams by using the <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> predicate
variants that take a stream as argument. For example, when testing the
standard <code class="docutils literal notranslate"><span class="pre">get_char/2</span></code> predicate, we could write:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(get_char_2_01, <span class="k">true</span>(<span class="nv">Char</span> <span class="o">==</span> <span class="s">&#39;q&#39;</span>)) <span class="o">:-</span>
    <span class="o">^^</span>set_text_input(my_alias, <span class="s">&#39;qwerty&#39;</span>),
    <span class="k">get_char</span>(my_alias, <span class="nv">Char</span>).

test(get_char_2_02, <span class="k">true</span>(<span class="nv">Assertion</span>)) <span class="o">:-</span>
    <span class="o">^^</span>set_text_input(my_alias, <span class="s">&#39;qwerty&#39;</span>),
    <span class="k">get_char</span>(my_alias, <span class="nv">_Char</span>),
    <span class="o">^^</span>text_input_assertion(my_alias, <span class="s">&#39;werty&#39;</span>, <span class="nv">Assertion</span>).
</pre></div>
</div>
<p>Testing output predicates follows the same pattern by using instead the
<code class="docutils literal notranslate"><span class="pre">set_text_output/1-2</span></code> and <code class="docutils literal notranslate"><span class="pre">text_output_assertion/2-3</span></code> predicates.
For testing binary input/output predicates, equivalent testing
predicates are provided. There is also a small set of helper predicates
for dealing with stream handles and stream positions. For testing with
files instead of streams, testing predicates are provided that allow
creating text and binary files with given contents and check text and
binary files for expected contents.</p>
<p>For more practical examples, check the included tests for Prolog
conformance of standard input/output predicates.</p>
</div>
<div class="section" id="suppressing-tested-predicates-output">
<h2>Suppressing tested predicates output<a class="headerlink" href="#suppressing-tested-predicates-output" title="Permalink to this headline">¶</a></h2>
<p>Sometimes predicates being tested output text or binary data that at
best clutters testing logs and at worse can interfere with parsing of
test logs. If that output itself is not under testing, you can suppress
it by using the goals <code class="docutils literal notranslate"><span class="pre">^^suppress_text_output</span></code> or
<code class="docutils literal notranslate"><span class="pre">^^suppress_binary_output</span></code> at the beginning of the tests. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>test(proxies_04, <span class="k">true</span>(<span class="nv">Color</span> <span class="o">==</span> yellow)) <span class="o">:-</span>
    <span class="o">^^</span>suppress_text_output,
    <span class="k">{</span>circle(<span class="s">&#39;#2&#39;</span>, <span class="nv">Color</span>)<span class="k">}</span><span class="o">::</span>print.
</pre></div>
</div>
</div>
<div class="section" id="tests-with-timeout-limits">
<h2>Tests with timeout limits<a class="headerlink" href="#tests-with-timeout-limits" title="Permalink to this headline">¶</a></h2>
<p>There’s no portable way to call a goal with a timeout limit. However,
some backend Prolog compilers provide this functionality:</p>
<ul class="simple">
<li><p>B-Prolog: <code class="docutils literal notranslate"><span class="pre">time_out/3</span></code> predicate</p></li>
<li><p>ECLiPSe: <code class="docutils literal notranslate"><span class="pre">timeout/3</span></code> and <code class="docutils literal notranslate"><span class="pre">timeout/7</span></code> library predicates</p></li>
<li><p>SICStus Prolog: <code class="docutils literal notranslate"><span class="pre">time_out/3</span></code> library predicate</p></li>
<li><p>SWI-Prolog: <code class="docutils literal notranslate"><span class="pre">call_with_time_limit/2</span></code> library predicate</p></li>
<li><p>YAP: <code class="docutils literal notranslate"><span class="pre">time_out/3</span></code> library predicate</p></li>
</ul>
<p>Logtalk provides a <code class="docutils literal notranslate"><span class="pre">timeout</span></code> portability library implementing a simple
abstraction for those backend Prolog compilers.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">logtalk_tester</span></code> automation script accepts a timeout option that
can be used to set a limit per test set.</p>
</div>
<div class="section" id="setup-and-cleanup-goals">
<h2>Setup and cleanup goals<a class="headerlink" href="#setup-and-cleanup-goals" title="Permalink to this headline">¶</a></h2>
<p>A test object can define <code class="docutils literal notranslate"><span class="pre">setup/0</span></code> and <code class="docutils literal notranslate"><span class="pre">cleanup/0</span></code> goals. The
<code class="docutils literal notranslate"><span class="pre">setup/0</span></code> predicate is called, when defined, before running the object
unit tests. The <code class="docutils literal notranslate"><span class="pre">cleanup/0</span></code> predicate is called, when defined, after
running all the object unit tests. The tests are skipped when the setup
goal fails or throws an error. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>cleanup <span class="o">:-</span>
    <span class="k">this</span>(<span class="nv">This</span>),
    <span class="k">object_property</span>(<span class="nv">This</span>, file(<span class="nv">_</span>,<span class="nv">Directory</span>)),
    <span class="k">atom_concat</span>(<span class="nv">Directory</span>, serialized_objects, <span class="nv">File</span>),
    <span class="k">catch</span>(<span class="k">ignore</span>(os<span class="o">::</span>delete_file(<span class="nv">File</span>)), <span class="nv">_</span>, <span class="k">true</span>).
</pre></div>
</div>
<p>Per test setup and cleanup goals can be defined using the <code class="docutils literal notranslate"><span class="pre">test/3</span></code>
dialect and the <code class="docutils literal notranslate"><span class="pre">setup/1</span></code> and <code class="docutils literal notranslate"><span class="pre">cleanup/1</span></code> options. The test is
skipped when the setup goal fails or throws an error. Note that a broken
test cleanup goal doesn’t affect the test but may adversely affect any
following tests.</p>
</div>
<div class="section" id="test-annotations">
<h2>Test annotations<a class="headerlink" href="#test-annotations" title="Permalink to this headline">¶</a></h2>
<p>It’s possible to define per unit and per test annotations to be printed
after the test results or when tests are skipped. This is particularly
useful when some units or some unit tests may be run while still being
developed. Annotations can be used to pass additional information to a
user reviewing test results. By intercepting the unit test framework
message printing calls (using the <code class="docutils literal notranslate"><span class="pre">message_hook/4</span></code> hook predicate),
test automation scripts and integrating tools can also access these
annotations.</p>
<p>Units can define a global annotation using the predicate <code class="docutils literal notranslate"><span class="pre">note/1</span></code>. To
define per test annotations, use the <code class="docutils literal notranslate"><span class="pre">test/3</span></code> dialect and the
<code class="docutils literal notranslate"><span class="pre">note/1</span></code> option. For example, you can inform why a test is being
skipped by writing:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> test(foo_1, <span class="k">true</span>, [note(<span class="s">&#39;Waiting for Deep Thought answer&#39;</span>)]) <span class="o">:-</span>
    ...
</pre></div>
</div>
<p>Annotations are written, by default, between parenthesis after and in
the same line as the test results.</p>
</div>
<div class="section" id="debugging-failed-tests">
<h2>Debugging failed tests<a class="headerlink" href="#debugging-failed-tests" title="Permalink to this headline">¶</a></h2>
<p>Debugging of failed unit tests is usually easy if you use assertions as
the reason for the assertion failures is printed out. Thus, use
preferably the <code class="docutils literal notranslate"><span class="pre">test/2-3</span></code> dialects with <code class="docutils literal notranslate"><span class="pre">true(Assertion)</span></code> or
<code class="docutils literal notranslate"><span class="pre">deterministic(Assertion)</span></code> outcomes. If a test checks multiple
assertions, you can use the predicate <code class="docutils literal notranslate"><span class="pre">assertion/2</span></code> in the test body.</p>
<p>In order to debug failed unit tests, start by compiling the unit test
objects and the code being tested in debug mode. Load the debugger and
trace the test that you want to debug. For example, assuming your tests
are defined in a <code class="docutils literal notranslate"><span class="pre">tests</span></code> object and that the identifier of test to be
debugged is <code class="docutils literal notranslate"><span class="pre">test_foo</span></code>:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(debugger(loader)).
...

| <span class="o">?-</span> debugger<span class="o">::</span>trace.
...

| <span class="o">?-</span> tests<span class="o">::</span>run(test_foo).
...
</pre></div>
</div>
<p>You can also compile the code and the tests in debug mode but without
using the <code class="docutils literal notranslate"><span class="pre">hook/1</span></code> compiler option for the tests compilation. Assuming
that the <code class="docutils literal notranslate"><span class="pre">context_switching_calls</span></code> flag is set to <code class="docutils literal notranslate"><span class="pre">allow</span></code>, you can
then use the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;/2</span></code> debugging control construct to debug the tests.
For example, assuming that the identifier of test to be debugged is
<code class="docutils literal notranslate"><span class="pre">test_foo</span></code> and that you used the <code class="docutils literal notranslate"><span class="pre">test/1</span></code> dialect:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(debugger(loader)).
...

| <span class="o">?-</span> debugger<span class="o">::</span>trace.
...

| <span class="o">?-</span> tests<span class="o">&lt;&lt;</span>test(test_foo).
...
</pre></div>
</div>
<p>In the more complicated cases, it may be worth to define
<code class="docutils literal notranslate"><span class="pre">loader_debug.lgt</span></code> and <code class="docutils literal notranslate"><span class="pre">tester_debug.lgt</span></code> files that load code and
tests in debug mode and also load the debugger.</p>
</div>
<div class="section" id="code-coverage">
<h2>Code coverage<a class="headerlink" href="#code-coverage" title="Permalink to this headline">¶</a></h2>
<p>If you want entity predicate clause coverage information to be collected
and printed, you will need to compile the entities that you’re testing
using the flags <code class="docutils literal notranslate"><span class="pre">debug(on)</span></code> and <code class="docutils literal notranslate"><span class="pre">source_data(on)</span></code>. Be aware,
however, that compiling in debug mode results in a performance penalty.</p>
<p>A single test object may include tests for one or more entities
(objects, protocols, and categories). The entities being tested by a
unit test object for which code coverage information should be collected
must be declared using the <code class="docutils literal notranslate"><span class="pre">cover/1</span></code> predicate. For example, to
collect code coverage data for the objects <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span></code> include
in the tests object the two clauses:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>cover(foo).
cover(bar).
</pre></div>
</div>
<p>Code coverage is listed using the predicates clause indexes (counting
from one). For example, using the <code class="docutils literal notranslate"><span class="pre">points</span></code> example in the Logtalk
distribution:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="c">% point: default_init_option/1 - 2/2 - (all)</span>
<span class="c">% point: instance_base_name/1 - 1/1 - (all)</span>
<span class="c">% point: move/2 - 1/1 - (all)</span>
<span class="c">% point: position/2 - 1/1 - (all)</span>
<span class="c">% point: print/0 - 1/1 - (all)</span>
<span class="c">% point: process_init_option/1 - 1/2 - [1]</span>
<span class="c">% point: position_/2 - 0/0 - (all)</span>
<span class="c">% point: 7 out of 8 clauses covered, 87.500000% coverage</span>
</pre></div>
</div>
<p>The numbers after the predicate indicators represents the clauses
covered and the total number of clauses. E.g. for the
<code class="docutils literal notranslate"><span class="pre">process_init_option/1</span></code> predicate, the tests cover 1 out of 2 clauses.
After these numbers, we either get <code class="docutils literal notranslate"><span class="pre">(all)</span></code> telling us that all clauses
are covered or a list of indexes for the covered clauses. E.g. only the
first clause for the <code class="docutils literal notranslate"><span class="pre">process_init_option/1</span></code> predicate, <code class="docutils literal notranslate"><span class="pre">[1]</span></code>.
Summary clause coverage numbers are also printed for entities and for
clauses across all entities.</p>
<p>In the printed predicate clause coverage information, you may get a
total number of clauses smaller than the covered clauses. This results
from the use of dynamic predicates with clauses asserted at runtime. You
may easily identify dynamic predicates in the results as their clauses
often have an initial count equal to zero.</p>
<p>The list of indexes of the covered predicate clauses can be quite long.
Some backend Prolog compilers provide a flag or a predicate to control
the depth of printed terms that can be useful:</p>
<ul class="simple">
<li><p>CxProlog: <code class="docutils literal notranslate"><span class="pre">write_depth/2</span></code> predicate</p></li>
<li><p>ECLiPSe: <code class="docutils literal notranslate"><span class="pre">print_depth</span></code> flag</p></li>
<li><p>SICStus Prolog: <code class="docutils literal notranslate"><span class="pre">toplevel_print_options</span></code> flag</p></li>
<li><p>SWI-Prolog 7.1.10 or earlier: <code class="docutils literal notranslate"><span class="pre">toplevel_print_options</span></code> flag</p></li>
<li><p>SWI-Prolog 7.1.11 or later: <code class="docutils literal notranslate"><span class="pre">answer_write_options</span></code> flag</p></li>
<li><p>XSB: <code class="docutils literal notranslate"><span class="pre">set_file_write_depth/1</span></code> predicate</p></li>
<li><p>YAP: <code class="docutils literal notranslate"><span class="pre">write_depth/2-3</span></code> predicates</p></li>
</ul>
<p>Code coverage is only available when testing Logtalk code. But Prolog
modules can often be compiled as Logtalk objects and plain Prolog code
may be wrapped in a Logtalk object. For example, assuming a
<code class="docutils literal notranslate"><span class="pre">module.pl</span></code> module file, we can compile and load the module as an
object by simply calling:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(module).
...
</pre></div>
</div>
<p>The module exported predicates become object public predicates. For a
plain Prolog file, say <code class="docutils literal notranslate"><span class="pre">plain.pl</span></code>, we can define a Logtalk object that
wraps the code using an <code class="docutils literal notranslate"><span class="pre">include/1</span></code> directive:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">object</span>(plain).

<span class="p">    :- </span><span class="k">include</span>(<span class="s">&#39;plain.pl&#39;</span>).

<span class="p">:- </span><span class="k">end_object</span>.
</pre></div>
</div>
<p>The object can also declare as public the top Prolog predicates to
simplify writing the tests. In alternative, we can use the
<code class="docutils literal notranslate"><span class="pre">object_wrapper_hook</span></code> provided by the <code class="docutils literal notranslate"><span class="pre">hook_objects</span></code> library:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>| <span class="o">?-</span> <span class="k">logtalk_load</span>(hook_objects(object_wrapper_hook)).
...

| <span class="o">?-</span> <span class="k">logtalk_load</span>(plain, [hook(object_wrapper_hook)]).
...
</pre></div>
</div>
<p>These workarounds may thus allow generating code coverage data also for
Prolog code by defining tests that use the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;/2</span></code> debugging control
construct to call the Prolog predicates.</p>
</div>
<div class="section" id="automating-running-tests">
<h2>Automating running tests<a class="headerlink" href="#automating-running-tests" title="Permalink to this headline">¶</a></h2>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">scripts/logtalk_tester.sh</span></code> Bash shell script for
automating running unit tests. See the <code class="docutils literal notranslate"><span class="pre">scripts/NOTES.md</span></code> file for
details. On POSIX systems, assuming Logtalk was installed using one of
the provided installers or installation scripts, there is also a <code class="docutils literal notranslate"><span class="pre">man</span></code>
page for the script:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ man logtalk_tester
</pre></div>
</div>
<p>An HTML version of this man page can be found at:</p>
<p><a class="reference external" href="https://logtalk.org/man/logtalk_tester.html">https://logtalk.org/man/logtalk_tester.html</a></p>
<p>Additional advice on testing and on automating testing using continuous
integration servers can be found at:</p>
<p><a class="reference external" href="https://logtalk.org/testing.html">https://logtalk.org/testing.html</a></p>
</div>
<div class="section" id="utility-predicates">
<h2>Utility predicates<a class="headerlink" href="#utility-predicates" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> tool provides several public utility predicates to
simplify writing unit tests:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">variant(Term1,</span> <span class="pre">Term2)</span></code></div>
<div class="line">to check when two terms are a variant of each other (e.g. to check
expected test results against actual results when they contain
variables)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">assertion(Goal)</span></code></div>
<div class="line">to generate an exception in case the goal argument fails or throws
an error</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">assertion(Description,</span> <span class="pre">Goal)</span></code></div>
<div class="line">to generate an exception in case the goal argument fails or throws
an error (the first argument allows assertion failures to be
distinguished when using multiple assertions)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">approximately_equal(Number1,</span> <span class="pre">Number2,</span> <span class="pre">Epsilon)</span></code></div>
<div class="line">for number approximate equality</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">essentially_equal(Number1,</span> <span class="pre">Number2,</span> <span class="pre">Epsilon)</span></code></div>
<div class="line">for number essential equality</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">tolerance_equal(Number1,</span> <span class="pre">Number2,</span> <span class="pre">RelativeTolerance,</span> <span class="pre">AbsoluteTolerance)</span></code></div>
<div class="line">for number equality within tolerances</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Number1</span> <span class="pre">=~=</span> <span class="pre">Number2</span></code></div>
<div class="line">for number (or list of numbers) close equality (usually
floating-point numbers)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">benchmark(Goal,</span> <span class="pre">Time)</span></code></div>
<div class="line">for timing a goal</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">benchmark_reified(Goal,</span> <span class="pre">Time,</span> <span class="pre">Result)</span></code></div>
<div class="line">reified version of <code class="docutils literal notranslate"><span class="pre">benchmark/2</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">benchmark(Goal,</span> <span class="pre">Repetitions,</span> <span class="pre">Time)</span></code></div>
<div class="line">for finding the average time to prove a goal</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">benchmark(Goal,</span> <span class="pre">Repetitions,</span> <span class="pre">Clock,</span> <span class="pre">Time)</span></code></div>
<div class="line">for finding the average time to prove a goal using a cpu or a wall
clock</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">deterministic(Goal)</span></code></div>
<div class="line">for checking that a predicate succeeds without leaving a
choice-point</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">deterministic(Goal,</span> <span class="pre">Deterministic)</span></code></div>
<div class="line">reified version of the <code class="docutils literal notranslate"><span class="pre">deterministic/1</span></code> predicate</div>
</div>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">assertion/1-2</span></code> predicates can be used in the body of tests where
using two or more assertions is convenient or in the body of tests
written using the <code class="docutils literal notranslate"><span class="pre">test/1</span></code>, <code class="docutils literal notranslate"><span class="pre">succeeds/1</span></code>, and <code class="docutils literal notranslate"><span class="pre">deterministic/1</span></code>
dialects to help differentiate between the test goal and checking the
test goal results and to provide more informative test failure messages.</p>
<p>When the assertion is a call to local predicate of the tests object, you
must call <code class="docutils literal notranslate"><span class="pre">assertion/1-2</span></code> using an implicit or explicit message
instead of a using <em>super</em> call. To use an implicit message, add the
following directive to the tests object:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span><span class="p">:- </span><span class="k">uses</span>(lgtunit, [assertion<span class="o">/</span><span class="m">1</span>, assertion<span class="o">/</span><span class="m">2</span>]).
</pre></div>
</div>
<p>The reason this is required is that the <code class="docutils literal notranslate"><span class="pre">assertion/1-2</span></code> predicates are
declared as meta-predicates and thus assertion goals are called in the
context of the <em>sender</em>, which would be the <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> object in the
case of a <code class="docutils literal notranslate"><span class="pre">^^/2</span></code> call (as it preserves both <em>self</em> and <em>sender</em> and
the tests are internally run by a message sent from the <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code>
object to the tests object).</p>
<p>As the <code class="docutils literal notranslate"><span class="pre">benchmark/2-3</span></code> predicates are meta-predicates, turning on the
<code class="docutils literal notranslate"><span class="pre">optimize</span></code> compiler flag is advised to avoid runtime compilation of
the meta-argument, which would add an overhead to the timing results.
But this advice conflicts with collecting code coverage data, which
requires compilation in debug mode. The solution is to use separate test
objects for benchmarking and for code coverage.</p>
<p>Consult the <code class="docutils literal notranslate"><span class="pre">lgtunit</span></code> object documentation for more details on these
predicates.</p>
</div>
<div class="section" id="exporting-test-results-in-xunit-xml-format">
<h2>Exporting test results in xUnit XML format<a class="headerlink" href="#exporting-test-results-in-xunit-xml-format" title="Permalink to this headline">¶</a></h2>
<p>To output test results in the xUnit XML format, simply load the
<code class="docutils literal notranslate"><span class="pre">xunit_output.lgt</span></code> file before running the tests. This file defines an
object, <code class="docutils literal notranslate"><span class="pre">xunit_output</span></code>, that intercepts and rewrites unit test
execution messages, converting them to the xUnit XML format.</p>
<p>To export the test results to a file using the xUnit XML format, simply
load the <code class="docutils literal notranslate"><span class="pre">xunit_report.lgt</span></code> file before running the tests. A file
named <code class="docutils literal notranslate"><span class="pre">xunit_report.xml</span></code> will be created in the same directory as the
object defining the tests. When running a set of test suites as a single
unified suite (using the <code class="docutils literal notranslate"><span class="pre">run_test_sets/1</span></code> predicate), the single
xUnit report is created in the directory of the first test suite object
in the set.</p>
<p>There are several third-party xUnit report converters that can generate
HTML files for easy browsing. For example:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://allure.qatools.ru">http://allure.qatools.ru</a> (supports
multiple reports)</p></li>
<li><p><a class="reference external" href="https://github.com/Zir0-93/xunit-to-html">https://github.com/Zir0-93/xunit-to-html</a>
(supports multiple test sets in a single report)</p></li>
<li><p><a class="reference external" href="https://www.npmjs.com/package/xunit-viewer">https://www.npmjs.com/package/xunit-viewer</a></p></li>
<li><p><a class="reference external" href="https://github.com/JatechUK/NUnit-HTML-Report-Generator">https://github.com/JatechUK/NUnit-HTML-Report-Generator</a></p></li>
<li><p><a class="reference external" href="https://plugins.jenkins.io/xunit">https://plugins.jenkins.io/xunit</a></p></li>
</ul>
</div>
<div class="section" id="exporting-test-results-in-the-tap-output-format">
<h2>Exporting test results in the TAP output format<a class="headerlink" href="#exporting-test-results-in-the-tap-output-format" title="Permalink to this headline">¶</a></h2>
<p>To output test results in the TAP (Test Anything Protocol) format,
simply load the <code class="docutils literal notranslate"><span class="pre">tap_output.lgt</span></code> file before running the tests. This
file defines an object, <code class="docutils literal notranslate"><span class="pre">tap_output</span></code>, that intercepts and rewrites
unit test execution messages, converting them to the TAP output format.</p>
<p>To export the test results to a file using the TAP (Test Anything
Protocol) output format, load instead the <code class="docutils literal notranslate"><span class="pre">tap_report.lgt</span></code> file before
running the tests. A file named <code class="docutils literal notranslate"><span class="pre">tap_report.txt</span></code> will be created in
the same directory as the object defining the tests.</p>
<p>When using the <code class="docutils literal notranslate"><span class="pre">test/3</span></code> dialect with the TAP format, a <code class="docutils literal notranslate"><span class="pre">note/1</span></code>
option whose argument is an atom starting with a <code class="docutils literal notranslate"><span class="pre">TODO</span></code> or <code class="docutils literal notranslate"><span class="pre">todo</span></code>
word results in a test report with a TAP TODO directive.</p>
<p>When running a set of test suites as a single unified suite, the single
TAP report is created in the directory of the first test suite object in
the set.</p>
</div>
<div class="section" id="exporting-code-coverage-results-in-xml-format">
<h2>Exporting code coverage results in XML format<a class="headerlink" href="#exporting-code-coverage-results-in-xml-format" title="Permalink to this headline">¶</a></h2>
<p>To export code coverage results in XML format, load the
<code class="docutils literal notranslate"><span class="pre">coverage_report.lgt</span></code> file before running the tests. A file named
<code class="docutils literal notranslate"><span class="pre">coverage_report.xml</span></code> will be created in the same directory as the
object defining the tests.</p>
<p>The XML file can be opened in most web browsers (with the notorious
exception of Google Chrome) by copying to the same directory the
<code class="docutils literal notranslate"><span class="pre">coverage_report.dtd</span></code> and <code class="docutils literal notranslate"><span class="pre">coverage_report.xsl</span></code> files found in the
<code class="docutils literal notranslate"><span class="pre">tools/lgtunit</span></code> directory (when using the <code class="docutils literal notranslate"><span class="pre">logtalk_tester</span></code> script,
these two files are copied automatically). In alternative, an XSLT
processor can be used to generate an XHTML file instead of relying on a
web browser for the transformation. For example, using the popular
<code class="docutils literal notranslate"><span class="pre">xsltproc</span></code> processor:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ xsltproc -o coverage_report.html coverage_report.xml
</pre></div>
</div>
<p>The coverage report can include links to the source code when hosted on
Bitbucket, GitHub, or GitLab. This requires passing the base URL as the
value for the <code class="docutils literal notranslate"><span class="pre">url</span></code> XSLT parameter. The exact syntax depends on the
XSLT processor, however. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ xsltproc \
  --stringparam url https://github.com/LogtalkDotOrg/logtalk3/blob/master \
  -o coverage_report.html coverage_report.xml
</pre></div>
</div>
<p>Note that the base URL should preferably be a permanent link (i.e. it
should include the commit SHA1) so that the links to source code files
and lines remain valid if the source code is later updated. It’s also
necessary to suppress the local path prefix in the generated
<code class="docutils literal notranslate"><span class="pre">coverage_report.xml</span></code> file. For example:</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ logtalk_tester -c xml -s $HOME/logtalk/
</pre></div>
</div>
<p>Alternatively, you can pass the local path prefix to be suppressed to
the XSLT processor (note that the <code class="docutils literal notranslate"><span class="pre">logtalk_tester</span></code> script suppresses
the <code class="docutils literal notranslate"><span class="pre">$HOME</span></code> prefix by default):</p>
<div class="highlight-logtalk notranslate"><div class="highlight"><pre><span></span>$ xsltproc \
  --stringparam prefix logtalk/ \
  --stringparam url https://github.com/LogtalkDotOrg/logtalk3/blob/master \
  -o coverage_report.html coverage_report.xml
</pre></div>
</div>
<p>If you are using Bitbucket, GitHub, or GitLab hosted in your own
servers, the <code class="docutils literal notranslate"><span class="pre">url</span></code> parameter may not contain a <code class="docutils literal notranslate"><span class="pre">bitbucket</span></code>,
<code class="docutils literal notranslate"><span class="pre">github</span></code>, or <code class="docutils literal notranslate"><span class="pre">gitlab</span></code> string. In this case, you can use the XSLT
parameter <code class="docutils literal notranslate"><span class="pre">host</span></code> to indicate which service are you running.</p>
</div>
<div class="section" id="minimizing-test-results-output">
<h2>Minimizing test results output<a class="headerlink" href="#minimizing-test-results-output" title="Permalink to this headline">¶</a></h2>
<p>To minimize the test results output, simply load the
<code class="docutils literal notranslate"><span class="pre">minimal_output.lgt</span></code> file before running the tests. This file defines
an object, <code class="docutils literal notranslate"><span class="pre">minimal_output</span></code>, that intercepts and summarizes the unit
test execution messages.</p>
</div>
<div class="section" id="known-issues">
<h2>Known issues<a class="headerlink" href="#known-issues" title="Permalink to this headline">¶</a></h2>
<p>Parameter variables (<code class="docutils literal notranslate"><span class="pre">_VariableName_</span></code>) cannot currently be used in the
definition of test options (e.g. <code class="docutils literal notranslate"><span class="pre">condition/1</span></code>) when using the
<code class="docutils literal notranslate"><span class="pre">test/3</span></code> dialect. Use in alternative the <code class="docutils literal notranslate"><span class="pre">pgr/2</span></code> built-in execution
context predicate.</p>
<p>Deterministic unit tests are currently not available when using Lean
Prolog or Quintus Prolog as these backend compilers lack required
built-in support that cannot be sensibly defined in Prolog.</p>
</div>
<div class="section" id="other-notes">
<h2>Other notes<a class="headerlink" href="#other-notes" title="Permalink to this headline">¶</a></h2>
<p>All source files are indented using tabs (a common setting is a tab
width equivalent to 4 spaces).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="linter.html" class="btn btn-neutral float-right" title="linter" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lgtdoc.html" class="btn btn-neutral float-left" title="lgtdoc" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1998-2020, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>