

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Glossary &mdash; The Logtalk Handbook v3.39.0-b02 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="zippers" href="libraries/zippers.html" />
   
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> The Logtalk Handbook
          

          
            
            <img src="_static/logtalk.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.39.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userman/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="libraries/index.html">Libraries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

            
          
	<p class="caption"><span class="caption-text">External Contents</span></p>
    <a href="../docs/index.html">APIs</a>
    <a href="https://logtalk.org">Logtalk website</a>
    <a href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Glossary</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/glossary.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="glossary">
<h1>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h1>
<dl class="glossary simple">
<dt id="term-abstract-class">abstract class</dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that cannot be instantiated. Usually used to contain
common predicates that are inherited by other classes.</p>
</dd>
<dt id="term-abstract-method">abstract method</dt><dd><p>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> implementing an algorithm whose step corresponds
to calls to methods defined in the descendants of the object (or
<a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>) containing it.</p>
</dd>
<dt id="term-adapter-file">adapter file</dt><dd><p>A Prolog source file defining a minimal abstraction layer between the
Logtalk compiler/runtime and a specific <a class="reference internal" href="#term-backend-Prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>.</p>
</dd>
<dt id="term-ancestor">ancestor</dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> or a parent <a class="reference internal" href="#term-prototype"><span class="xref std std-term">prototype</span></a> that contributes (via
inheritance) to the definition of an object. For class-based hierarchies,
the ancestors of an instance are its class(es) and all the superclasses
of its class(es). For prototype-based hierarchies, the ancestors of
a prototype are its parent(s) and the ancestors of its parent(s).</p>
</dd>
<dt id="term-backend-Prolog-compiler">backend Prolog compiler</dt><dd><p>The Prolog compiler that is used to host and run Logtalk and that is
called for compiling the intermediate Prolog code generated by the
Logtalk compiler when compiling source files.</p>
</dd>
<dt id="term-built-in-method">built-in method</dt><dd><p>A predefined <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> that can be called from within any object
or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>. I.e. built-in methods are built-in object and
category predicates. Built-in methods cannot be redefined.</p>
</dd>
<dt id="term-built-in-predicate">built-in predicate</dt><dd><p>A predefined predicate that can be called from anywhere. Built-in
predicates can be redefined within objects and
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>.</p>
</dd>
<dt id="term-category">category</dt><dd><p>A set of predicates directives and clauses that can be (virtually)
imported by any object. Categories support composing objects using
fine-grained units of code reuse and also <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> of
existing objects. A category should be functionally-cohesive,
defining a single functionality.</p>
</dd>
<dt id="term-class">class</dt><dd><p>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> that specializes another object, interpreted as its
superclass. Classes define the common predicates of a set of objects
that instantiates it. An object can also be interpreted as a class
when it instantiates itself.</p>
</dd>
<dt id="term-closed-world-assumption">closed-world assumption</dt><dd><p>The assumption that what cannot be proved true is false. Therefore,
sending a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> corresponding to a <em>declared</em> but not <em>defined</em>
predicate, or calling a declared predicate with no clauses, fails.
But messages or calls to undeclared predicates generate an error.</p>
</dd>
<dt id="term-closure">closure</dt><dd><p>A callable term (i.e. an atom or a compound term) passed to a
<a class="reference internal" href="#term-meta-predicate"><span class="xref std std-term">meta-predicate</span></a> call where it is extended with additional
arguments to form a goal called by the meta-predicate.</p>
</dd>
<dt id="term-coinductive-predicate">coinductive predicate</dt><dd><p>A predicate whose calls are proved using greatest fixed point
semantics. Coinductive predicates allows reasoning about
infinite rational entities such as cyclic terms and ω-automata.</p>
</dd>
<dt id="term-complementing-category">complementing category</dt><dd><p>A category used for <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> an existing object (or a
set of objects).</p>
</dd>
<dt id="term-component">component</dt><dd><p>A unique atom or compound term template identifying a library, tool,
application, or application sub-system. Component names are notably
used by the message printing and question asking mechanisms. Compound
terms are used instead of atoms when parameterization is required.</p>
</dd>
<dt id="term-directive">directive</dt><dd><p>A source file term that affects the interpretation of source code.
Directives use the <code class="docutils literal notranslate"><span class="pre">(:-)/1</span></code> prefix operator as functor.</p>
</dd>
<dt id="term-doclet-file">doclet file</dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to generate documentation
for e.g. a <a class="reference internal" href="#term-library"><span class="xref std std-term">library</span></a> or an application.</p>
</dd>
<dt id="term-doclet-object">doclet object</dt><dd><p>An object specifying the steps necessary to (re)generate the API
documentation for a project. See the
<a class="reference external" href="https://github.com/LogtalkDotOrg/logtalk3/tree/master/tools/doclet/NOTES.md">doclet</a>
and <a class="reference external" href="https://github.com/LogtalkDotOrg/logtalk3/tree/master/tools/lgtdoc/NOTES.md">lgtdoc</a>
tools for details.</p>
</dd>
<dt id="term-dynamic-binding">dynamic binding</dt><dd><p>Runtime lookup of a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> and
<a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> to verify the validity of a
<a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>) and find the
predicate definition that will be used to answer the message (or the
super call). Also known as <em>late binding</em>. See also <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a>.</p>
</dd>
<dt id="term-dynamic-entity">dynamic entity</dt><dd><p>See <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a>.</p>
</dd>
<dt id="term-early-binding">early binding</dt><dd><p>See <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a>.</p>
</dd>
<dt id="term-encapsulation">encapsulation</dt><dd><p>The hiding of an object implementation. This promotes software reuse
by isolating the object clients from its implementation details.
Encapsulation is enforced in Logtalk by using
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">predicate scope directives</span></a>.</p>
</dd>
<dt id="term-entity">entity</dt><dd><p>Generic name for Logtalk compilation units: <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>,
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>, and <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocols</span></a>.
Entities share a single namespace (i.e. entity
<a class="reference internal" href="#term-identity"><span class="xref std std-term">identifiers</span></a> must be unique) and can be static (the
default) or dynamic. Static entities are defined in source files.
Dynamic entities can be created and abolished at runtime using the
language built-in predicates.</p>
</dd>
<dt id="term-entity-directive">entity directive</dt><dd><p>A directive that affects how Logtalk entities (<a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>,
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>, or <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocols</span></a>) are
used or compiled.</p>
</dd>
<dt id="term-event">event</dt><dd><p>The sending of a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to an object. An event can be
expressed as an ordered tuple: <code class="docutils literal notranslate"><span class="pre">(Event,</span> <span class="pre">Object,</span> <span class="pre">Message,</span> <span class="pre">Sender)</span></code>.
Logtalk distinguish between the sending of a message — <code class="docutils literal notranslate"><span class="pre">before</span></code>
event — and the return of control to the sender — <code class="docutils literal notranslate"><span class="pre">after</span></code> event.</p>
</dd>
<dt id="term-expansion-workflow">expansion workflow</dt><dd><p>A sequence of term-expansion or goal-expansion steps where each step is
usually defined using a <a class="reference internal" href="#term-hook-object"><span class="xref std std-term">hook object</span></a> or a combination of hook
objects.</p>
</dd>
<dt id="term-grammar-rule">grammar rule</dt><dd><p>An alternative notation for predicates used to parse or generate
sentences on some language. This notation hides the arguments used to
pass the sequences of tokens being processed, thus simplifying the
representation of grammars. Grammar rules are represented using as
functor the infix operator <code class="docutils literal notranslate"><span class="pre">(--&gt;)/2</span></code> instead of the <code class="docutils literal notranslate"><span class="pre">(:-)/2</span></code>
operator used with predicate clauses.</p>
</dd>
<dt id="term-grammar-rule-non-terminal">grammar rule non-terminal</dt><dd><p>A syntactic category of words or phrases. A non-terminal is
identified by its <em>non-terminal indicator</em>, i.e. by its name and
number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>.</p>
</dd>
<dt id="term-grammar-rule-terminal">grammar rule terminal</dt><dd><p>A word or basic symbol of a language.</p>
</dd>
<dt id="term-hook-object">hook object</dt><dd><p>An object, implementing the <a class="reference external" href="../docs/expanding_0.html#expanding-0" title="(in Logtalk APIs v3.39.0)"><span class="xref std std-ref">expanding</span></a> built-in
protocol, defining term- and goal-expansion predicates, used in the
compilation of Logtalk or Prolog source files. A hook object can be
specified using the <a class="reference internal" href="userman/programming.html#flag-hook"><span class="std std-ref">hook</span></a> flag. It can also
be specified using a <a class="reference internal" href="refman/directives/set_logtalk_flag_2.html#directives-set-logtalk-flag-2"><span class="std std-ref">set_logtalk_flag/2</span></a> directive in
the source files to be expanded.</p>
</dd>
<dt id="term-hook-predicate">hook predicate</dt><dd><p>A predicate, usually declared <a class="reference internal" href="#term-multifile-predicate"><span class="xref std std-term">multifile</span></a>,
that allows the user to customize another predicate or provide
alternative definitions for a default predicate definition.</p>
</dd>
<dt id="term-hot-patching">hot patching</dt><dd><p>The act of fixing entity directives and predicates or adding new
entity directives and predicates to loaded entities in a running
application without requiring access to the entities source code
or restarting the application.</p>
</dd>
<dt id="term-identity">identity</dt><dd><p>Property of an entity that distinguishes it from every other entity.
The identifier of an entity is its functor (i.e. its name and arity),
which must be unique. Object and <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> identifiers can be
atoms or compound terms. Protocol identities must be atoms. All Logtalk
entities (objects, protocols, and categories) share the same namespace.</p>
</dd>
<dt id="term-inheritance">inheritance</dt><dd><p>An entity inherits predicate directives and clauses from related
entities. In the particular case of objects, when an object extends
other object, we have prototype-based inheritance. When an object
specializes or instantiates another object, we have class-based
inheritance. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a>,
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a>, and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-instance">instance</dt><dd><p>An object that instantiates one another object, interpreted as its
<a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>. An object may instantiate multiple objects (also known
as multiple instantiation).</p>
</dd>
<dt id="term-instantiation">instantiation</dt><dd><p>The process of creating a new class instance. In Logtalk, this does
not necessarily imply dynamic creation of an object at runtime; an
instance may also be defined as a static object in a source file.</p>
</dd>
<dt id="term-interface">interface</dt><dd><p>See <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocol</span></a>.</p>
</dd>
<dt id="term-lambda-expression">lambda expression</dt><dd><p>A compound term that can be used in place of a goal or <a class="reference internal" href="#term-closure"><span class="xref std std-term">closure</span></a>
meta-argument and that abstracts a <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> by
listing its variables and a callable term that implements the
definition. Lambda expressions help avoiding the need of naming and
defining auxiliary predicates.</p>
</dd>
<dt id="term-lambda-free-variable">lambda free variable</dt><dd><p>A variable that is global to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All
used global variables must be explicitly listed in a lambda
expression.</p>
</dd>
<dt id="term-lambda-parameter">lambda parameter</dt><dd><p>A term (usually a variable or a non-ground compound term) that is
local to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All lambda parameters must
be explicitly enumerated in a lambda expression.</p>
</dd>
<dt id="term-late-binding">late binding</dt><dd><p>See <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.</p>
</dd>
<dt id="term-library">library</dt><dd><p>A directory containing source files. See also <a class="reference internal" href="#term-library-alias"><span class="xref std std-term">library alias</span></a>
and <a class="reference internal" href="#term-library-notation"><span class="xref std std-term">library notation</span></a>.</p>
</dd>
<dt id="term-library-alias">library alias</dt><dd><p>An atom that can be used as an alias for a <a class="reference internal" href="#term-library"><span class="xref std std-term">library</span></a> full
path. Library aliases and their corresponding paths can be defined
using the <a class="reference internal" href="refman/predicates/logtalk_library_path_2.html#predicates-logtalk-library-path-2"><span class="std std-ref">logtalk_library_path/2</span></a> predicate. See
also <a class="reference internal" href="#term-library-notation"><span class="xref std std-term">library notation</span></a>.</p>
</dd>
<dt id="term-library-notation">library notation</dt><dd><p>A compound term where the name is a <a class="reference internal" href="#term-library-alias"><span class="xref std std-term">library alias</span></a> and the
single argument is a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> relative path. Use of
library notation simplifies compiling and loading source files and
can make an application easily relocatable by defining an alias for
the root directory of the application files.</p>
</dd>
<dt id="term-loader-file">loader file</dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load a set of
source files.</p>
</dd>
<dt id="term-local-predicate">local predicate</dt><dd><p>A predicate that is defined in an object (or in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>)
but that is not listed in a
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>. These predicates
behave like private predicates but are invisible to the reflection
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in methods</span></a>. Local predicates are
usually auxiliary predicates and only relevant to the entity where
they are defined.</p>
</dd>
<dt id="term-message">message</dt><dd><p>A query sent to an object. In logical terms, a message can be seen as
a request for proof construction using an object database and the
databases of related entities.</p>
</dd>
<dt id="term-message-lookup">message lookup</dt><dd><p>Sending a message to an object requires a lookup for the
<a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a>, to check if the message is within the
scope of the sender, and a lookup for the <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a>
that is going to be called to answer the message. Message lookup can
occur at <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">compile</span></a> time or at <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">runtime</span></a>.</p>
</dd>
<dt id="term-message-to-self">message to self</dt><dd><p>A message sent to the object that received the original message under
processing. Messages to self require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> as the
value of self is only know at runtime.</p>
</dd>
<dt id="term-meta-argument">meta-argument</dt><dd><p>A predicate argument that is called as a goal, used as a <a class="reference internal" href="#term-closure"><span class="xref std std-term">closure</span></a>
to construct a goal that will be called, or that is handled in a
way that requires awareness of the predicate calling context.</p>
</dd>
<dt id="term-meta-interpreter">meta-interpreter</dt><dd><p>A program capable of running other programs written in the same
language.</p>
</dd>
<dt id="term-meta-predicate">meta-predicate</dt><dd><p>A predicate with one or more <a class="reference internal" href="#term-meta-argument"><span class="xref std std-term">meta-arguments</span></a>.
For example, <a class="reference internal" href="refman/methods/call_N.html#methods-call-n"><span class="std std-ref">call/1-N</span></a> and <a class="reference internal" href="refman/methods/findall_3.html#methods-findall-3"><span class="std std-ref">findall/3</span></a> are
built-in meta-predicates.</p>
</dd>
<dt id="term-metaclass">metaclass</dt><dd><p>The <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> of a class, when interpreted as an instance.
Metaclass instances are themselves classes. Metaclasses are optional,
except for the root class, and can be shared by several classes.</p>
</dd>
<dt id="term-method">method</dt><dd><p>The <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> used to answer a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> sent
to an object. Logtalk supports both <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a> and
<a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> to find which method to run to answer a message.</p>
</dd>
<dt id="term-module">module</dt><dd><p>A Prolog entity characterized by an identity and a set of predicate
directives and clauses. Prolog modules are usually static although
some Prolog systems allow the creation of dynamic modules at runtime.
Prolog modules can be seen as prototypes.</p>
</dd>
<dt id="term-monitor">monitor</dt><dd><p>Any object, implementing the <a class="reference external" href="../docs/monitoring_0.html#monitoring-0" title="(in Logtalk APIs v3.39.0)"><span class="xref std std-ref">monitoring</span></a>
built-in protocol, that is notified by the runtime when a spied event
occurs. The spied <a class="reference internal" href="#term-event"><span class="xref std std-term">events</span></a> can be set by the monitor
itself or by any other object.</p>
</dd>
<dt id="term-multifile-predicate">multifile predicate</dt><dd><p>A predicate whose clauses can be defined in multiple
<a class="reference internal" href="#term-entity"><span class="xref std std-term">entities</span></a> and <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source files</span></a>.
The object or category holding the directive without an entity
prefix qualifying the predicate holds the multifile predicate
<em>primary declaration</em>, which consists of both a
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a> and a
<a class="reference internal" href="refman/directives/multifile_1.html#directives-multifile-1"><span class="std std-ref">multifile/1</span></a> directive for the predicate.</p>
</dd>
<dt id="term-object">object</dt><dd><p>An entity characterized by an <a class="reference internal" href="#term-identity"><span class="xref std std-term">identity</span></a> and a set of predicate
directives and clauses. Logtalk objects can be either static or
dynamic. Logtalk objects can play the <em>role</em> of classes, instances,
or prototypes. The role or roles an object plays are a function of
its relations with other objects.</p>
</dd>
<dt id="term-object-database">object database</dt><dd><p>The set of predicates locally defined inside an object.</p>
</dd>
<dt id="term-parameter">parameter</dt><dd><p>An argument of a parametric object or a parametric category identifier.
Parameters are <em>logical variables</em> implicitly shared by all the entity
predicate clauses.</p>
</dd>
<dt id="term-parameter-variable">parameter variable</dt><dd><p>A variable used as parameter in a parametric object or a parametric
category using the syntax <code class="docutils literal notranslate"><span class="pre">_ParameterName_</span></code>. Occurrences of
parameter variables in entity clauses are implicitly unified with the
corresponding entity parameters.</p>
</dd>
<dt id="term-parametric-category">parametric category</dt><dd><p>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</p>
</dd>
<dt id="term-parametric-entity">parametric entity</dt><dd><p>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> whose <a class="reference internal" href="#term-identity"><span class="xref std std-term">identifier</span></a>
is a compound term possibly containing free variables that can be used
to parameterize the entity predicates. Parameters are <em>logical variables</em>
implicitly shared by all the entity clauses. Note that the identifier
of a parametric entity is its functor, irrespective of the possible
values of its arguments (e.g. <code class="docutils literal notranslate"><span class="pre">foo(bar)</span></code> and <code class="docutils literal notranslate"><span class="pre">foo(baz)</span></code> are
different parameterizations of the same parametric entity, <code class="docutils literal notranslate"><span class="pre">foo/1</span></code>).</p>
</dd>
<dt id="term-parametric-object">parametric object</dt><dd><p>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</p>
</dd>
<dt id="term-parametric-object-proxy">parametric object proxy</dt><dd><p>A compound term (usually represented as a plain Prolog fact) with
the same name and number of arguments as the identifier of a parametric
object.</p>
</dd>
<dt id="term-parent">parent</dt><dd><p>A prototype that is extended by another prototype.</p>
</dd>
<dt id="term-polymorphism">polymorphism</dt><dd><p>Different objects (and categories) can provide different implementations
of the same predicate. The predicate declaration can be inherited from a
common ancestor, also known as <em>subtype polymorphism</em>. Logtalk implements
<em>single dispatch</em> on the receiver of a message, which can be described as
<em>single-argument polymorphism</em>. As <a class="reference internal" href="#term-message-lookup"><span class="xref std std-term">message lookup</span></a> only uses the
predicate functor, multiple predicate implementations for different types
of arguments are possible, also known as <em>ad hoc polymorphism</em>.
<a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">Parametric objects and categories</span></a> enable
implementation of <em>parametric polymorphism</em> by using one of more
parameters to pass object identifiers that can be used to parameterize
generic predicate definitions.</p>
</dd>
<dt id="term-predicate">predicate</dt><dd><p>Predicates describe what is true about the application domain. A
predicate is identified by its <em>predicate indicator</em>, i.e. by its
name and number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>.
When predicates defined in <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a> or
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a> they are also referred to as
<a class="reference internal" href="#term-method"><span class="xref std std-term">methods</span></a>.</p>
</dd>
<dt id="term-predicate-alias">predicate alias</dt><dd><p>An alternative functor (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>) for a predicate. Predicate
aliases can be defined for any inherited predicate using the
<a class="reference internal" href="refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> directive and for predicates listed in
<a class="reference internal" href="refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> and <a class="reference internal" href="refman/directives/use_module_2.html#directives-use-module-2"><span class="std std-ref">use_module/2</span></a> directives.
Predicate aliases can be used to solve inheritance conflicts and
to improve code clarity by using alternative names that are more
meaningful in the calling context.</p>
</dd>
<dt id="term-predicate-declaration">predicate declaration</dt><dd><p>A predicate declaration is composed by a set of predicate directives,
which must include ar least a
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.</p>
</dd>
<dt id="term-predicate-definition">predicate definition</dt><dd><p>The set of clauses for a predicate, contained in an object or category.
Predicate definitions can be overriden or specialized in descendant
entities.</p>
</dd>
<dt id="term-predicate-directive">predicate directive</dt><dd><p>A directive that specifies a predicate property that affects how
predicates are called or compiled.</p>
</dd>
<dt id="term-predicate-scope-container">predicate scope container</dt><dd><p>The object that inherits a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> from an
imported <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> or an implemented <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocol</span></a>.</p>
</dd>
<dt id="term-predicate-scope-directive">predicate scope directive</dt><dd><p>A directive that declares a predicate by specifying its visibility
as <em>public</em>, <em>protected</em>, or <em>private</em>.</p>
</dd>
<dt id="term-predicate-shorthand">predicate shorthand</dt><dd><p>A predicate alias that defines a call template, possibly using a
different name, with a reduced number of arguments by hard-coding
the value of the omitted arguments in the original call template.
Predicate shorthands can be defined using <a class="reference internal" href="refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a>
and <a class="reference internal" href="refman/directives/use_module_2.html#directives-use-module-2"><span class="std std-ref">use_module/2</span></a> directives. They can be used to
simplify predicate calls and to ensure consistent call patterns
when some of the arguments always use the same fixed values in the
calling context.</p>
</dd>
<dt id="term-primary-predicate-declaration">primary predicate declaration</dt><dd><p>See <a class="reference internal" href="#term-multifile-predicate"><span class="xref std std-term">multifile predicate</span></a>.</p>
</dd>
<dt id="term-private-inheritance">private inheritance</dt><dd><p>All public and protected predicates are inherited as private
predicates. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a> and
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a>.</p>
</dd>
<dt id="term-private-predicate">private predicate</dt><dd><p>A predicate that can only be called from the object that contains
its <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.</p>
</dd>
<dt id="term-profiler">profiler</dt><dd><p>A program that collects data about other program performance.</p>
</dd>
<dt id="term-protected-inheritance">protected inheritance</dt><dd><p>All public predicates are inherited as protected. No scope change
for protected or private predicates. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a>
and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-protected-predicate">protected predicate</dt><dd><p>A predicate that can only be called from the object containing its
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a> or from an object
that inherits the predicate.</p>
</dd>
<dt id="term-protocol">protocol</dt><dd><p>An entity that contains
<a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declarations</span></a>. A predicate
is declared using a <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.
It may be further specified by additional predicate directives.
Protocols support the separation between interface and implementation,
can be implemented by both objects and categories, and can be extended
by other protocols. A protocol should be functionally-cohesive,
specifying a single functionality. Also known as <em>interface</em>.</p>
</dd>
<dt id="term-prototype">prototype</dt><dd><p>A self-describing object that may extend or be extended by other
objects. An object with no instantiation or specialization relations
with other objects is always interpreted as a prototype.</p>
</dd>
<dt id="term-public-inheritance">public inheritance</dt><dd><p>All inherited predicates maintain their declared scope. See also
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a> and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-public-predicate">public predicate</dt><dd><p>A predicate that can be called from any object.</p>
</dd>
<dt id="term-scratch-directory">scratch directory</dt><dd><p>The directory used to save the intermediate Prolog files generated by
the compiler when compiling <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source files</span></a>.</p>
</dd>
<dt id="term-self">self</dt><dd><p>The object that received the <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> under processing.</p>
</dd>
<dt id="term-sender">sender</dt><dd><p>An object that sends a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to other object. When a message
is sent from within a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, the <em>sender</em> is the object
importing the category.</p>
</dd>
<dt id="term-settings-file">settings file</dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a>, compiled and loaded automatically by default at
Logtalk startup, mainly defining default values for compiler flags that
override the defaults found on the backend Prolog compiler
<a class="reference internal" href="#term-adapter-file"><span class="xref std std-term">adapter files</span></a>.</p>
</dd>
<dt id="term-singleton-method">singleton method</dt><dd><p>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> defined in an <a class="reference internal" href="#term-instance"><span class="xref std std-term">instance</span></a> itself. Singleton
methods are supported in Logtalk and can also be found in other
object-oriented programming languages.</p>
</dd>
<dt id="term-source-file">source file</dt><dd><p>A text file defining Logtalk and/or Prolog code. Multiple Logtalk
entities may be defined in a single source file. Plain Prolog code
may be intermixed with Logtalk entity definitions. Depending on the
used <a class="reference internal" href="#term-backend-Prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>, the text encoding may be
specified using an <a class="reference internal" href="refman/directives/encoding_1.html#directives-encoding-1"><span class="std std-ref">encoding/1</span></a> directive as the
first term in the first line in the file.</p>
</dd>
<dt id="term-source-file-directive">source file directive</dt><dd><p>A directive that affects how a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> is compiled.</p>
</dd>
<dt id="term-specialization">specialization</dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> is specialized by defining a new class that inherit its
predicates and possibly add new ones.</p>
</dd>
<dt id="term-static-binding">static binding</dt><dd><p>Compile time lookup of a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> and
<a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> when compiling a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> sending
call (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>). Dynamic binding is used whenever static
binding is not possible (e.g. due to the predicate being dynamic or due
to lack of enough information at compilation time). Also known as <em>early
binding</em>. See also <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.</p>
</dd>
<dt id="term-static-entity">static entity</dt><dd><p>See <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a>.</p>
</dd>
<dt id="term-steadfastness">steadfastness</dt><dd><p>A predicate definition is <em>steadfast</em> when it still generates only
correct answers when called with unexpected arguments (notably,
bound output arguments). Typically, a predicate may not be steadfast
when output argument unifications can occur before a cut in a predicate
clause.</p>
</dd>
<dt id="term-subclass">subclass</dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that is a specialization, direct or indirectly, of
another class.</p>
</dd>
<dt id="term-super-call">super call</dt><dd><p>Call of an inherited (or imported) <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a>. Mainly
used when redefining an inherited (or imported) predicate to call the
overridden definition while making additional calls. Super calls preserve
<a class="reference internal" href="#term-self"><span class="xref std std-term">self</span></a> and may require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> if the predicate is
dynamic.</p>
</dd>
<dt id="term-superclass">superclass</dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> from which another class is a specialization
(directly or indirectly via another class). A class may have
multiple superclasses.</p>
</dd>
<dt id="term-synchronized-predicate">synchronized predicate</dt><dd><p>A synchronized predicate is protected by a mutex ensuring that, in
a multi-threaded application, it can only be called by a single
thread at a time.</p>
</dd>
<dt id="term-template-method">template method</dt><dd><p>See <a class="reference internal" href="#term-abstract-method"><span class="xref std std-term">abstract method</span></a>.</p>
</dd>
<dt id="term-tester-file">tester file</dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load and a run a set of
unit tests.</p>
</dd>
<dt id="term-this">this</dt><dd><p>The object that contains the predicate clause under execution. When
the predicate clause is contained in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, <em>this</em> is a
reference to the object importing the category for which the
predicate clause is being executed.</p>
</dd>
<dt id="term-threaded-engine">threaded engine</dt><dd><p>A computing thread running a goal whose solutions can be lazily and
concurrently computed and retrieved. A threaded engine also supports
a term queue that allows passing arbitrary terms to the engine. This
queue can be used to pass e.g. data and new goals to the engine.</p>
</dd>
<dt id="term-visible-predicate">visible predicate</dt><dd><p>A predicate that is within scope, a locally defined predicate, a
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in method</span></a>, a Logtalk built-in predicate, or a Prolog
built-in predicate.</p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bibliography.html" class="btn btn-neutral float-right" title="Bibliography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="libraries/zippers.html" class="btn btn-neutral float-left" title="zippers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1998-2020, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>