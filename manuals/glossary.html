<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Glossary &mdash; The Logtalk Handbook v3.81.0-b01 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=396eccfe" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=9456dd46"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="xml_parser" href="contributions/xml_parser.html" />
   
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            The Logtalk Handbook
              <img src="_static/logtalk.gif" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.81.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userman/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="devtools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="libraries/index.html">Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="ports/index.html">Ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributions/index.html">Contributions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

    <p class="caption"><span class="caption-text">External Contents</span></p>
    <ul>
    <li class="toctree-l1"><a class="reference internal" href="../docs/index.html">APIs</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://logtalk.org">Logtalk website</a></li>
    <li class="toctree-l1"><a class="reference internal" href="https://github.com/LogtalkDotOrg/logtalk3">GitHub repo</a></li>
    </ul>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Logtalk Handbook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Glossary</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/glossary.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="glossary">
<h1>Glossary<a class="headerlink" href="#glossary" title="Link to this heading"></a></h1>
<dl class="simple glossary">
<dt id="term-abstract-class">abstract class<a class="headerlink" href="#term-abstract-class" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that cannot be instantiated by sending it a message.
Usually used to contain common predicates that are inherited by other
classes.</p>
</dd>
<dt id="term-abstract-method">abstract method<a class="headerlink" href="#term-abstract-method" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> implementing an algorithm whose step corresponds
to calls to methods defined in the descendants of the object (or
<a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>) containing it.</p>
</dd>
<dt id="term-adapter-file">adapter file<a class="headerlink" href="#term-adapter-file" title="Link to this term"></a></dt><dd><p>A Prolog source file defining a minimal abstraction layer between the
Logtalk compiler/runtime and a specific <a class="reference internal" href="#term-backend-Prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>.</p>
</dd>
<dt id="term-ancestor">ancestor<a class="headerlink" href="#term-ancestor" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> or a parent <a class="reference internal" href="#term-prototype"><span class="xref std std-term">prototype</span></a> that contributes (via
inheritance) to the definition of an object. For class-based hierarchies,
the ancestors of an instance are its class(es) and all the superclasses
of its class(es). For prototype-based hierarchies, the ancestors of
a prototype are its parent(s) and the ancestors of its parent(s).</p>
</dd>
<dt id="term-backend-Prolog-compiler">backend Prolog compiler<a class="headerlink" href="#term-backend-Prolog-compiler" title="Link to this term"></a></dt><dd><p>The Prolog compiler that is used to host and run Logtalk and that is
called for compiling the intermediate Prolog code generated by the
Logtalk compiler when compiling source files.</p>
</dd>
<dt id="term-built-in-method">built-in method<a class="headerlink" href="#term-built-in-method" title="Link to this term"></a></dt><dd><p>A predefined <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> that can be called from within any object
or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>. I.e. built-in methods are built-in object and
category predicates. Built-in methods cannot be redefined.</p>
</dd>
<dt id="term-built-in-predicate">built-in predicate<a class="headerlink" href="#term-built-in-predicate" title="Link to this term"></a></dt><dd><p>A predefined predicate that can be called from anywhere. Built-in
predicates can be redefined within <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a> and
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>.</p>
</dd>
<dt id="term-category">category<a class="headerlink" href="#term-category" title="Link to this term"></a></dt><dd><p>A set of <a class="reference internal" href="#term-predicate-directive"><span class="xref std std-term">predicates directives</span></a> and
clauses that can be (virtually) imported by any object. Categories
support composing objects using fine-grained units of code reuse
and also <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> of existing objects. A category
should be functionally-cohesive, defining a single functionality.</p>
</dd>
<dt id="term-class">class<a class="headerlink" href="#term-class" title="Link to this term"></a></dt><dd><p>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> that specializes another object, interpreted as its
superclass. A class define the common predicates of a set of objects
that instantiates it. An object can also be interpreted as a class
when it instantiates itself.</p>
</dd>
<dt id="term-closed-world-assumption">closed-world assumption<a class="headerlink" href="#term-closed-world-assumption" title="Link to this term"></a></dt><dd><p>The assumption that what cannot be proved true is false. Therefore,
sending a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> corresponding to a <em>declared</em> but not <em>defined</em>
predicate, or calling a declared predicate with no clauses, fails.
But messages or calls to undeclared predicates generate an error.</p>
</dd>
<dt id="term-closure">closure<a class="headerlink" href="#term-closure" title="Link to this term"></a></dt><dd><p>A callable term (i.e. an atom or a compound term) passed to a
<a class="reference internal" href="#term-meta-predicate"><span class="xref std std-term">meta-predicate</span></a> call where it is extended with additional
arguments to form a goal called by the meta-predicate.</p>
</dd>
<dt id="term-coinductive-predicate">coinductive predicate<a class="headerlink" href="#term-coinductive-predicate" title="Link to this term"></a></dt><dd><p>A predicate whose calls are proved using greatest fixed point
semantics. Coinductive predicates allows reasoning about
infinite rational entities such as cyclic terms and ω-automata.</p>
</dd>
<dt id="term-complementing-category">complementing category<a class="headerlink" href="#term-complementing-category" title="Link to this term"></a></dt><dd><p>A category used for <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> an existing object (or a
set of objects).</p>
</dd>
<dt id="term-component">component<a class="headerlink" href="#term-component" title="Link to this term"></a></dt><dd><p>A unique atom or compound term template identifying a library, tool,
application, or application sub-system. Component names are notably
used by the message printing and question asking mechanisms. Compound
terms are used instead of atoms when parameterization is required.</p>
</dd>
<dt id="term-directive">directive<a class="headerlink" href="#term-directive" title="Link to this term"></a></dt><dd><p>A source file term that affects the interpretation of source code.
Directives use the <code class="docutils literal notranslate"><span class="pre">(:-)/1</span></code> prefix operator as functor.</p>
</dd>
<dt id="term-discontiguous-predicate">discontiguous predicate<a class="headerlink" href="#term-discontiguous-predicate" title="Link to this term"></a></dt><dd><p>A predicate whose clauses are not contiguous in a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a>.
I.e. a predicate whose clauses are mixed with clauses for other
predicates.</p>
</dd>
<dt id="term-doclet-file">doclet file<a class="headerlink" href="#term-doclet-file" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to generate documentation
for e.g. a <a class="reference internal" href="#term-library"><span class="xref std std-term">library</span></a> or an application.</p>
</dd>
<dt id="term-doclet-object">doclet object<a class="headerlink" href="#term-doclet-object" title="Link to this term"></a></dt><dd><p>An object specifying the steps necessary to (re)generate the API
documentation for a project. See the <a class="reference internal" href="devtools/doclet.html"><span class="doc">doclet</span></a>
and <a class="reference internal" href="devtools/lgtdoc.html"><span class="doc">lgtdoc</span></a> tools for details.</p>
</dd>
<dt id="term-dynamic-binding">dynamic binding<a class="headerlink" href="#term-dynamic-binding" title="Link to this term"></a></dt><dd><p>Runtime lookup of a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> and
<a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> to verify the validity of a
<a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>) and find the
predicate definition that will be used to answer the message (or the
super call). Also known as <em>late binding</em>. See also <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a>.</p>
</dd>
<dt id="term-dynamic-entity">dynamic entity<a class="headerlink" href="#term-dynamic-entity" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a>.</p>
</dd>
<dt id="term-dynamic-predicate">dynamic predicate<a class="headerlink" href="#term-dynamic-predicate" title="Link to this term"></a></dt><dd><p>A predicate whose clauses can be dynamically added or retracted at
runtime.</p>
</dd>
<dt id="term-early-binding">early binding<a class="headerlink" href="#term-early-binding" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a>.</p>
</dd>
<dt id="term-encapsulation">encapsulation<a class="headerlink" href="#term-encapsulation" title="Link to this term"></a></dt><dd><p>The hiding of an object implementation. This promotes software reuse
by isolating the object clients from its implementation details.
Encapsulation is enforced in Logtalk by using
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">predicate scope directives</span></a>.</p>
</dd>
<dt id="term-entity">entity<a class="headerlink" href="#term-entity" title="Link to this term"></a></dt><dd><p>Generic name for Logtalk compilation units: <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>,
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>, and <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocols</span></a>.
Entities share a single namespace (i.e. entity
<a class="reference internal" href="#term-identity"><span class="xref std std-term">identifiers</span></a> must be unique) and can be static (the
default) or dynamic. Static entities are defined in source files.
Dynamic entities can also be defined in source files but are usually
created and abolished at runtime using the language built-in predicates.</p>
</dd>
<dt id="term-entity-alias">entity alias<a class="headerlink" href="#term-entity-alias" title="Link to this term"></a></dt><dd><p>An alternative name for an entity. Entity aliases can be defined using
the <a class="reference internal" href="refman/directives/uses_1.html#directives-uses-1"><span class="std std-ref">uses/1</span></a> and <a class="reference internal" href="refman/directives/use_module_1.html#directives-use-module-1"><span class="std std-ref">use_module/1</span></a> directives.
Entity aliases can be used to improve code clarity by using alternative
names that are more meaningful in the calling context, to bind parametric
entity parameters, and to simplify experimenting with alternative entities
implementing the same protocol.</p>
</dd>
<dt id="term-entity-directive">entity directive<a class="headerlink" href="#term-entity-directive" title="Link to this term"></a></dt><dd><p>A directive that affects how Logtalk <a class="reference internal" href="#term-entity"><span class="xref std std-term">entities</span></a> are
used or compiled.</p>
</dd>
<dt id="term-event">event<a class="headerlink" href="#term-event" title="Link to this term"></a></dt><dd><p>The sending of a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to an object. An event can be
expressed as an ordered tuple: <code class="docutils literal notranslate"><span class="pre">(Event,</span> <span class="pre">Object,</span> <span class="pre">Message,</span> <span class="pre">Sender)</span></code>.
Logtalk distinguish between the sending of a message — <code class="docutils literal notranslate"><span class="pre">before</span></code>
event — and the return of control to the sender — <code class="docutils literal notranslate"><span class="pre">after</span></code> event.</p>
</dd>
<dt id="term-expansion-workflow">expansion workflow<a class="headerlink" href="#term-expansion-workflow" title="Link to this term"></a></dt><dd><p>A sequence of term-expansion or goal-expansion steps where each step is
usually defined using a <a class="reference internal" href="#term-hook-object"><span class="xref std std-term">hook object</span></a> or a combination of hook
objects.</p>
</dd>
<dt id="term-grammar-rule">grammar rule<a class="headerlink" href="#term-grammar-rule" title="Link to this term"></a></dt><dd><p>An alternative notation for predicates used to parse or generate
sentences on some language. This notation hides the arguments used to
pass the sequences of tokens being processed, thus simplifying the
representation of grammars. Grammar rules are represented using as
functor the infix operator <code class="docutils literal notranslate"><span class="pre">(--&gt;)/2</span></code> instead of the <code class="docutils literal notranslate"><span class="pre">(:-)/2</span></code>
operator used with predicate clauses.</p>
</dd>
<dt id="term-grammar-rule-non-terminal">grammar rule non-terminal<a class="headerlink" href="#term-grammar-rule-non-terminal" title="Link to this term"></a></dt><dd><p>A syntactic category of words or phrases. A non-terminal is
identified by its <em>non-terminal indicator</em>, i.e. by its name and
number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>.</p>
</dd>
<dt id="term-grammar-rule-terminal">grammar rule terminal<a class="headerlink" href="#term-grammar-rule-terminal" title="Link to this term"></a></dt><dd><p>A word or basic symbol of a language.</p>
</dd>
<dt id="term-homoiconic">homoiconic<a class="headerlink" href="#term-homoiconic" title="Link to this term"></a></dt><dd><p>A property of programming languages where <em>code</em> and <em>data</em> use the
same representation. Logtalk (and Prolog) are examples of homoiconic
programming languages. A Logtalk program is a set of terms (clauses
and directives) that can be handled as <em>data</em> by e.g. the term-expansion
mechanism.</p>
</dd>
<dt id="term-hook-object">hook object<a class="headerlink" href="#term-hook-object" title="Link to this term"></a></dt><dd><p>An object, implementing the <a class="reference external" href="../docs/expanding_0.html#expanding-0" title="(in Logtalk APIs v3.81.0)"><span class="xref std std-ref">expanding</span></a> built-in
protocol, defining term- and goal-expansion predicates, used in the
compilation of Logtalk or Prolog source files. A hook object can be
specified using the <a class="reference internal" href="userman/programming.html#flag-hook"><span class="std std-ref">hook</span></a> flag. It can also
be specified using a <a class="reference internal" href="refman/directives/set_logtalk_flag_2.html#directives-set-logtalk-flag-2"><span class="std std-ref">set_logtalk_flag/2</span></a> directive in
the source files to be expanded.</p>
</dd>
<dt id="term-hook-predicate">hook predicate<a class="headerlink" href="#term-hook-predicate" title="Link to this term"></a></dt><dd><p>A predicate, usually declared <a class="reference internal" href="#term-multifile-predicate"><span class="xref std std-term">multifile</span></a>,
that allows the user to customize another predicate or provide
alternative definitions for a default predicate definition.</p>
</dd>
<dt id="term-hot-patching">hot patching<a class="headerlink" href="#term-hot-patching" title="Link to this term"></a></dt><dd><p>The act of fixing <a class="reference internal" href="#term-entity-directive"><span class="xref std std-term">entity directives</span></a> and
predicates or adding new entity directives and predicates to loaded
<a class="reference internal" href="#term-entity"><span class="xref std std-term">entities</span></a> in a running application without requiring
access to the entities source code or restarting the application.
Achieved using <a class="reference internal" href="#term-complementing-category"><span class="xref std std-term">complementing categories</span></a>.</p>
</dd>
<dt id="term-identity">identity<a class="headerlink" href="#term-identity" title="Link to this term"></a></dt><dd><p>Property of an <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a> that distinguishes it from every other entity.
The identifier of an entity is its functor (i.e. its name and arity),
which must be unique. Object and <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> identifiers can be
atoms or compound terms. Protocol identities must be atoms. All Logtalk
entities (objects, protocols, and categories) share the same namespace.</p>
</dd>
<dt id="term-inheritance">inheritance<a class="headerlink" href="#term-inheritance" title="Link to this term"></a></dt><dd><p>An <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a> inherits <a class="reference internal" href="#term-predicate-directive"><span class="xref std std-term">predicates directives</span></a>
and clauses from related entities. In the particular case of objects,
when an object extends other object, we have prototype-based inheritance.
When an object specializes or instantiates another object, we have
class-based inheritance. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a>,
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a>, and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-instance">instance<a class="headerlink" href="#term-instance" title="Link to this term"></a></dt><dd><p>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> that instantiates another object, interpreted as
its <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>. An object may instantiate multiple objects (also
known as multiple instantiation).</p>
</dd>
<dt id="term-instantiation">instantiation<a class="headerlink" href="#term-instantiation" title="Link to this term"></a></dt><dd><p>The process of creating a new <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> <a class="reference internal" href="#term-instance"><span class="xref std std-term">instance</span></a>. In Logtalk,
this does not necessarily imply dynamic creation of an object at runtime;
an instance may also be defined as a static object in a source file.</p>
</dd>
<dt id="term-interface">interface<a class="headerlink" href="#term-interface" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocol</span></a>.</p>
</dd>
<dt id="term-lambda-expression">lambda expression<a class="headerlink" href="#term-lambda-expression" title="Link to this term"></a></dt><dd><p>A compound term that can be used in place of a goal or <a class="reference internal" href="#term-closure"><span class="xref std std-term">closure</span></a>
meta-argument and that abstracts a <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> by
listing its variables and a callable term that implements the
definition. Lambda expressions help avoiding the need of naming and
defining auxiliary predicates.</p>
</dd>
<dt id="term-lambda-free-variable">lambda free variable<a class="headerlink" href="#term-lambda-free-variable" title="Link to this term"></a></dt><dd><p>A variable that is global to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All
used global variables must be explicitly listed in a lambda
expression for well-defined semantics.</p>
</dd>
<dt id="term-lambda-parameter">lambda parameter<a class="headerlink" href="#term-lambda-parameter" title="Link to this term"></a></dt><dd><p>A term (usually a variable or a non-ground compound term) that is
local to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All lambda parameters must
be explicitly enumerated in a lambda expression for well-defined
semantics.</p>
</dd>
<dt id="term-late-binding">late binding<a class="headerlink" href="#term-late-binding" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.</p>
</dd>
<dt id="term-library">library<a class="headerlink" href="#term-library" title="Link to this term"></a></dt><dd><p>A directory containing source files. See also <a class="reference internal" href="#term-library-alias"><span class="xref std std-term">library alias</span></a>
and <a class="reference internal" href="#term-library-notation"><span class="xref std std-term">library notation</span></a>.</p>
</dd>
<dt id="term-library-alias">library alias<a class="headerlink" href="#term-library-alias" title="Link to this term"></a></dt><dd><p>An atom that can be used as an alias for a <a class="reference internal" href="#term-library"><span class="xref std std-term">library</span></a> full
path. Library aliases and their corresponding paths can be defined
using the <a class="reference internal" href="refman/predicates/logtalk_library_path_2.html#predicates-logtalk-library-path-2"><span class="std std-ref">logtalk_library_path/2</span></a> predicate. See
also <a class="reference internal" href="#term-library-notation"><span class="xref std std-term">library notation</span></a>.</p>
</dd>
<dt id="term-library-notation">library notation<a class="headerlink" href="#term-library-notation" title="Link to this term"></a></dt><dd><p>A compound term where the name is a <a class="reference internal" href="#term-library-alias"><span class="xref std std-term">library alias</span></a> and the
single argument is a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> relative path. Use of
library notation simplifies compiling and loading source files and
can make an application easily relocatable by defining an alias for
the root directory of the application files.</p>
</dd>
<dt id="term-loader-file">loader file<a class="headerlink" href="#term-loader-file" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load a set of
source files (possibly with specific compiler flags) and any
library dependencies.</p>
</dd>
<dt id="term-local-predicate">local predicate<a class="headerlink" href="#term-local-predicate" title="Link to this term"></a></dt><dd><p>A predicate that is defined in an object (or in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>)
but that is not listed in a
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>. These predicates
behave like private predicates but are invisible to the reflection
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in methods</span></a>. Local predicates are
usually auxiliary predicates and only relevant to the entity where
they are defined.</p>
</dd>
<dt id="term-message">message<a class="headerlink" href="#term-message" title="Link to this term"></a></dt><dd><p>A query sent to an object. In logical terms, a message can be
interpreted as a request for proof construction using an object
database and the databases of related entities.</p>
</dd>
<dt id="term-message-lookup">message lookup<a class="headerlink" href="#term-message-lookup" title="Link to this term"></a></dt><dd><p>Sending a message to an object requires a lookup for the
<a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a>, to check if the message is within the
scope of the sender, and a lookup for the <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a>
that is going to be called to answer the message. Message lookup can
occur at <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">compile</span></a> time or at <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">runtime</span></a>.</p>
</dd>
<dt id="term-message-to-self">message to self<a class="headerlink" href="#term-message-to-self" title="Link to this term"></a></dt><dd><p>A message sent to the object that received the original message under
processing. Messages to self require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> as the
value of self is only know at runtime.</p>
</dd>
<dt id="term-meta-argument">meta-argument<a class="headerlink" href="#term-meta-argument" title="Link to this term"></a></dt><dd><p>A predicate argument that is called as a goal, used as a <a class="reference internal" href="#term-closure"><span class="xref std std-term">closure</span></a>
to construct a goal that will be called, or that is handled in a
way that requires awareness of the predicate calling context.</p>
</dd>
<dt id="term-meta-interpreter">meta-interpreter<a class="headerlink" href="#term-meta-interpreter" title="Link to this term"></a></dt><dd><p>A program capable of running other programs written in the same
language.</p>
</dd>
<dt id="term-meta-predicate">meta-predicate<a class="headerlink" href="#term-meta-predicate" title="Link to this term"></a></dt><dd><p>A predicate with one or more <a class="reference internal" href="#term-meta-argument"><span class="xref std std-term">meta-arguments</span></a>.
For example, <a class="reference internal" href="refman/methods/call_N.html#methods-call-n"><span class="std std-ref">call/1-N</span></a> and <a class="reference internal" href="refman/methods/findall_3.html#methods-findall-3"><span class="std std-ref">findall/3</span></a> are
built-in meta-predicates.</p>
</dd>
<dt id="term-meta-variable">meta-variable<a class="headerlink" href="#term-meta-variable" title="Link to this term"></a></dt><dd><p>A variable in a <a class="reference internal" href="#term-meta-argument"><span class="xref std std-term">meta-argument</span></a> position that is expected to be
unified with a goal or a closure at runtime.</p>
</dd>
<dt id="term-metaclass">metaclass<a class="headerlink" href="#term-metaclass" title="Link to this term"></a></dt><dd><p>The <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> of a class, when interpreted as an <a class="reference internal" href="#term-instance"><span class="xref std std-term">instance</span></a>.
Metaclass instances are themselves classes. Metaclasses are optional,
except for the root class, and can be shared by several classes.</p>
</dd>
<dt id="term-method">method<a class="headerlink" href="#term-method" title="Link to this term"></a></dt><dd><p>The <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> used to answer a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> sent
to an object. Logtalk supports both <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a> and
<a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> to find which method to run to answer a message.</p>
</dd>
<dt id="term-module">module<a class="headerlink" href="#term-module" title="Link to this term"></a></dt><dd><p>A Prolog entity characterized by an identity and a set of
<a class="reference internal" href="#term-predicate-directive"><span class="xref std std-term">predicates directives</span></a> and clauses.
Prolog modules are usually static although some Prolog systems
allow the creation of dynamic modules at runtime. Prolog modules
can be interpreted as prototypes.</p>
</dd>
<dt id="term-monitor">monitor<a class="headerlink" href="#term-monitor" title="Link to this term"></a></dt><dd><p>Any object, implementing the <a class="reference external" href="../docs/monitoring_0.html#monitoring-0" title="(in Logtalk APIs v3.81.0)"><span class="xref std std-ref">monitoring</span></a>
built-in protocol, that is notified by the runtime when a spied event
occurs. The spied <a class="reference internal" href="#term-event"><span class="xref std std-term">events</span></a> can be set by the monitor
itself or by any other object.</p>
</dd>
<dt id="term-multifile-predicate">multifile predicate<a class="headerlink" href="#term-multifile-predicate" title="Link to this term"></a></dt><dd><p>A predicate whose clauses can be defined in multiple
<a class="reference internal" href="#term-entity"><span class="xref std std-term">entities</span></a> and <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source files</span></a>.
The object or category holding the directive without an entity
prefix qualifying the predicate holds the multifile predicate
<em>primary declaration</em>, which consists of both a
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a> and a
<a class="reference internal" href="refman/directives/multifile_1.html#directives-multifile-1"><span class="std std-ref">multifile/1</span></a> directive for the predicate.</p>
</dd>
<dt id="term-naked-meta-variable">naked meta-variable<a class="headerlink" href="#term-naked-meta-variable" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-meta-variable"><span class="xref std std-term">meta-variable</span></a> used as the body of a predicate clause or
grammar rule or used in a cut-transparent argument of a control
construct. The “naked” designation highlights that the meta-variable
is not wrapped by <code class="docutils literal notranslate"><span class="pre">call/1</span></code> or <code class="docutils literal notranslate"><span class="pre">phrase//1</span></code> goals.</p>
</dd>
<dt id="term-object">object<a class="headerlink" href="#term-object" title="Link to this term"></a></dt><dd><p>An entity characterized by an <a class="reference internal" href="#term-identity"><span class="xref std std-term">identity</span></a> and a set of
<a class="reference internal" href="#term-predicate-directive"><span class="xref std std-term">predicates directives</span></a> and clauses.
Logtalk objects can be either static or dynamic. Logtalk objects
can play the <em>role</em> of classes, instances, or prototypes. The
role or roles an object plays are a function of its relations
with other objects.</p>
</dd>
<dt id="term-object-database">object database<a class="headerlink" href="#term-object-database" title="Link to this term"></a></dt><dd><p>The set of predicates locally defined inside an object.</p>
</dd>
<dt id="term-parameter">parameter<a class="headerlink" href="#term-parameter" title="Link to this term"></a></dt><dd><p>An argument of a parametric object or a parametric category identifier.
Parameters are <em>logical variables</em> implicitly shared by all the entity
predicate clauses.</p>
</dd>
<dt id="term-parameter-variable">parameter variable<a class="headerlink" href="#term-parameter-variable" title="Link to this term"></a></dt><dd><p>A variable used as parameter in a parametric object or a parametric
category using the syntax <code class="docutils literal notranslate"><span class="pre">_ParameterName_</span></code> (i.e. a variable whose
name stars and ends with an underscore). Parameter variables are
<em>logical variables</em> shared by all entity terms. Occurrences of parameter
variables in <a class="reference internal" href="#term-entity-directive"><span class="xref std std-term">entity directives</span></a> and clauses
are implicitly unified with the corresponding entity parameters.</p>
</dd>
<dt id="term-parametric-category">parametric category<a class="headerlink" href="#term-parametric-category" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</p>
</dd>
<dt id="term-parametric-entity">parametric entity<a class="headerlink" href="#term-parametric-entity" title="Link to this term"></a></dt><dd><p>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> whose <a class="reference internal" href="#term-identity"><span class="xref std std-term">identifier</span></a>
is a compound term possibly containing free variables that can be used
to parameterize the entity predicates. Parameters are <em>logical variables</em>
implicitly shared by all the entity clauses. Note that the identifier
of a parametric entity is its functor, irrespective of the possible
values of its arguments (e.g. <code class="docutils literal notranslate"><span class="pre">foo(bar)</span></code> and <code class="docutils literal notranslate"><span class="pre">foo(baz)</span></code> are
different parameterizations of the same parametric entity, <code class="docutils literal notranslate"><span class="pre">foo/1</span></code>).</p>
</dd>
<dt id="term-parametric-object">parametric object<a class="headerlink" href="#term-parametric-object" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</p>
</dd>
<dt id="term-parametric-object-proxy">parametric object proxy<a class="headerlink" href="#term-parametric-object-proxy" title="Link to this term"></a></dt><dd><p>A compound term (usually represented as a plain Prolog fact) with
the same name and number of arguments as the identifier of a parametric
object.</p>
</dd>
<dt id="term-parent">parent<a class="headerlink" href="#term-parent" title="Link to this term"></a></dt><dd><p>A prototype that is extended by another prototype.</p>
</dd>
<dt id="term-polymorphism">polymorphism<a class="headerlink" href="#term-polymorphism" title="Link to this term"></a></dt><dd><p>Different objects (and categories) can provide different implementations
of the same predicate. The predicate declaration can be inherited from a
common ancestor, also known as <em>subtype polymorphism</em>. Logtalk implements
<em>single dispatch</em> on the receiver of a message, which can be described as
<em>single-argument polymorphism</em>. As <a class="reference internal" href="#term-message-lookup"><span class="xref std std-term">message lookup</span></a> only uses the
predicate functor, multiple predicate implementations for different types
of arguments are possible, also known as <em>ad hoc polymorphism</em>.
<a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">Parametric objects and categories</span></a> enable
implementation of <em>parametric polymorphism</em> by using one of more
parameters to pass object identifiers that can be used to parameterize
generic predicate definitions.</p>
</dd>
<dt id="term-predicate">predicate<a class="headerlink" href="#term-predicate" title="Link to this term"></a></dt><dd><p>Predicates describe what is true about the application domain. A
predicate is identified by its <em>predicate indicator</em>, i.e. by its
name and number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>.
When predicates defined in <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a> or
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a> they are also referred to as
<a class="reference internal" href="#term-method"><span class="xref std std-term">methods</span></a>.</p>
</dd>
<dt id="term-predicate-alias">predicate alias<a class="headerlink" href="#term-predicate-alias" title="Link to this term"></a></dt><dd><p>An alternative functor (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>) for a predicate. Predicate
aliases can be defined for any inherited predicate using the
<a class="reference internal" href="refman/directives/alias_2.html#directives-alias-2"><span class="std std-ref">alias/2</span></a> directive and for predicates listed in
<a class="reference internal" href="refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a> and <a class="reference internal" href="refman/directives/use_module_2.html#directives-use-module-2"><span class="std std-ref">use_module/2</span></a> directives.
Predicate aliases can be used to solve inheritance conflicts and
to improve code clarity by using alternative names that are more
meaningful in the calling context.</p>
</dd>
<dt id="term-predicate-calling-context">predicate calling context<a class="headerlink" href="#term-predicate-calling-context" title="Link to this term"></a></dt><dd><p>The object or category from within a predicate is called (either
directly or using a control construct such as a message sending
control construct).</p>
</dd>
<dt id="term-predicate-declaration">predicate declaration<a class="headerlink" href="#term-predicate-declaration" title="Link to this term"></a></dt><dd><p>A predicate declaration is composed by a set of
<a class="reference internal" href="#term-predicate-directive"><span class="xref std std-term">predicates directives</span></a>, which must
include ar least a <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.</p>
</dd>
<dt id="term-predicate-definition">predicate definition<a class="headerlink" href="#term-predicate-definition" title="Link to this term"></a></dt><dd><p>The set of clauses for a predicate, contained in an object or category.
Predicate definitions can be overriden or specialized in descendant
entities.</p>
</dd>
<dt id="term-predicate-definition-context">predicate definition context<a class="headerlink" href="#term-predicate-definition-context" title="Link to this term"></a></dt><dd><p>The object or category that contains the definition (i.e. clauses)
for a predicate.</p>
</dd>
<dt id="term-predicate-directive">predicate directive<a class="headerlink" href="#term-predicate-directive" title="Link to this term"></a></dt><dd><p>A directive that specifies a predicate property that affects how
predicates are called or compiled.</p>
</dd>
<dt id="term-predicate-execution-context">predicate execution context<a class="headerlink" href="#term-predicate-execution-context" title="Link to this term"></a></dt><dd><p>The implicit arguments (including <a class="reference internal" href="#term-sender"><span class="xref std std-term">sender</span></a>, <a class="reference internal" href="#term-self"><span class="xref std std-term">self</span></a>,
and <a class="reference internal" href="#term-this"><span class="xref std std-term">this</span></a>) required for the correct execution of a
predicate call.</p>
</dd>
<dt id="term-predicate-scope-container">predicate scope container<a class="headerlink" href="#term-predicate-scope-container" title="Link to this term"></a></dt><dd><p>The object that inherits a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> from an
imported <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> or an implemented <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocol</span></a>.</p>
</dd>
<dt id="term-predicate-scope-directive">predicate scope directive<a class="headerlink" href="#term-predicate-scope-directive" title="Link to this term"></a></dt><dd><p>A directive that declares a predicate by specifying its visibility
as <em>public</em>, <em>protected</em>, or <em>private</em>.</p>
</dd>
<dt id="term-predicate-shorthand">predicate shorthand<a class="headerlink" href="#term-predicate-shorthand" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-predicate-alias"><span class="xref std std-term">predicate alias</span></a> that defines a call template, possibly using
a different name, with a reduced number of arguments by hard-coding
the value of the omitted arguments in the original call template.
Predicate shorthands can be defined using <a class="reference internal" href="refman/directives/uses_2.html#directives-uses-2"><span class="std std-ref">uses/2</span></a>
and <a class="reference internal" href="refman/directives/use_module_2.html#directives-use-module-2"><span class="std std-ref">use_module/2</span></a> directives. They can be used to
simplify predicate calls and to ensure consistent call patterns
when some of the arguments always use the same fixed values in the
calling context.</p>
</dd>
<dt id="term-primary-predicate-declaration">primary predicate declaration<a class="headerlink" href="#term-primary-predicate-declaration" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-multifile-predicate"><span class="xref std std-term">multifile predicate</span></a>.</p>
</dd>
<dt id="term-private-inheritance">private inheritance<a class="headerlink" href="#term-private-inheritance" title="Link to this term"></a></dt><dd><p>All public and protected predicates are inherited as private
predicates. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a> and
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a>.</p>
</dd>
<dt id="term-private-predicate">private predicate<a class="headerlink" href="#term-private-predicate" title="Link to this term"></a></dt><dd><p>A predicate that can only be called from the object that contains
its <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.</p>
</dd>
<dt id="term-profiler">profiler<a class="headerlink" href="#term-profiler" title="Link to this term"></a></dt><dd><p>A program that collects data about other program performance.</p>
</dd>
<dt id="term-protected-inheritance">protected inheritance<a class="headerlink" href="#term-protected-inheritance" title="Link to this term"></a></dt><dd><p>All public predicates are inherited as protected. No scope change
for protected or private predicates. See also <a class="reference internal" href="#term-public-inheritance"><span class="xref std std-term">public inheritance</span></a>
and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-protected-predicate">protected predicate<a class="headerlink" href="#term-protected-predicate" title="Link to this term"></a></dt><dd><p>A predicate that can only be called from the object containing its
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a> or from an object
that inherits the predicate.</p>
</dd>
<dt id="term-protocol">protocol<a class="headerlink" href="#term-protocol" title="Link to this term"></a></dt><dd><p>An entity that contains
<a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declarations</span></a>. A predicate
is declared using a <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a>.
It may be further specified by additional predicate directives.
Protocols support the separation between interface and implementation,
can be implemented by both objects and categories, and can be extended
by other protocols. A protocol should be functionally-cohesive,
specifying a single functionality. Also known as <em>interface</em>.</p>
</dd>
<dt id="term-prototype">prototype<a class="headerlink" href="#term-prototype" title="Link to this term"></a></dt><dd><p>A self-describing object that may extend or be extended by other
objects. An object with no instantiation or specialization relations
with other objects is always interpreted as a prototype.</p>
</dd>
<dt id="term-public-inheritance">public inheritance<a class="headerlink" href="#term-public-inheritance" title="Link to this term"></a></dt><dd><p>All inherited predicates maintain their declared scope. See also
<a class="reference internal" href="#term-protected-inheritance"><span class="xref std std-term">protected inheritance</span></a> and <a class="reference internal" href="#term-private-inheritance"><span class="xref std std-term">private inheritance</span></a>.</p>
</dd>
<dt id="term-public-predicate">public predicate<a class="headerlink" href="#term-public-predicate" title="Link to this term"></a></dt><dd><p>A predicate that can be called from any object.</p>
</dd>
<dt id="term-scratch-directory">scratch directory<a class="headerlink" href="#term-scratch-directory" title="Link to this term"></a></dt><dd><p>The directory used to save the intermediate Prolog files generated by
the compiler when compiling <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source files</span></a>.</p>
</dd>
<dt id="term-self">self<a class="headerlink" href="#term-self" title="Link to this term"></a></dt><dd><p>The object that received the <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> under processing.</p>
</dd>
<dt id="term-sender">sender<a class="headerlink" href="#term-sender" title="Link to this term"></a></dt><dd><p>An object that sends a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to other object. When a message
is sent from within a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, the <em>sender</em> is the object
importing the category.</p>
</dd>
<dt id="term-settings-file">settings file<a class="headerlink" href="#term-settings-file" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a>, compiled and loaded automatically by default at
Logtalk startup, mainly defining default values for compiler flags that
override the defaults found on the backend Prolog compiler
<a class="reference internal" href="#term-adapter-file"><span class="xref std std-term">adapter files</span></a>.</p>
</dd>
<dt id="term-singleton-method">singleton method<a class="headerlink" href="#term-singleton-method" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> defined in an <a class="reference internal" href="#term-instance"><span class="xref std std-term">instance</span></a> itself. Singleton
methods are supported in Logtalk and can also be found in other
object-oriented programming languages.</p>
</dd>
<dt id="term-source-file">source file<a class="headerlink" href="#term-source-file" title="Link to this term"></a></dt><dd><p>A text file defining Logtalk and/or Prolog code. Multiple Logtalk
entities may be defined in a single source file. Plain Prolog code
may be intermixed with Logtalk entity definitions. Depending on the
used <a class="reference internal" href="#term-backend-Prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>, the text encoding may be
specified using an <a class="reference internal" href="refman/directives/encoding_1.html#directives-encoding-1"><span class="std std-ref">encoding/1</span></a> directive as the
first term in the first line in the file.</p>
</dd>
<dt id="term-source-file-directive">source file directive<a class="headerlink" href="#term-source-file-directive" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-directive"><span class="xref std std-term">directive</span></a> that affects how a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> is compiled.</p>
</dd>
<dt id="term-specialization">specialization<a class="headerlink" href="#term-specialization" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> is specialized by defining a new class that inherits its
predicates and possibly adds new ones.</p>
</dd>
<dt id="term-static-binding">static binding<a class="headerlink" href="#term-static-binding" title="Link to this term"></a></dt><dd><p>Compile time lookup of a <a class="reference internal" href="#term-predicate-declaration"><span class="xref std std-term">predicate declaration</span></a> and
<a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a> when compiling a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> sending
call (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>). Dynamic binding is used whenever static
binding is not possible (e.g. due to the predicate being dynamic or due
to lack of enough information at compilation time). Also known as <em>early
binding</em>. See also <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.</p>
</dd>
<dt id="term-static-entity">static entity<a class="headerlink" href="#term-static-entity" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-entity"><span class="xref std std-term">entity</span></a>.</p>
</dd>
<dt id="term-steadfastness">steadfastness<a class="headerlink" href="#term-steadfastness" title="Link to this term"></a></dt><dd><p>A predicate definition is <em>steadfast</em> when it still generates only
correct answers when called with unexpected arguments (notably,
bound output arguments). Typically, a predicate may not be steadfast
when output argument unifications can occur before a cut in a predicate
clause body.</p>
</dd>
<dt id="term-subclass">subclass<a class="headerlink" href="#term-subclass" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that is a specialization, direct or indirectly, of
another class. A class may have multiple subclasses.</p>
</dd>
<dt id="term-super-call">super call<a class="headerlink" href="#term-super-call" title="Link to this term"></a></dt><dd><p>Call of an inherited (or imported) <a class="reference internal" href="#term-predicate-definition"><span class="xref std std-term">predicate definition</span></a>. Mainly
used when redefining an inherited (or imported) predicate to call the
overridden definition while making additional calls. Super calls preserve
<a class="reference internal" href="#term-self"><span class="xref std std-term">self</span></a> and may require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> if the predicate is
dynamic.</p>
</dd>
<dt id="term-superclass">superclass<a class="headerlink" href="#term-superclass" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> from which another class is a specialization
(directly or indirectly via another class). A class may have
multiple superclasses.</p>
</dd>
<dt id="term-synchronized-predicate">synchronized predicate<a class="headerlink" href="#term-synchronized-predicate" title="Link to this term"></a></dt><dd><p>A synchronized predicate is protected by a mutex ensuring that, in
a multi-threaded application, it can only be called by a single
thread at a time.</p>
</dd>
<dt id="term-template-method">template method<a class="headerlink" href="#term-template-method" title="Link to this term"></a></dt><dd><p>See <a class="reference internal" href="#term-abstract-method"><span class="xref std std-term">abstract method</span></a>.</p>
</dd>
<dt id="term-tester-file">tester file<a class="headerlink" href="#term-tester-file" title="Link to this term"></a></dt><dd><p>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load and a run a set of
unit tests.</p>
</dd>
<dt id="term-this">this<a class="headerlink" href="#term-this" title="Link to this term"></a></dt><dd><p>The object that contains the predicate clause under execution. When
the predicate clause is contained in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, <em>this</em> is a
reference to the object importing the category for which the
predicate clause is being executed.</p>
</dd>
<dt id="term-threaded-engine">threaded engine<a class="headerlink" href="#term-threaded-engine" title="Link to this term"></a></dt><dd><p>A computing thread running a goal whose solutions can be lazily and
concurrently computed and retrieved. A threaded engine also supports
a term queue that allows passing arbitrary terms to the engine. This
queue can be used to pass e.g. data and new goals to the engine.</p>
</dd>
<dt id="term-top-level-interpreter-shorthand">top-level interpreter shorthand<a class="headerlink" href="#term-top-level-interpreter-shorthand" title="Link to this term"></a></dt><dd><p>Aliases for frequently used built-in predicates such as
<a class="reference internal" href="refman/predicates/logtalk_load_1.html#predicates-logtalk-load-1"><span class="std std-ref">logtalk_load/1</span></a> and <a class="reference internal" href="refman/predicates/logtalk_make_1.html#predicates-logtalk-make-1"><span class="std std-ref">logtalk_make/1</span></a>.
These shorthands are <strong>not</strong> part of the Logtalk language and must
only be used at the top-level interpreter.</p>
</dd>
<dt id="term-visible-predicate">visible predicate<a class="headerlink" href="#term-visible-predicate" title="Link to this term"></a></dt><dd><p>A predicate that is within scope, a locally defined predicate, a
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in method</span></a>, a Logtalk built-in predicate, or a Prolog
built-in predicate.</p>
</dd>
</dl>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="contributions/xml_parser.html" class="btn btn-neutral float-left" title="xml_parser" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bibliography.html" class="btn btn-neutral float-right" title="Bibliography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1998-2024, Paulo Moura.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>