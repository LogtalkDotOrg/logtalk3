

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Glossary &mdash; The Logtalk Handbook v3.23.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <!-- begin favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#355b95" />
    <meta name="theme-color" content="#ffffff" />
    <!-- end favicon -->
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="Support" href="faq/support.html" />
   

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> The Logtalk Handbook
          

          
          </a>

          
            
            
              <div class="version">
                3.23.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="userman/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="refman/index.html">Reference Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq/index.html">FAQ</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Logtalk Handbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Glossary</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/LogtalkDotOrg/logtalk3/blob/master/manuals/sources/glossary.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="glossary">
<h1>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h1>
<dl class="glossary docutils">
<dt id="term-abstract-class">abstract class</dt>
<dd>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that cannot be instantiated. Usually used to contain
common predicates that are inherited by other classes.</dd>
<dt id="term-abstract-method">abstract method</dt>
<dd>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> implementing an algorithm whose step corresponds
to calls to methods defined in the descendants of the object (or
<a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>) containing it.</dd>
<dt id="term-adapter-file">adapter file</dt>
<dd>A Prolog source file defining a minimal abstraction layer between
the Logtalk compiler/runtime and a specific
<a class="reference internal" href="#term-backend-prolog-compiler"><span class="xref std std-term">backend Prolog compiler</span></a>.</dd>
<dt id="term-ancestor">ancestor</dt>
<dd>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> or a parent <a class="reference internal" href="#term-prototype"><span class="xref std std-term">prototype</span></a> that contributes (via
inheritance) to the definition of an object. For class-based hierarchies,
the ancestors of an instance are its class(es) and all the superclasses
of its class(es). For prototype-based hierarchies, the ancestors of
a prototype are its parent(s) and the ancestors of its parent(s).</dd>
<dt id="term-backend-prolog-compiler">backend Prolog compiler</dt>
<dd>The Prolog compiler that is used to host and run Logtalk and that is
called for compiling the intermediate Prolog code generated by the
Logtalk compiler when compiling source files.</dd>
<dt id="term-built-in-method">built-in method</dt>
<dd>A predefined <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> that can be called from within any object
or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>. Built-in methods cannot be redefined.</dd>
<dt id="term-built-in-predicate">built-in predicate</dt>
<dd>A predefined predicate that can be called from anywhere. Built-in
predicates can be redefined within objects and
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>.</dd>
<dt id="term-category">category</dt>
<dd>A set of predicates directives and clauses that can be (virtually)
imported by any object. Categories support composing objects using
fine-grained units of code reuse and also <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> of
existing objects. A category should be functionally-cohesive,
defining a single functionality.</dd>
<dt id="term-class">class</dt>
<dd>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> that specializes another object, interpreted as its
superclass. Classes define the common predicates of a set of objects
that instantiates it. An object can also be interpreted as a class
when it instantiates itself.</dd>
<dt id="term-closed-world-assumption">closed-world assumption</dt>
<dd>The assumption that what cannot be proved true is false. Therefore,
sending a message corresponding to a <em>declared</em> but not <em>defined</em>
predicate, or calling a declared predicate with no clauses, fails.
But messages or calls to undeclared predicates generate an error.</dd>
<dt id="term-coinductive-predicate">coinductive predicate</dt>
<dd>A predicate whose calls are proved using greatest fixed point
semantics. Coinductive predicates allows reasoning about
infinite rational entities such as cyclic terms and ω-automata.</dd>
<dt id="term-complementing-category">complementing category</dt>
<dd>A category used for <a class="reference internal" href="#term-hot-patching"><span class="xref std std-term">hot patching</span></a> an existing object (or a
set of objects).</dd>
<dt id="term-directive">directive</dt>
<dd>A source file term that affects the interpretation of source code.
Directives use the <code class="docutils literal notranslate"><span class="pre">(:-)/1</span></code> prefix operator as functor.</dd>
<dt id="term-doclet-file">doclet file</dt>
<dd>A source file whose main purpose is to generate documentation for
e.g. a <a class="reference internal" href="#term-library"><span class="xref std std-term">library</span></a> or an application.</dd>
<dt id="term-doclet-object">doclet object</dt>
<dd>An object specifying the steps necessary to (re)generate the API
documentation for a project. See the <code class="docutils literal notranslate"><span class="pre">doclet</span></code> and <code class="docutils literal notranslate"><span class="pre">lgtdoc</span></code>
tools for details.</dd>
<dt id="term-dynamic-binding">dynamic binding</dt>
<dd>Runtime lookup of a predicate declaration and definition to verify
the validity of a message (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>) and find the predicate
definition that will be used to answer the message (or the super call).
Also known as <em>late binding</em>. See also <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a>.</dd>
<dt id="term-encapsulation">encapsulation</dt>
<dd>The hiding of an object implementation. This promotes software reuse
by isolating the object clients from its implementation details.
Encapsulation is enforced in Logtalk by using
<a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">predicate scope directives</span></a>.</dd>
<dt id="term-entity">entity</dt>
<dd>Generic name for Logtalk compilation units: <a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>,
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>, and <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocols</span></a>.
Entities share a single namespace (i.e. entity
<a class="reference internal" href="#term-identity"><span class="xref std std-term">identifiers</span></a> must be unique).</dd>
<dt id="term-entity-directive">entity directive</dt>
<dd>A directive that affects how Logtalk entities (<a class="reference internal" href="#term-object"><span class="xref std std-term">objects</span></a>,
<a class="reference internal" href="#term-category"><span class="xref std std-term">categories</span></a>, or <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocols</span></a>) are
used or compiled.</dd>
<dt id="term-event">event</dt>
<dd>The sending of a <a class="reference internal" href="#term-message"><span class="xref std std-term">message</span></a> to an object. An event can be
expressed as an ordered tuple: <code class="docutils literal notranslate"><span class="pre">(Event,</span> <span class="pre">Object,</span> <span class="pre">Message,</span> <span class="pre">Sender)</span></code>.
Logtalk distinguish between the sending of a message — <code class="docutils literal notranslate"><span class="pre">before</span></code>
event — and the return of control to the sender — <code class="docutils literal notranslate"><span class="pre">after</span></code> event.</dd>
<dt id="term-grammar-rule">grammar rule</dt>
<dd>An alternative notation for predicates used to parse or generate
sentences on some language. This notation hides the arguments used to
pass the sequences of tokens being processed, thus simplifying the
representation of grammars. Grammar rules are represented using as
functor the infix operator <code class="docutils literal notranslate"><span class="pre">(--&gt;)/2</span></code> instead of the <code class="docutils literal notranslate"><span class="pre">(:-)/2</span></code>
operator used with predicate clauses.</dd>
<dt id="term-grammar-rule-non-terminal">grammar rule non-terminal</dt>
<dd>A syntactic category of words or phrases. A non-terminal is
identified by its <em>non-terminal indicator</em>, i.e. by its name and
number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name//Arity</span></code>.</dd>
<dt id="term-grammar-rule-terminal">grammar rule terminal</dt>
<dd>A word or basic symbol of a language.</dd>
<dt id="term-hook-object">hook object</dt>
<dd>An object, implementing the <code class="docutils literal notranslate"><span class="pre">expanding</span></code> built-in protocol,
defining term- and goal-expansion predicates, used in the compilation
of Logtalk or Prolog source files. A hook object can be specified
using the <a class="reference internal" href="userman/programming.html#flag-hook"><span class="std std-ref">hook</span></a> compiler flag. It can also be
specified using a <a class="reference internal" href="refman/directives/set_logtalk_flag_2.html#directives-set-logtalk-flag-2"><span class="std std-ref">set_logtalk_flag/2</span></a> directive in
the source files to be expanded.</dd>
<dt id="term-hot-patching">hot patching</dt>
<dd>The act of fixing entity directives and predicates or adding new
entity directives and predicates to loaded entities in a running
application without requiring access to the entities source code
or restarting the application.</dd>
<dt id="term-identity">identity</dt>
<dd>Property of an entity that distinguishes it from every other entity.
The identifier of an entity is its functor (i.e. its name and arity),
which must be unique. Object and <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> identifiers can be
atoms or compound terms. Protocol identities must be atoms. All Logtalk
entities (objects, protocols, and categories) share the same namespace.</dd>
<dt id="term-inheritance">inheritance</dt>
<dd>An entity inherits predicate directives and clauses from related
entities. In the particular case of objects, when an object extends
other object, we have prototype-based inheritance. When an object
specializes or instantiates another object, we have class-based
inheritance.</dd>
<dt id="term-instance">instance</dt>
<dd>An object that instantiates another object, interpreted as its
<a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a>.</dd>
<dt id="term-instantiation">instantiation</dt>
<dd>The process of creating a new class instance. In Logtalk, this does
not necessarily imply dynamic creation of an object at runtime; an
instance may also be defined as a static object in a source file.</dd>
<dt id="term-lambda-expression">lambda expression</dt>
<dd>A compound term that can be used in place of a goal or closure
meta-argument and that abstracts a predicate definition by listing
its variables and a callable term that implements the definition.
Lambda expressions help avoiding the need of naming and defining
auxiliary predicates.</dd>
<dt id="term-lambda-free-variable">lambda free variable</dt>
<dd>A variable that is global to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All
used global variables must be explicitly listed in a lambda
expression.</dd>
<dt id="term-lambda-parameter">lambda parameter</dt>
<dd>A term (usually a variable or a non-ground compound term) that is
local to a <a class="reference internal" href="#term-lambda-expression"><span class="xref std std-term">lambda expression</span></a>. All lambda parameters must
be explicitly enumerated in a lambda expression.</dd>
<dt id="term-library">library</dt>
<dd>A directory containing source files. The library name can be used as
an alias to the directory path when compiling and loading source
files using the notation <code class="docutils literal notranslate"><span class="pre">library_name('source_file_relative_path')</span></code>.
Library names and their paths are defined using the
<a class="reference internal" href="refman/predicates/logtalk_library_path_2.html#predicates-logtalk-library-path-2"><span class="std std-ref">logtalk_library_path/2</span></a> predicate.</dd>
<dt id="term-loader-file">loader file</dt>
<dd>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load a set of
source files.</dd>
<dt id="term-local-predicate">local predicate</dt>
<dd>A predicate that is defined in an object (or in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>)
but that is not listed in a scope directive. These predicates behave
like private predicates but are invisible to the reflection
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in methods</span></a>. Local predicates are
usually auxiliary predicates and only relevant to the entity where
they are defined.</dd>
<dt id="term-message">message</dt>
<dd>A query sent to an object. In logical terms, a message can be seen as
a request for proof construction using an object database and the
databases of related entities.</dd>
<dt id="term-message-to-self">message to self</dt>
<dd>A message sent to the object that received the original message under
processing. Messages to self require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> as the
value of self is only know at runtime.</dd>
<dt id="term-meta-argument">meta-argument</dt>
<dd>A predicate argument that is called as a goal, used as a closure
to construct a goal that will be called, or that is handled in a
way that requires awareness of the predicate calling context.</dd>
<dt id="term-meta-interpreter">meta-interpreter</dt>
<dd>A program capable of running other programs written in the same
language.</dd>
<dt id="term-meta-predicate">meta-predicate</dt>
<dd>A predicate with one or more <a class="reference internal" href="#term-meta-argument"><span class="xref std std-term">meta-arguments</span></a>.
For example, <a class="reference internal" href="refman/methods/call_N.html#methods-call-n"><span class="std std-ref">call/1-N</span></a> and <a class="reference internal" href="refman/methods/findall_3.html#methods-findall-3"><span class="std std-ref">findall/3</span></a> are
built-in meta-predicates.</dd>
<dt id="term-metaclass">metaclass</dt>
<dd>The <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> of a class, when interpreted as an instance.
Metaclass instances are themselves classes.</dd>
<dt id="term-method">method</dt>
<dd>The predicate definition used to answer a message sent to an object.
Logtalk supports both <a class="reference internal" href="#term-static-binding"><span class="xref std std-term">static binding</span></a> and <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>
to find which method to run to answer a message.</dd>
<dt id="term-module">module</dt>
<dd>A Prolog entity characterized by an identity and a set of predicate
directives and clauses. Prolog modules are usually static although
some Prolog systems allow the creation of dynamic modules at runtime.
Prolog modules can be seen as prototypes.</dd>
<dt id="term-monitor">monitor</dt>
<dd>Any object, implementing the <code class="docutils literal notranslate"><span class="pre">monitoring</span></code> built-in protocol, that
is notified by the runtime when a spied event occurs. The spied
<a class="reference internal" href="#term-event"><span class="xref std std-term">events</span></a> can be set by the monitor itself or by any
other object.</dd>
<dt id="term-multifile-predicate">multifile predicate</dt>
<dd>A predicate whose clauses can be defined in multiple
<a class="reference internal" href="#term-entity"><span class="xref std std-term">entities</span></a>. The object or category holding the
directive without an entity prefix qualifying the predicate holds
the multifile predicate <em>primary declaration</em>, which consists of
both a <a class="reference internal" href="#term-predicate-scope-directive"><span class="xref std std-term">scope directive</span></a> and a
<code class="docutils literal notranslate"><span class="pre">multifile/1</span></code> directive for the predicate.</dd>
<dt id="term-object">object</dt>
<dd>An entity characterized by an <a class="reference internal" href="#term-identity"><span class="xref std std-term">identity</span></a> and a set of predicate
directives and clauses. Logtalk objects can be either static or
dynamic. Logtalk objects can play the <em>role</em> of classes, instances,
or prototypes. The role or roles an object plays are a function of
its relations with other objects.</dd>
<dt id="term-object-database">object database</dt>
<dd>The set of predicates locally defined inside an object.</dd>
<dt id="term-parameter">parameter</dt>
<dd>An argument of a parametric object or a parametric category identifier.
Parameters are <em>logical variables</em> implicitly shared by all the entity
predicate clauses.</dd>
<dt id="term-parameter-variable">parameter variable</dt>
<dd>A variable used as parameter in a parametric object or a parametric
category using the syntax <code class="docutils literal notranslate"><span class="pre">_VariableName_</span></code>. Occurrences of
parameter variables in entity clauses are implicitly unified with the
corresponding entity parameters.</dd>
<dt id="term-parametric-category">parametric category</dt>
<dd>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</dd>
<dt id="term-parametric-entity">parametric entity</dt>
<dd>An <a class="reference internal" href="#term-object"><span class="xref std std-term">object</span></a> or <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> whose <a class="reference internal" href="#term-identity"><span class="xref std std-term">identifier</span></a>
is a compound term possibly containing free variables that can be used
to parameterize the entity predicates. Parameters are <em>logical variables</em>
implicitly shared by all the entity clauses. Note that the identifier
of a parametric entity is its functor, irrespective of the possible
values of its arguments (e.g. <code class="docutils literal notranslate"><span class="pre">foo(bar)</span></code> and <code class="docutils literal notranslate"><span class="pre">foo(baz)</span></code> are
different parameterizations of the same parametric entity, <code class="docutils literal notranslate"><span class="pre">foo/1</span></code>).</dd>
<dt id="term-parametric-object">parametric object</dt>
<dd>See <a class="reference internal" href="#term-parametric-entity"><span class="xref std std-term">parametric entity</span></a>.</dd>
<dt id="term-parametric-object-proxy">parametric object proxy</dt>
<dd>A compound term (usually represented as a plain Prolog fact) with
the same name and number of arguments as the identifier of a parametric
object.</dd>
<dt id="term-parent">parent</dt>
<dd>A prototype that is extended by another prototype.</dd>
<dt id="term-predicate">predicate</dt>
<dd>Predicates describe what is true about the application domain. A
predicate is identified by its <em>predicate indicator</em>, i.e. by its
name and number of arguments using the notation <code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>.</dd>
<dt id="term-predicate-alias">predicate alias</dt>
<dd>An alternative functor (<code class="docutils literal notranslate"><span class="pre">Name/Arity</span></code>) for a predicate. Predicate
aliases can be defined for any inherited predicate using the <code class="docutils literal notranslate"><span class="pre">alias/2</span></code>
directive and for predicates listed in <code class="docutils literal notranslate"><span class="pre">uses/2</span></code> and <code class="docutils literal notranslate"><span class="pre">use_module</span></code>
directives. Predicate aliases can be used to solve inheritance conflicts
and to improve code clarity by using alternative names that are more
meaningful in the calling context.</dd>
<dt id="term-predicate-directive">predicate directive</dt>
<dd>A directive that affects how predicates are called or compiled.</dd>
<dt id="term-predicate-scope-container">predicate scope container</dt>
<dd>The object that inherits a predicate declaration from an imported
<a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> or an implemented <a class="reference internal" href="#term-protocol"><span class="xref std std-term">protocol</span></a>.</dd>
<dt id="term-predicate-scope-directive">predicate scope directive</dt>
<dd>A directive that declares a predicate by specifying its visibility
(public, protected, or private).</dd>
<dt id="term-primary-predicate-declaration">primary predicate declaration</dt>
<dd>See <a class="reference internal" href="#term-multifile-predicate"><span class="xref std std-term">multifile predicate</span></a>.</dd>
<dt id="term-private-inheritance">private inheritance</dt>
<dd>All public and protected predicates are inherited as private
predicates.</dd>
<dt id="term-private-predicate">private predicate</dt>
<dd>A predicate that can only be called from the object that contains
the scope directive.</dd>
<dt id="term-profiler">profiler</dt>
<dd>A program that collects data about other program performance.</dd>
<dt id="term-protected-inheritance">protected inheritance</dt>
<dd>All public predicates are inherited as protected. No scope change
for protected or private predicates.</dd>
<dt id="term-protected-predicate">protected predicate</dt>
<dd>A predicate that can only be called from the object containing the
scope directive or from an object that inherits the predicate.</dd>
<dt id="term-protocol">protocol</dt>
<dd>An entity that contains predicate declarations. A predicate is
declared using a scope directive. It may be further specified by
additional predicate directives. Protocols support the separation
between interface and implementation, can be implemented by both
objects and categories, and can be extended by other protocols. A
protocol should be functionally-cohesive, specifying a single
functionality.</dd>
<dt id="term-prototype">prototype</dt>
<dd>A self-describing object that may extend or be extended by other
objects. An object with no instantiation or specialization relations
with other objects is always interpreted as a prototype.</dd>
<dt id="term-public-inheritance">public inheritance</dt>
<dd>All inherited predicates maintain their declared scope.</dd>
<dt id="term-public-predicate">public predicate</dt>
<dd>A predicate that can be called from any object.</dd>
<dt id="term-self">self</dt>
<dd>The object that received the message under processing.</dd>
<dt id="term-sender">sender</dt>
<dd>An object that sends a message to other object. When a message is
sent from within a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, the <em>sender</em> is the object
importing the category.</dd>
<dt id="term-settings-file">settings file</dt>
<dd>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a>, compiled and loaded at Logtalk startup, mainly
defining default values for compiler flags that override the
defaults found on the backend Prolog compiler
<a class="reference internal" href="#term-adapter-file"><span class="xref std std-term">adapter files</span></a>.</dd>
<dt id="term-singleton-method">singleton method</dt>
<dd>A <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a> defined in an <a class="reference internal" href="#term-instance"><span class="xref std std-term">instance</span></a> itself. Singleton
methods are supported in Logtalk and can also be found in other
object-oriented programming languages.</dd>
<dt id="term-source-file">source file</dt>
<dd>A text file defining Logtalk and/or Prolog code. Multiple Logtalk
entities may be defined in a single source file. Plain Prolog code
may be intermixed with Logtalk entity definitions.</dd>
<dt id="term-source-file-directive">source file directive</dt>
<dd>A directive that affects how a <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> is compiled.</dd>
<dt id="term-specialization">specialization</dt>
<dd>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> is specialized by defining a new class that inherit its
predicates and possibly add new ones.</dd>
<dt id="term-static-binding">static binding</dt>
<dd>Compile time lookup of a predicate declaration and definition when
compiling a message sending call (or a <a class="reference internal" href="#term-super-call"><span class="xref std std-term">super call</span></a>). Dynamic
binding is used whenever static binding is not possible (e.g. due to
the predicate being dynamic or due to lack of enough information at
compilation time). Also known as <em>early binding</em>. See also
<a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a>.</dd>
<dt id="term-subclass">subclass</dt>
<dd>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> that is a specialization, direct or indirectly, of
another class.</dd>
<dt id="term-super-call">super call</dt>
<dd>Call of an inherited (or imported) predicate definition. Mainly used
when redefining an inherited (or imported) predicate to call the
overridden definition while making additional calls. Super calls preserve
self and may require <a class="reference internal" href="#term-dynamic-binding"><span class="xref std std-term">dynamic binding</span></a> if the predicate is dynamic.</dd>
<dt id="term-superclass">superclass</dt>
<dd>A <a class="reference internal" href="#term-class"><span class="xref std std-term">class</span></a> from which another class is a specialization
(directly or indirectly via another class).</dd>
<dt id="term-synchronized-predicate">synchronized predicate</dt>
<dd>A synchronized predicate is protected by a mutex ensuring that, in
a multi-threaded application, it can only be called by a single
thread at a time.</dd>
<dt id="term-template-method">template method</dt>
<dd>See <a class="reference internal" href="#term-abstract-method"><span class="xref std std-term">abstract method</span></a>.</dd>
<dt id="term-tester-file">tester file</dt>
<dd>A <a class="reference internal" href="#term-source-file"><span class="xref std std-term">source file</span></a> whose main purpose is to load and a run a set of
unit tests.</dd>
<dt id="term-this">this</dt>
<dd>The object that contains the predicate clause under execution. When
the predicate clause is contained in a <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a>, <em>this</em> is a
reference to the object importing the category for which the
predicate clause is being executed.</dd>
<dt id="term-threaded-engine">threaded engine</dt>
<dd>A computing thread running a goal whose solutions can be lazily and
concurrently computed and retrieved. A threaded engine also supports
a term queue that allows passing arbitrary terms to the engine. This
queue can be used to pass e.g. data and new goals to the engine.</dd>
<dt id="term-visible-predicate">visible predicate</dt>
<dd>A predicate that is within scope, a locally defined predicate, a
<a class="reference internal" href="#term-built-in-method"><span class="xref std std-term">built-in method</span></a>, a Logtalk built-in predicate, or a Prolog
built-in predicate.</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bibliography.html" class="btn btn-neutral float-right" title="Bibliography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="faq/support.html" class="btn btn-neutral" title="Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Paulo Moura

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>